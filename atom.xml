<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[loop in codes]]></title>
  <link href="http://codemacro.com/atom.xml" rel="self"/>
  <link href="http://codemacro.com/"/>
  <updated>2018-01-24T19:11:23+08:00</updated>
  <id>http://codemacro.com/</id>
  <author>
    <name><![CDATA[Kevin Lynx]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[基于Yarn的分布式应用调度器Slider]]></title>
    <link href="http://codemacro.com/2018/01/24/apache-slider/"/>
    <updated>2018-01-24T00:00:00+08:00</updated>
    <id>http://codemacro.com/2018/01/24/apache-slider</id>
    <content type="html"><![CDATA[<p>Apache Hadoop Map-Reduce
框架为了解决规模增长问题，发展出了yarn。而yarn不仅解决Map-Reduce调度问题，还成为了一个通用的分布式应用调度服务。yarn中的一个创新是把各种不同应用的调度逻辑拆分到了一个称为Application
Manager(以下简称AM)的角色中，从而让yarn自己变得更通用，同时解决调度性能问题。Apache
Slider就是这其中的一个AM具体实现。但Slider进一步做了通用化，可以用于调度长运行(long-running)的分布式应用。</p>

<p>为了更好地理解Slider/Yarn，需要思考这样一个问题：在不用Slider/Yarn这种自动部署并管理应用的软件时，我们如何在一个网络环境中部署一个分布式应用？</p>

<ul>
<li>可能需要在目标物理机上创建虚拟容器，指定容器所用的CPU核数、内存数</li>
<li>到容器中下载或复制应用运行所需的所有软件包</li>
<li>可能需要改写应用所需的各种配置</li>
<li>运行应用，输入可能很长的命令行参数</li>
</ul>


<p>注意这些操作需要在所有需要运行的容器中执行，当然现在也有很多自动部署的工具可以解决这些问题。但是，当应用首次部署运行起来后，继续思考以下问题：</p>

<ul>
<li>某台机器物理原因关机，对应的应用实例不可服务，如何自动发现故障并迁移该实例</li>
<li>应用有突发流量，需要基于当前运行中的版本做扩容</li>
<li>应用需要更新</li>
</ul>


<h2>架构</h2>

<p>看一下yarn的总体架构：</p>

<p><img src="http://codemacro.com/assets/res/yarn.png" alt="" /></p>

<!-- more -->


<p>yarn管理的每台机器上都会部署Node Manager (简称NM)，NM主要用于创建容器，用户的应用运行在这个容器中。一台机器可能会跑多个应用的实例(Instance)。Resource Manager
(简称RM)用于管理整个集群的资源，例如CPU、内存。App Master(Manager) (简称AM) 用于管理容器中用户的应用。AM本身也运行在容器中。</p>

<p>通过Client提交AM的请求到RM中，RM找到一个可用的NM并启动该AM。随后，AM与RM交互，为应用请求各种资源，并发出应用的部署请求。在运行期间，AM会监视应用每个实例的正确性，以在假设有机器挂掉后，申请新的资源来自动恢复该实例。</p>

<p>为了更具体地了解这个过程，可以先参考<a href="https://hadoop.apache.org/docs/stable/hadoop-yarn/hadoop-yarn-site/WritingYarnApplications.html">Writing YARN Applications</a>。</p>

<p>Slider是AM的一种实现，接下来从以下几个方面来了解Slider：</p>

<ul>
<li>Slider架构</li>
<li>如何描述一个应用</li>
<li>使用流程及主要接口</li>
<li>如何定制</li>
<li>其他细节</li>
</ul>


<h2>Slider架构</h2>

<p>借图(<a href="http://www.weixinnu.com/tag/article/2086961513">Slider设计理念与基本架构</a>)：</p>

<p><img src="http://codemacro.com/assets/res/slider.jpeg" alt="" /></p>

<p>作为一个Yarn AM其结构与之前描述的相差无几。Slider Client是一个命令行程序，它直接与RM交互，提交一个Slider AM包给RM。RM分配资源并配合NM启动Slider AM这个服务程序。Slider AM在启动目标应用时，通常会在目标容器中部署一个Slider
Agent。这个Agent实现了一套与不同应用之间的交互协议，例如：INSTALL/CONFIGURE/START/STOP/STATUS，应用一般通过Python脚本实现这些协议命令，就可以被Slider部署起来。</p>

<h2>如何描述一个应用</h2>

<p>完整地描述一个应用，就可以让第三方调度器，例如Slider，自动地部署应用、迁移应用。在Slider中描述一个应用，主要分为3部分内容：</p>

<ul>
<li>资源描述，resources.json，例如单实例所需要的CPU核数、内存数，总共需要多少实例</li>
<li>应用特定的配置描述，appConfig.json，例如Java应用JVM的内存配置</li>
<li>应用适配协议，这个不是配置文件，一般是Python脚本，实现一个应用实例如何安装、如何启动</li>
</ul>


<p>除了以上内容外，Slider认为一个完整的分布式应用可能包含多个组件(Component)，例如HBase包含Master、Worker。应用描述还应该包含各个组件的描述，例如每个组件可以有自己的资源需求。Component也被称为Role(可能不准确，但意思接近)。当有多个Component时，可以配置每个Component的优先级，高优先级的Component优先得到资源分配。</p>

<p>例如，一个<code>resource.json</code>例子，主要就是指定各个Component的资源：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "schema": "http://example.org/specification/v2.0.0",
</span><span class='line'>
</span><span class='line'>  "metadata": {
</span><span class='line'>    "description": "example of a resources file"
</span><span class='line'>  },
</span><span class='line'>
</span><span class='line'>  "global": {
</span><span class='line'>    "yarn.vcores": "1",
</span><span class='line'>    "yarn.memory": "512"
</span><span class='line'>  },
</span><span class='line'>
</span><span class='line'>  "components": {
</span><span class='line'>    "master": {
</span><span class='line'>      "instances": "1",
</span><span class='line'>      "yarn.vcores": "1",
</span><span class='line'>      "yarn.memory": "1024"
</span><span class='line'>    },
</span><span class='line'>    "worker": {
</span><span class='line'>      "instances":"5",
</span><span class='line'>      "yarn.vcores": "1",
</span><span class='line'>      "yarn.memory": "512"
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>appConfig.json</code>主要就是应用相关的配置参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "schema": "http://example.org/specification/v2.0.0",
</span><span class='line'>
</span><span class='line'>  "global": {
</span><span class='line'>
</span><span class='line'>    "zookeeper.port": "2181",
</span><span class='line'>    "zookeeper.path": "/yarnapps_small_cluster",
</span><span class='line'>    "zookeeper.hosts": "zoo1,zoo2,zoo3",
</span><span class='line'>  },
</span><span class='line'>  "components": {
</span><span class='line'>    "worker": {
</span><span class='line'>      "jvm.heapsize": "512M"
</span><span class='line'>    },
</span><span class='line'>    "master": {
</span><span class='line'>      "jvm.heapsize": "512M"
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>  "credentials" {
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在Slider中，应用需要将这些配置信息以及应用自己部署所需要的各种软件包，按照规范打成一个压缩包。然后使用slider工具提交，slider工具会将包上传至HDFS上。</p>

<p>可以通过<a href="http://slider.incubator.apache.org/docs/slider_specs/hello_world_slider_app.html">Hello World Slider App</a>获得直观的印象。</p>

<h2>使用流程及主要接口</h2>

<p>使用Slider主要就是使用其客户端工具<code>slider</code>。要通过Slider启动一个应用，主要步骤如下：</p>

<ul>
<li>准备好应用包，配置资源描述resources.json、应用配置appConfig.json、开发适配协议脚本。</li>
<li>打包并上传，通过<code>slider install-package</code>完成</li>
<li>提交并部署，通过<code>slider create</code>完成</li>
</ul>


<p>其中，应用的部署和AM自身的部署是一起提交的。在应用部署好后，后续的运维操作都可以通过<code>slider</code>工具完成，例如：</p>

<ul>
<li>对应用做扩缩容: <code>./slider flex cl1 --component worker 5</code></li>
<li>对应用做更新：<code>slider upgrade MyHBase_Facebook_Finance --components HBASE_MASTER HBASE_REGIONSERVER</code></li>
</ul>


<p>对应用做更新时，Slider文档中指出不可以同时做扩缩容。另外，如果更新过程中有部分容器坏掉自动替换，可能会自动更新为新版本。在更新过程中，Slider并不做更新过程的维护，即用户需要自己指定当前希望哪些容器得到更新（或全部更新），用户通过slider工具检查这些容器的版本是否达到预期，并继续更新下一批容器。过程大体如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># 上传更新包
</span><span class='line'>slider package --install --name MyHBase_Facebook --version 2.0 --package ~/slider-hbase-app-package_v2.0.zip
</span><span class='line'># upgrades the internal state 
</span><span class='line'>slider upgrade MyHBase_Facebook_Finance --template ~/myHBase_appConfig_v2.0.json --resources ~/myHBase_resources_v2.0.json
</span><span class='line'># 重复以下步骤，根据应用的需求更新各个容器
</span><span class='line'>slider upgrade MyHBase_Facebook_Finance --containers id1 id2 .. idn</span></code></pre></td></tr></table></div></figure>


<p>如果应用有多个Component，Component之间的更新一般是有顺序的，这里Slider交给用户自己去控制。用户也可以控制容器之间的更新间隔。</p>

<p>更新过程的细节参考<a href="http://slider.incubator.apache.org/docs/slider_specs/application_pkg_upgrade.html">Rolling Upgrade</a>。</p>

<h2>如何定制</h2>

<p>Slider中有一个概念叫<code>Provider</code>。provider可以理解为为了支持特定应用类型而开发的插件，以让Slider部署这些特殊的应用。默认的provider就是前面提到的slider agent。这个agent是一堆Python脚本，定义了与应用交互的各种协议。实现自己的provider，需要实现client端和server端。client端会被slider client (前面提到的<code>slider</code>工具)调用，可以用于添加应用所需要的特殊包，以提交为Slider AM。而server端主要指的是Slider AM端，可以定制具体部署应用时的行为，例如部署自己定制的agent。</p>

<p>具体provider例子可以参考源码中slider-providers子项目。</p>

<h2>其他细节</h2>

<p>以下细节仅供记录，未深入了解。</p>

<h3>服务发现</h3>

<p>服务发现用于解决分布式系统中上游服务如何发现下游服务实例，以发出RPC调用。Slider中依靠Yarn的服务发现机制，目前主要是通过zookeeper来自动对服务做注册。参考<a href="http://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/registry/yarn-registry.html">The Yarn Service Registry</a>。</p>

<h3>资源分配策略</h3>

<p>Slider在请求yarn分配容器时，可以配置不同的策略，这个称为<code>Placement Policy</code>。例如是否优先跑在打有特殊标签的机器上，或者跑在特定的机架(rack)上。这里的资源标签就是一些普通的文本，例如给一个机器打上<code>gpu</code>标签，而分配容器时，也只是简单的匹配，并没有看到互斥、多标签组合等功能。分配策略可以解决带数据应用的机器亲近性，当应用实例发生迁移时，优先在有历史数据的机器上部署，可以获得更快的启动速度。</p>

<p>具体参考<a href="https://slider.incubator.apache.org/docs/placement.html">Apache Slider Placement</a>。</p>

<h2>总结</h2>

<p>翻看了Slider的文档及部分源码，主要功能了解得七七八八。Slider虽然可以自动调度起一个应用，但是一个用于生产环境的调度器还要在很多细节上做得出色，例如：</p>

<ul>
<li>需要与服务发现深度结合。应用实例在服务发现中的状态能够参与到调度器的调度中，例如是否能做到对上游应用透明地更新</li>
<li>应用实例与agent交互时，STATUS需要表达应用确实可提供服务，并且在运行期间持续透出可服务状态</li>
<li>调度整个集群时，是否能对失败节点做容错，是否会自动recover这些失败节点，也就是我们说的基于目标式的调度实现(level-triggered)</li>
<li>应用的更新是日常运维的常态，更新语义应该基于百分比，而不是基于容器；更新既然是常态，调度器就该处理好在这期间集群里可能发生的任何事情，例如有容器被自动替换</li>
</ul>


<p class='post-footer'>
            原文地址：
            <a href='http://codemacro.com/2018/01/24/apache-slider/'>http://codemacro.com/2018/01/24/apache-slider/</a><br/>
            written by <a href='http://codemacro.com'>Kevin Lynx</a>
            &nbsp;posted at <a href='http://codemacro.com'>http://codemacro.com</a>
            </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python协程greenlet实现原理]]></title>
    <link href="http://codemacro.com/2018/01/17/greenlet/"/>
    <updated>2018-01-17T00:00:00+08:00</updated>
    <id>http://codemacro.com/2018/01/17/greenlet</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/python-greenlet/greenlet">greenlet</a>是<a href="https://wiki.python.org/moin/StacklessPython">stackless
Python</a>中剥离出来的一个项目，可以作为官方CPython的一个扩展来使用，从而支持Python协程。<a href="http://www.gevent.org/">gevent</a>正是基于greenlet实现。</p>

<h2>协程实现原理</h2>

<p>实现协程主要是在协程切换时，将协程当前的执行上下文保存到协程关联的context中。在c/c++这种native程序中实现协程，需要将栈内容和CPU各个寄存器的内容保存起来。在Python这种VM中则有些不同。例如，在以下基于greenlet协程的python程序中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def foo():
</span><span class='line'>    bar()
</span><span class='line'>
</span><span class='line'>def bar():
</span><span class='line'>    a = 3 + 1
</span><span class='line'>    gr2.switch()
</span><span class='line'>
</span><span class='line'>def func():
</span><span class='line'>    pass
</span><span class='line'>
</span><span class='line'>gr1 = greenlet(foo)
</span><span class='line'>gr2 = greenlet(func)
</span><span class='line'>gr1.switch()</span></code></pre></td></tr></table></div></figure>


<p>在<code>bar</code>中<code>gr2.switch</code>切换到gr2时，协程库需要保存gr1协程的执行上下文。这个上下文包括:</p>

<ul>
<li>Python VM的stack</li>
<li>Python VM中解释执行的上下文</li>
</ul>


<!-- more -->


<p>理解以上两点非常重要，至于为什么呢？想象一下如何去实现一个Python
VM，去解释执行一段Python代码。其实这在任何基于VM的语言中，原理都是一样的（native程序可以把x86物理CPU也视作特殊的VM)。可以参考<a href="http://python.jobbole.com/81660/">Python解释器简介-深入主循环</a>。主要包含两方面内容：</p>

<ul>
<li>VM在执行代码时，其自身调用栈通常都是递归的</li>
<li>VM在执行代码时，通常会创建相应的数据结构来表示代码执行块，例如通常会有个<code>struct Frame</code>来表示一个函数</li>
</ul>


<p>在VM的实现中通常会有类似以下的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Frame {
</span><span class='line'>    unsigned char *codes; // 存放代码指令
</span><span class='line'>    size_t pc; // 当前执行的指令位置
</span><span class='line'>    int *stack; // stack-based的VM会有一个栈用于存放指令操作数
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>void op_call(frame) {
</span><span class='line'>    switch (OP_CODE()) {
</span><span class='line'>        case OP_CALL:
</span><span class='line'>            child_frame = new_frame()
</span><span class='line'>            op_call(child_frame)
</span><span class='line'>                ...
</span><span class='line'>        case OP_ADD:
</span><span class='line'>            op_add(...)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>对应到前面的Python例子代码，在某一时刻VM的call stack可能是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>op_add
</span><span class='line'>op_call
</span><span class='line'>op_call</span></code></pre></td></tr></table></div></figure>


<p>理解了以上内容后，就可以推测出greenlet本质上也是做了以上两件事。</p>

<h2>greenlet实现原理</h2>

<p>greenlet库中每一个协程称为一个greenlet。greenlet都有一个栈空间，如下图：</p>

<p><img src="http://codemacro.com/assets/res/greenlet.png" alt="" /></p>

<p>图中未表达出来的，greenlet的栈空间地址可能是重叠的。对于活跃的（当前正在运行）的greenlet，其栈内容必然在c程序栈顶。而不活跃的被切走的greenlet，其栈内容会被copy到新分配的堆内存中。greenlet的栈空间是动态的，其起始地址是固定的，但栈顶地址不固定。以下代码展示一个greenlet的栈空间如何确定：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>579         if (!PyGreenlet_STARTED(target)) { // greenlet未启动，是一个需要新创建的greenlet
</span><span class='line'>580             void* dummymarker; // 该局部变量的地址成为新的greenlet的栈底
</span><span class='line'>581             ts_target = target;
</span><span class='line'>582             err = g_initialstub(&dummymarker); // 创建该greenlet并运行</span></code></pre></td></tr></table></div></figure>


<p>以上<code>greenlet-&gt;stack_stop</code>确定了栈底，而栈顶则是动态的，在切换到其他greenlet前，对当前greenlet进行上下文的保存时，获取当前的RSP（程序实际运行的栈顶地址）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>410 static int GREENLET_NOINLINE(slp_save_state)(char* stackref)
</span><span class='line'>411 {
</span><span class='line'>412     /* must free all the C stack up to target_stop */
</span><span class='line'>413     char* target_stop = ts_target-&gt;stack_stop;
</span><span class='line'>414     PyGreenlet* owner = ts_current;
</span><span class='line'>415     assert(owner-&gt;stack_saved == 0);
</span><span class='line'>416     if (owner-&gt;stack_start == NULL)
</span><span class='line'>417         owner = owner-&gt;stack_prev;  /* not saved if dying */
</span><span class='line'>418     else
</span><span class='line'>419         owner-&gt;stack_start = stackref; // stack_start指向栈顶</span></code></pre></td></tr></table></div></figure>


<p><code>stackref</code>是通过汇编获取当前RSP寄存器的值：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> __asm__ ("movl %%esp, %0" : "=g" (stackref));</span></code></pre></td></tr></table></div></figure>


<p>保存栈内容到堆内存参看<code>g_save</code>的实现，没什么特别的。除了保存栈内容外，如上一节讲的，还需要保存VM执行函数所对应的<code>Frame</code>对象，这个在<code>g_switchstack</code>中体现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>460         PyThreadState* tstate = PyThreadState_GET(); // 获取当前线程的VM执行上下文
</span><span class='line'>461         current-&gt;recursion_depth = tstate-&gt;recursion_depth;
</span><span class='line'>462         current-&gt;top_frame = tstate-&gt;frame; // 保存当前正在执行的frame到当前正在执行的greenlet
</span><span class='line'>    ...
</span><span class='line'>473         slp_switch(); // 做栈切换
</span><span class='line'>    ...
</span><span class='line'>487         PyThreadState* tstate = PyThreadState_GET();
</span><span class='line'>488         tstate-&gt;recursion_depth = target-&gt;recursion_depth;
</span><span class='line'>489         tstate-&gt;frame = target-&gt;top_frame; // 切换回来
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码展示VM frame的切换。接下来看下最复杂的部分，当切换到目标greenlet时，如何恢复目标greenlet的执行上下文，这里主要就是恢复目标greenlet的栈空间。假设有如下greenlet应用代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def test1():
</span><span class='line'>    gr2.switch()
</span><span class='line'>
</span><span class='line'>def test2():
</span><span class='line'>    print('test2')
</span><span class='line'>
</span><span class='line'>gr1 = greenlet(test1)
</span><span class='line'>gr2 = greenlet(test2)
</span><span class='line'>gr1.switch()
</span></code></pre></td></tr></table></div></figure>


<p>在gr1中切换到gr2时，也就是<code>gr2.switch</code>，会发生什么事情。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// g_switch 实现
</span><span class='line'>574         if (PyGreenlet_ACTIVE(target)) {
</span><span class='line'>575             ts_target = target; // 找到目标greenlet，也就是gr2
</span><span class='line'>576             err = g_switchstack(); // 开始切换
</span><span class='line'>
</span><span class='line'>// g_switchstack 实现
</span><span class='line'>462         current-&gt;top_frame = tstate-&gt;frame;
</span><span class='line'>    ...
</span><span class='line'>473     err = slp_switch();
</span><span class='line'>
</span><span class='line'>// slp_switch 实现，根据不同平台实现方式不同，原理相同
</span><span class='line'>69         SLP_SAVE_STATE(stackref, stsizediff);
</span><span class='line'>// 这个很重要，强行将当前的栈指针ESP/EBP (32位OS)通过加上一个与目标greenlet栈地址的偏移，而回到了
</span><span class='line'>// 目标greenlet的栈空间。可以在下文看到stsizediff的获取实现
</span><span class='line'>70         __asm__ volatile (
</span><span class='line'>71             "addl %0, %%esp\n"
</span><span class='line'>72             "addl %0, %%ebp\n"
</span><span class='line'>73             :
</span><span class='line'>74             : "r" (stsizediff)
</span><span class='line'>75             );
</span><span class='line'>76         SLP_RESTORE_STATE();
</span><span class='line'>
</span><span class='line'>// SLP_SAVE_STATE 实现
</span><span class='line'>316 #define SLP_SAVE_STATE(stackref, stsizediff)            \
</span><span class='line'>317     stackref += STACK_MAGIC;                        \
</span><span class='line'>318     if (slp_save_state((char*)stackref)) return -1; \
</span><span class='line'>319     if (!PyGreenlet_ACTIVE(ts_target)) return 1;    \
</span><span class='line'>// 获取目标greenlet的栈空间与当前栈地址的偏移，用于稍后设置当前栈地址回目标greenlet的栈地址
</span><span class='line'>320     stsizediff = ts_target-&gt;stack_start - (char*)stackref 
</span><span class='line'>
</span><span class='line'>// slp_save_state 没啥看的，前面也提过了，主要就是复制当前greenlet栈内容到堆内存
</span><span class='line'>
</span><span class='line'>// SLP_RESTORE_STATE 也没什么看的，主要就是把greenlet堆内存复制回栈空间</span></code></pre></td></tr></table></div></figure>


<p>以上，首先将ESP/EBP的值改回目标greenlet当初切换走时的ESP/EBP值，然后再把greenlet的栈空间内存（存放于堆内存中）全部复制回来，就实现了greenlet栈的回切。尤其注意的是，这个栈中是保存了各种函数的return地址的，所以当<code>slp_switch</code>返回时，就完全恢复到了目标greenlet当初被切走时栈上的内容，包括各种函数调用栈。而当前greenlet的栈，则停留在了类似以下的函数调用栈：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>g_switchstack
</span><span class='line'>g_switch
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<h2>参考</h2>

<ul>
<li><a href="https://www.shymonk.com/posts/2016/06/stackless-python-tan-mi/">Stackless Python 探秘</a></li>
<li><a href="http://blog.csdn.net/permike/article/details/54846675">python协程的实现（greenlet源码分析)</a></li>
<li><a href="http://blog.csdn.net/yueguanghaidao/article/details/24281751">深度分析gevent运行流程</a></li>
</ul>


<p class='post-footer'>
            原文地址：
            <a href='http://codemacro.com/2018/01/17/greenlet/'>http://codemacro.com/2018/01/17/greenlet/</a><br/>
            written by <a href='http://codemacro.com'>Kevin Lynx</a>
            &nbsp;posted at <a href='http://codemacro.com'>http://codemacro.com</a>
            </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[写了一个棋牌游戏服务器框架]]></title>
    <link href="http://codemacro.com/2017/12/12/chess-gameserver/"/>
    <updated>2017-12-12T00:00:00+08:00</updated>
    <id>http://codemacro.com/2017/12/12/chess-gameserver</id>
    <content type="html"><![CDATA[<p>最近业余时间写了一个棋牌游戏服务端框架：<a href="https://github.com/kevinlynx/pigy">pigy</a>。对于棋牌游戏服务端框架，我的定义是：</p>

<ul>
<li>分布式的</li>
<li>包含网络棋牌游戏中包括登陆、大厅、游戏框架、数据持久化等基础组件</li>
<li>提供具体游戏框架，游戏逻辑程序员可以基于这个框架focus在游戏的开发上</li>
</ul>


<p>写得差不多的时候，我在网上搜索了下，发现棋牌游戏源码已经烂大街，自己精力有限，也没有心思和动力去研究现有实现的优缺点而做出一个更好的替代。所以我这份实现仅作为一个demo放出来让大家开心下好了。</p>

<p><a href="https://github.com/kevinlynx/pigy">pigy</a>基于<a href="https://github.com/cloudwu/skynet">skynet</a>实现。之所以选择skynet是看中其中已经有不少网络游戏基础组件可以使用，结合开发下来稍微花点业余时间就可以完成雏形。除此之外，部分源码也参考/复制了<a href="https://github.com/fztcjjl/metoo">metoo</a>项目。</p>

<!-- more -->


<h2>架构</h2>

<p><img src="https://i.imgur.com/7RLkaWm.png" alt="" /></p>

<p>服务器主要有3类角色：</p>

<ul>
<li>Login，登陆/账号服务器，负责玩家账号相关</li>
<li>Hall，大厅服务器，职责包括：

<ul>
<li>获取玩家信息及公告推送等独立于具体游戏的逻辑</li>
<li>房间相关管理，分配玩家到游戏服务器</li>
</ul>
</li>
<li>Game，游戏服务器，包装具体的游戏，提供游戏运行框架</li>
</ul>


<p>我希望除了Game之外，Login和Hall都具备高可用性，例如可水平扩展，在挂掉后对玩家无影响。要做到这一点就要对服务器的状态数据做较好的管理，以实现挂掉后要么玩家被自动迁移到其他服务，要么挂掉的服务重启后可以快速恢复之前的数据。对于Login/Hall而言最主要的状态数据就是玩家的登陆数据，由于数据简单，可以选择直接持久化到redis并且不需要落盘。redis就可以作为单点，保存全服的数据。这样，Login/Hall还可以水平扩展，动态根据实例数分摊全服玩家数据。</p>

<p>但是我只是实现了一个阉割版。我暂时不希望太过依赖redis，所以我让Login/Hall互相作为数据备份。Login和Hall本身就持有玩家的登陆数据，可以在对方挂掉重启后，自动恢复数据。为了恢复数据时简单可靠，我让Login作为单点存在。毕竟，Login并不与Client保持长连接，也没有除了登陆外其他更复杂的逻辑，加上skynet多线程的特性，性能上单点就足够支撑。</p>

<p>Hall是支持水平扩展的。Login可以按玩家uid一致性哈希地选择一个Hall，其实按普通取模哈希也没有什么问题。1个Hall实例挂掉后，Client启动重连定时器，预期能在短时间内重新启动完成这个挂掉的Hall。</p>

<p>Game (server)肯定是支持水平扩展的。我在Game中抽象了Gamelet概念，本质上就是一个具体的游戏。Gamelet可以部署到任意一个Game内，Game单实例可以跑多个Gamelet。Hall会定期查询所有Game的Gamelet实时情况。Gamelet的实时情况主要包括某具体游戏关联的所有房间信息。Hall聚合这些信息，主要确定两方面信息：</p>

<ul>
<li>哪些Game加载了哪些Gamelet，主要用于在Hall上创建房间</li>
<li>某具体的Game有哪些房间，一般用于Client展示游戏房间信息</li>
</ul>


<p>各个Server角色之间通信全部依靠skynet Cluster机制，节省了不少工作。</p>

<h2>账号处理</h2>

<p>Login最开始是完全基于skynet <a href="https://github.com/cloudwu/skynet/wiki/loginServer">Login Server</a>实现。但是涉及到账号相关的功能还包括：</p>

<ul>
<li>游客账号及自有注册账号</li>
<li>账号绑定</li>
</ul>


<p>所以扩展了LoginServer，在原有协议上增加了扩展命令，搞得类似HTTP协议的URI。</p>

<h2>消息及RPC</h2>

<p>除了Login使用文本协议外，Hall/Game都使用基于skynet <a href="https://github.com/cloudwu/skynet/wiki/GateServer">Gate Server</a>的长度+消息体的格式，而消息体又使用protobuf格式。为了支持消息的派发，将消息值映射到skynet service method上，类似于简单的RPC：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>消息code值 -&gt; 消息code到service.method字符串映射 -&gt; 找到对应的service，调用其method</span></code></pre></td></tr></table></div></figure>


<p>这里也可以使用云风提供的<a href="https://github.com/cloudwu/skynet/wiki/Sproto">sproto</a>。本质上都是解决消息格式编码及消息dispatch问题。</p>

<h2>断线重连</h2>

<p>断线重连主要牵涉到几个问题：</p>

<ul>
<li>玩家的状态数据不能依赖socket的状态</li>
<li>server间对于玩家数据一般有鉴权处理，Client断线重连时可以直接携带token直连某个server，而不用走重新登陆逻辑</li>
<li>server对client数据做重连补发</li>
</ul>


<p>其中，重连补发根据实现又分为两种情况：</p>

<ul>
<li>基于断线协议，在server框架层，或者整个游戏服务器组的统一接入层自动解决。例如<a href="https://github.com/ejoy/goscon">goscon</a></li>
<li>在应用层解决，一般就是游戏内根据具体游戏重发全量游戏数据到Client</li>
</ul>


<p>在pigy中，我认为更简单可靠的做法是在应用层解决。当然，一些前提还是得实现的。例如玩家在线状态不基于socket、server间传递token以支持Client直连server。</p>

<h2>数据持久化及缓存</h2>

<p>持久化及缓存是基于三层结构：本地内存、redis缓存、mysql。mysql作为关系型数据库，其表里的每一行记录，都会映射为redis中的一个哈希表。哈希表自身由db table name 及该行关键值确定，id可以作为关键值。而为了获取该数据库表里所有行，又将所有行的index字段(配置)作为redis一个有序集合关联起来。这样，通过获取redis有序集合所有元素，就可以获取该数据库表所有行记录。</p>

<p>例如，有玩家表：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>id | name | age |
</span><span class='line'>---|------|-----|
</span><span class='line'>1  | kev  | 18  |
</span><span class='line'>---|------|-----|
</span><span class='line'>2  | john | 20  |
</span></code></pre></td></tr></table></div></figure>


<p>映射到redis中，就会得到2个哈希表，对应2行；另外得到一个有序集合，根据配置，集合中存储了所有<code>id</code>字段值。</p>

<p>然后，基于以上结构，可以配置有些数据库表，是需要在启动时全部载入内存，而有些数据，例如玩家数据，由于数据会很多，并且很多数据并不需要，所以就只载入一部分。整个游戏的数据会根据玩家uid进行分区(partition)，redis可以以独立集群的模式启动多个集群，然后玩家数据根据uid分区存储到这些redis中。</p>

<h2>游戏框架</h2>

<p>网络棋牌游戏中有很多子游戏，所以游戏框架是肯定需要的。游戏框架主要用来抽象/隔离各种底层细节，包括网络数据发送、同房间玩家数据获取、数据持久化等等。设计上主要就是包装，但是目前的实现还不完整。pigy将子游戏抽象为gamelet，类似于servlet。这个抽象本质上就是与框架交互协议的包装，以及框架对一些数据的接口化透出。</p>

<p>例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function init(source) -- 将房间service传入
</span><span class='line'>    room = source
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>function accept.enter(user) -- 某个玩家进入该房间
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>pigy中某个Game (server)是可以载入多个gamelet的。所以在Hall端会聚合出来某个游戏(gamelet)在哪些Game上部署，以在其上创建房间。</p>

<h2>网关</h2>

<p>网关服务器主要用于隔离内部服务器与外网，避免受到恶意攻击。在早期我并不想花精力去重写一个Gate (server)，同时我希望Gate的加入应该尽可能少地对其他服务造成侵入。所以这造成了一种困境，因为在Game上的通信不太方便实现为Req/Resp的模式，所以现成的类似nginx TCP的网关也用不上，自己写优先级也不高，所以直到目前我也没有花时间去实现一个出来。</p>

<h2>如何运行</h2>

<p>准备好skynet，然后参考doc/guide.md。</p>

<h2>总结</h2>

<p>网络游戏服务器毕竟是分布式系统，在框架层面，稳定性及可扩展性是比较有趣的问题。在移动网络游戏方面，断线重连又是无法逃避的问题。这些问题要做得完美还是很不容易。</p>

<p class='post-footer'>
            原文地址：
            <a href='http://codemacro.com/2017/12/12/chess-gameserver/'>http://codemacro.com/2017/12/12/chess-gameserver/</a><br/>
            written by <a href='http://codemacro.com'>Kevin Lynx</a>
            &nbsp;posted at <a href='http://codemacro.com'>http://codemacro.com</a>
            </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[协程并发模型及使用感受]]></title>
    <link href="http://codemacro.com/2017/12/03/coroutine/"/>
    <updated>2017-12-03T00:00:00+08:00</updated>
    <id>http://codemacro.com/2017/12/03/coroutine</id>
    <content type="html"><![CDATA[<p>协程可以简单理解为更轻量的线程，但有很多显著的不同：</p>

<ul>
<li>不是OS级别的调度单元，通常是编程语言或库实现</li>
<li>可能需要应用层自己切换</li>
<li>由于切换点是可控制的，所以对于CPU资源是非抢占式的</li>
<li>通常用于有大量阻塞操作的应用，例如大量IO</li>
</ul>


<p>协程与actor模式的实现有一定关系。由于协程本身是应用级的并发调度单元，所以理论上可以大量创建。在协程之上做队列及通信包装，即可得到一个actor框架，例如<a href="https://github.com/jrydberg/python-actors">python-actor</a></p>

<p>最近1年做了一个python项目。这个项目中利用gevent wsgi对外提供HTTP API，使用gevent greelet来支撑上层应用的开发。当可以使用协程后，编程模型会得到一定简化，例如相对于传统线程池+队列的并发实现，协程可以抛弃这个模型，直接一个协程对应于一个并发任务，例如网络服务中一个协程对应一个socket fd。</p>

<p>但是python毕竟是单核的，这个项目内部虽然有大量IO请求，但随着业务增长，CPU很快就到达了瓶颈。后来改造为多进程结构，将业务单元分散到各个worker进程上。</p>

<p>python gevent中的协议切换是自动的，在遇到阻塞操作后gevent会自动挂起当前协程，并切换到其他需要激活的协程。阻塞操作完成，对应的协程就会处于待激活状态。</p>

<p>在这个项目过程中，我发现协程也存在很多陷阱。</p>

<!-- more -->


<h2>协程的陷阱</h2>

<ul>
<li>死循环</li>
</ul>


<p>普通的死循环很难遇到，间接的死循环一旦发生，就会一直占用CPU资源，导致其他协程被饿死。</p>

<ul>
<li>留意非协程化的阻塞接口</li>
</ul>


<p>gevent中通常会将python内置的各种阻塞操作green化，也就是我这里说的协程化，例如socket IO接口、time.sleep、各种锁等待。如果在系统中引入一个不能被协程化的库，例如<a href="https://github.com/farcepest/MySQLdb1">MySQL-python</a>。当协程被阻塞在这种库的接口时，协程不能被切走，而是等到python内线程的抢占式切换，实际上对于gevent的协程调度其总计可用的CPU就不是100%了。在压力较大的情况下，协程就可能出现延迟调度。意思是在协程阻塞操作完成后，在负载较小的情况下，该协程会立即得到切换。</p>

<p>这里有一个小技巧，可以写一个time.sleep延时的协程，检查真实的延时情况和time.sleep的延时参数相差多少，就可以衡量整个系统中协程切换的延时情况。</p>

<ul>
<li>注意不同角色协程的CPU资源分配</li>
</ul>


<p>这个问题本质上类似于在基于线程的应用中，需要为不同角色的线程设定不同的优先级。在多核程序中由于总的CPU资源比较多，所以一般也不会遇到需要分配不同优先级的情况。但在基于协程的单核程序中，由于单核CPU资源很快就会被压榨到80-90%，所以就需要关注不同角色协程的优先级。</p>

<p>例如，系统中有用于服务HTTP API的协程集，有用于做耗时任务的协程集。耗时任务正常情况下可能需要分钟级，所以做任务的协程就算慢几秒也没什么关系。但是对外提供API的协程，本身API时延就在毫秒到秒级，如果晚几秒到几十秒，对上游系统或者用于就会造成不良的影响，表现为服务质量差。</p>

<p>但是通常协程库是没有设定优先级的功能的。所以这个时候就要从应用层解决。例如前面的耗时任务例子，一般情况下，为了编程简单，我们会为每一个任务分配一个协程去做。由于所有协程优先级相同，大家被切换的机会是均等的，那么当任务增多后，API相关的协程获得的切换机会更少，影响服务质量。所以这个时候，就会创建一个用于完成耗时任务的协程池，以限制耗时任务占用的总协程数量。这就又回到了基于线程的并发模型中。</p>

<ul>
<li>留意协程切换</li>
</ul>


<p>在gevent这种协程切换不需要程序员显示操作的协程库中，程序员会慢慢忘掉自己是在协程环境下编程。前面的例子中，我们创建了一个协程池去限制耗时任务可用的协程数量。在实际项目中可能会对调度做一些包装，让应用层只关注自己的业务代码。那么，在业务代码中，对于一些需要重试的失败操作，我sleep一段较长的时间也很合情理吧。这个时候如果由于外部依赖服务异常，而导致部分业务协程失败，处于sleep中。这个时候，协程池内有限的协程都被挂起了。导致很多本来可以获得CPU资源的任务无法得到消费，导致整个系统的吞吐量下降。</p>

<h2>总结</h2>

<p>协程会在低CPU系统中获得不少易于编程的好处，但是当系统总CPU上去后就需要付出等价于甚至大于多线程编程中的代价。</p>

<p class='post-footer'>
            原文地址：
            <a href='http://codemacro.com/2017/12/03/coroutine/'>http://codemacro.com/2017/12/03/coroutine/</a><br/>
            written by <a href='http://codemacro.com'>Kevin Lynx</a>
            &nbsp;posted at <a href='http://codemacro.com'>http://codemacro.com</a>
            </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实现一个memcache proxy]]></title>
    <link href="http://codemacro.com/2017/05/18/memcache-proxy/"/>
    <updated>2017-05-18T00:00:00+08:00</updated>
    <id>http://codemacro.com/2017/05/18/memcache-proxy</id>
    <content type="html"><![CDATA[<p>通常我们会使用多台memcached构成一个集群，通过客户端库来实现缓存数据的分片(replica)。这会带来2个主要问题：</p>

<ul>
<li>memcached机器连接数过多</li>
<li>不利于做整体的服务化；缺少可运维性。例如想对接入的客户端做应用级隔离；或者对缓存数据做多区域(机房)的冗余</li>
</ul>


<p>实现一个memcache proxy，相对于减少连接数来说，主要可以提供更多的扩展性。目前已经存在一些不错的memcache proxy，例如twitter的<a href="https://github.com/twitter/twemproxy">twemproxy</a>，facebook的<a href="https://github.com/facebook/mcrouter">mcrouter</a>。稍微调研了下，发现twemproxy虽然轻量，但功能较弱；mcrouter功能齐全，类似多区域多写的需求也满足。处于好玩的目的，之前又读过网络库<a href="http://codemacro.com/2017/04/09/xnio-source/">xnio</a>源码，我还是决定自己实现一个。</p>

<!-- more -->


<p>这个项目简单取名为<a href="https://github.com/kevinlynx/kvproxy">kvproxy</a>，通过简单的抽象可以实现为memcache或redis等key-value形式的服务proxy。 这是一些预想中的<a href="https://github.com/kevinlynx/kvproxy/blob/master/design.md">feature</a>。</p>

<p>在目前的阶段，主要关注于其性能。因为memcached本身的RT非常小，所以这个proxy的性能就要求比较高。这里主要先关注下核心功能的实现。</p>

<h2>架构</h2>

<p>如下图：</p>

<p><img src="http://i.imgur.com/VxrSdKT.png" alt="" /></p>

<ul>
<li><code>Service</code>，用于抽象key-value服务，如memcache；<code>MemcacheService</code>是其实现之一</li>
<li><code>ServerLocator</code>，用于定位memcached机器列表，例如<code>ConstantLocator</code>则是从配置文件中读取。可以实现一个从名字服务读取列表的locator。</li>
<li><code>Connection</code>，配合<code>KVProxy</code>，基于xnio，表示一个与客户端的连接</li>
<li><code>ConnectionListener</code>，用于处理网络连接上的请求，例如<code>RequestHandler</code>则是<code>MemcaheService</code>中的listener，用于处理从客户端发过来的memcache协议请求</li>
<li><code>MemClient</code>，包装memcache客户端，用于proxy将请求转发到后端的memcache服务</li>
<li><code>GroupClient</code>，包装<code>MemClient</code>，可以用于多区域数据的同时写入，目前实现为单个primary及多个slave。写数据同步写入primary异步写入slave；读取数据则只从primary读。</li>
</ul>


<p>本身要抽象的东西不复杂，所以结构其实是很简单的，也没有花太多心思。接下来关注下性能方面的问题。</p>

<h2>异步性</h2>

<p>作为一个proxy，异步基本是必然选择的方案，指的是，proxy在收到memcache的请求时，不阻塞当前的IO线程，形成一个请求context，在收到回应时拿到这个context来回应客户端。这样通过增加消耗的内存，来释放CPU资源，可以让IO模块尽可能多地接收从客户端来的请求。当然，如果请求过多，可能就会耗尽内存。</p>

<p>为了简单，我没有自己实现memcache client。网络上有很多开源的memcache client。我试了几个，例如<a href="http://codemacro.com/2017/04/23/xmemcached/">xmemcached</a>(为此还读过它的源码)，但由于这些客户端都是同步的，虽然可以自己起线程池来把同步包装为异步，但始终不是最优方案。最后无意发现了<a href="https://github.com/spotify/folsom">folsom</a>，集成到kvproxy后性能表现还不错。当然，真正要做到性能最优，最好还是自己实现memcache client，这样可以使用同一个xnio reactor，不用开那么多IO线程，拿到数据后就可以直接得到ByteBuffer，应该可以减少内存拷贝操作(能提高多少也不确定)。</p>

<h2>性能测试</h2>

<p>我使用了<a href="https://github.com/RedisLabs/memtier_benchmark">memtier_benchmark</a>来做压力测试。测试环境是16core的虚拟机(宿主机不同)，benchmark工具同目标测试服务部署在不同的机器，proxy同memcache部署在相同机器。目标服务基于OS centos7，测试命令为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./memtier_benchmark -s 127.0.0.1 -p 22122 -P memcache_text --test-time 60 -d 4096 --hide-histogram</span></code></pre></td></tr></table></div></figure>


<p>默认开启4个压测线程，每个线程建立50个连接，测试60秒，默认设置是1:10的set/get。</p>

<p>首先是直接压测memcached：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ALL STATS
</span><span class='line'>========================================================================
</span><span class='line'>Type        Ops/sec     Hits/sec   Misses/sec      Latency       KB/sec
</span><span class='line'>------------------------------------------------------------------------
</span><span class='line'>Sets        5729.65          ---          ---      3.27500     23141.85
</span><span class='line'>Gets       57279.42        80.33     57199.09      3.16000      1771.99
</span><span class='line'>Waits          0.00          ---          ---      0.00000          ---
</span><span class='line'>Totals     63009.07        80.33     57199.09      3.17000     24913.84</span></code></pre></td></tr></table></div></figure>


<p>然后我压测了twitter的twemproxy，RT差不多增加70%。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ALL STATS
</span><span class='line'>========================================================================
</span><span class='line'>Type        Ops/sec     Hits/sec   Misses/sec      Latency       KB/sec
</span><span class='line'>------------------------------------------------------------------------
</span><span class='line'>Sets        3344.58          ---          ---      5.58400     13508.68
</span><span class='line'>Gets       33430.28        40.00     33390.28      5.41900      1006.32
</span><span class='line'>Waits          0.00          ---          ---      0.00000          ---
</span><span class='line'>Totals     36774.85        40.00     33390.28      5.43400     14515.00
</span></code></pre></td></tr></table></div></figure>


<p>最后是压测kvproxy (jdk8)，只与memcache建立一个连接，RT增加95%，基本上翻倍。不过由于是Java实现，相对于twemproxy的C实现感觉也不差。当然，机器资源消耗更大(主要是内存)。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ALL STATS
</span><span class='line'>========================================================================
</span><span class='line'>Type        Ops/sec     Hits/sec   Misses/sec      Latency       KB/sec
</span><span class='line'>------------------------------------------------------------------------
</span><span class='line'>Sets        2959.41          ---          ---      6.62400     11953.00
</span><span class='line'>Gets       29578.47        33.90     29544.57      6.20800       884.38
</span><span class='line'>Waits          0.00          ---          ---      0.00000          ---
</span><span class='line'>Totals     32537.88        33.90     29544.57      6.24600     12837.37
</span></code></pre></td></tr></table></div></figure>


<p>压测中IO线程CPU并没有跑满，推测是虚拟机之间的网络带宽还是不够。</p>

<p class='post-footer'>
            原文地址：
            <a href='http://codemacro.com/2017/05/18/memcache-proxy/'>http://codemacro.com/2017/05/18/memcache-proxy/</a><br/>
            written by <a href='http://codemacro.com'>Kevin Lynx</a>
            &nbsp;posted at <a href='http://codemacro.com'>http://codemacro.com</a>
            </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xmemcached源码阅读]]></title>
    <link href="http://codemacro.com/2017/04/23/xmemcached/"/>
    <updated>2017-04-23T00:00:00+08:00</updated>
    <id>http://codemacro.com/2017/04/23/xmemcached</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/killme2008/xmemcached">Xmemcached</a> 是一个memcached客户端库。由于它提供的是同步API，而我想看下如何增加异步接口。所以就大致浏览了下它的源码。</p>

<h2>主要结构</h2>

<p>针对memcache客户端的实现，主要结构如下：</p>

<p><img src="http://i.imgur.com/7r4Y35O.jpg" alt="" /></p>

<ul>
<li><code>XMemcachedClient</code> 是应用主要使用的类，所有针对memcache的接口都在这里</li>
<li><code>Command</code> 用于抽象二进制协议或文本协议下各个操作，这里称为Command。<code>CommandFactory</code> 用于创建这些command</li>
<li><code>MemcachedSessionLocator</code> 用于抽象不同的负载均衡策略，或者说数据分布策略。在一个memcached集群中，数据具体存放在哪个replica中，主要就是由这个类的实现具体的，例如<code>KetamaMemcachedSessionLocator</code> 实现了一致性哈希策略</li>
<li><code>MemcachedConnector</code> 包装了网络部分，与每一个memcached建立连接后，就得到一个<code>Session</code>。command的发送都在<code>MemcachedConnector</code>中实现</li>
<li>各个Session类/接口，则涉及到Xmemcached使用的网络库yanf4j。这个库也是Xmemcached作者的。</li>
</ul>


<!-- more -->


<p>Command 类的实现中有个关键的<code>CountDownLatch</code>。在将Command通过session发送出去之后，就利用这个latch同步等待，等到网络模块收到数据后回调。Command会和session绑定，在这个session上收到数据后，就认为是这个command的回应。</p>

<p>由于本身memcached库核心东西比较少，上面的结构也就很好理解。协议的抽象和数据分布策略的抽象是必须的。接下来看看网络实现部分。</p>

<h2>网络实现</h2>

<p>Xmemcached的网络实现主要结构如下：</p>

<p><img src="http://i.imgur.com/pwGjcgQ.jpg" alt="" /></p>

<ul>
<li><code>SocketChannelController</code>，主要的类，将IO事件通知转交给session</li>
<li><code>NioController</code>，主要关注其成员<code>SelectorManagrer</code></li>
<li><code>SelectorManager</code> 内置若干个<code>Reactor</code>，数量由CPU核数决定</li>
<li><code>Reactor</code>，IO事件的产生器，一个Reactor对应一个线程，线程循环中不断轮询NIO selector是否产生了IO事件</li>
<li><code>CodecFactory</code>，编解码网络消息接口</li>
<li><code>PoolDispatcher</code> ，Dispatcher 用于调度一个IO事件的具体处理过程，而<code>PoolDispatcher</code>则是放到一个单独的线程池中处理</li>
<li><code>DispatcherFactory</code> ，用于创建具体的dispatcher</li>
</ul>


<p>这个网络实现还是比较典型的Reactor模式。其中，产生IO事件后，IO事件的具体处理，默认交给了一个独立的线程池。一般网络库都会提供类似的机制，以使得IO线程不至于被业务逻辑阻塞住，导致IO处理效率下降。</p>

<p>写数据时，数据都会写到一个队列中，在设备可写时才具体写入。看下具体的读数据过程：</p>

<p><img src="http://i.imgur.com/N7XqVS7.jpg" alt="" /></p>

<p>从Reactor中最终调用到Xmemcached的command，用于具体解析回应数据。要调整为异步的话，则可以修改Command的实现，增加异步回调。同时注意控制dispatcher使用的线程池。</p>

<p>完。</p>

<p class='post-footer'>
            原文地址：
            <a href='http://codemacro.com/2017/04/23/xmemcached/'>http://codemacro.com/2017/04/23/xmemcached/</a><br/>
            written by <a href='http://codemacro.com'>Kevin Lynx</a>
            &nbsp;posted at <a href='http://codemacro.com'>http://codemacro.com</a>
            </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XNIO源码阅读]]></title>
    <link href="http://codemacro.com/2017/04/09/xnio-source/"/>
    <updated>2017-04-09T00:00:00+08:00</updated>
    <id>http://codemacro.com/2017/04/09/xnio-source</id>
    <content type="html"><![CDATA[<p><a href="http://xnio.jboss.org/">XNIO</a>是JBoss的一个IO框架。最开始我想找个lightweight servlet container库，于是看到了<a href="http://undertow.io/">undertow</a>，发现其网络部分使用的就是XNIO。所以干脆就先把XNIO的源码读下。</p>

<p>XNIO文档非常匮乏，能找到都是<a href="https://docs.jboss.org/author/display/XNIO/About+XNIO">3.0的版本</a>，而且描述也不完全。Git上已经出到3.5.0。我读的是3.3.6.Final。</p>

<h2>使用方式</h2>

<p>可以参考<a href="https://github.com/ecki/xnio-samples/blob/master/src/main/java/org/xnio/samples/SimpleEchoServer.java">SimpleEchoServer.java</a>，不过这个例子使用的API已经被deprecated，仅供参考。使用方式大致为：</p>

<ul>
<li>创建服务，提供acceptListener</li>
<li>在acceptListener中accept新的连接，并注册连接listener</li>
<li>在连接listener回调中完成IO读写</li>
</ul>


<!-- more -->


<h2>主要概念</h2>

<ul>
<li>Channel，基本上同Java NIO中的Channel一致，一个server socket是一个channel，accept出来的连接也是channel</li>
<li>ChannelListener，监听Channel上的IO事件，应用代码与XNIO交互的地方</li>
<li>XnioWorker，维护IO线程池及应用任务线程池</li>
</ul>


<h2>项目结构</h2>

<p>源码分为两个项目: xnio-api及nio-impl。xnio-api属于API层；nio-impl是基于NIO的实现。通过Java service provider动态地找到nio-impl这个实现。可见XNIO还可以用其他方式来实现。</p>

<p><code>org.xnio.channels</code>这个包里包含了大量的Channel接口定义，这个是非常恶心的一个地方，读代码的时候很容易被绕进去。这个包主要的实现后面提。<code>org.xnio.conduits</code>，我理解为比Channel更底层的传输通道，channel依赖于conduit实现，总之也是个恶心的概念。</p>

<h2>线程模型</h2>

<p>可以通过连接如何建立以及建立连接后如何管理连接来了解XNIO的线程模型。通过这个过程我简单画了下主要类关系以及连接建立过程：</p>

<p><img src="http://i.imgur.com/HoL99Wz.png" alt="" /></p>

<p><em>用的Dia绘图，UML图支持得不够好</em></p>

<p>XNIO的线程模型是一个典型的one loop per thread的Reactor模型。<code>WorkerThread</code>类就是这个线程，其有一个主循环，不断地检测其关心的IO设备是否有IO事件发生。当有事件发生时，就将事件通知给关心的listener。站在上层模块的角度，这个线程就是一个Reactor，事件产生器。整个系统有固定数量的<code>WorkerThread</code>，也就是IO线程数。这个模型基本上凡是基于epoll/select模型实现的网络库都会用，例如<a href="http://codemacro.com/2014/05/04/muduo-source/">muduo</a>。可以回看下这个模型：</p>

<p><img src="http://codemacro.com/assets/res/muduo-model.png" alt="" /></p>

<p>XNIO中接收到一个新连接时，会根据这个连接的地址(remote&amp;local address)算出一个哈希值，然后根据哈希值分配到某一个IO线程，然后该连接以后的IO事件都由该线程处理。<code>WorkerThread</code>会始终回调<code>NioHandle</code>。<code>QueuedNioTcpServerHandle</code>是一个accept socket，监听accept事件。而<code>NioSocketStreamConnection</code>则是一个建立好的连接，每次新连接进来就会创建，被哈希到某个<code>WorkerThread</code>处理。<code>NioSocketConduit</code>是一个连接具体关心IO事件的类，正是前面提到的，是一个Channel的底层实现。</p>

<p><code>NioXnioWorker</code>继承于<code>XnioWorker</code>，<code>XnioWorker</code>内部包含了一个应用任务的线程池。应用代码通过channel listener获取到IO事件通知，channel listener是在IO线程中回调的，所以不适合做耗时操作，否则会导致IO线程中其他IO设备饿死。所以对于这类任务就可以放到这个线程池中做。</p>

<h2>Channel架构</h2>

<p>前面提到的XNIO例子使用了一个deprecated的接口，那如何不使用这个接口呢？这就需要更具体地了解channel。XNIO中抽象的channel有很多类型，有些是只读的，有些是只写的，有些则是全双工的。channel还能被组合 (<code>AssembledChannel</code>)。可以看下3.1里channel包的大图：<a href="http://docs.jboss.org/xnio/3.1/api/org/xnio/channels/package-summary.png">channel package summary</a></p>

<p>这里我只关注基于TCP服务中的channel。如图：</p>

<p><img src="http://i.imgur.com/BjmU3BJ.png" alt="" /></p>

<p>重点关注 <code>QueuedNioTcpServer</code> 及 <code>NioSocketStreamConnection</code>。<code>QueuedNioTcpServer</code>实现<code>AcceptingChannel</code> 没什么好说的，就是表示一个可以接收连接的channel。<code>NioSocketStreamConnection</code>表示一个网络连接。<code>StreamConnection</code>是一个可读可写的channel，但是其内部是通过另外两个channel来实现的，分别是<code>ConduitStreamSourceChannel</code>及<code>ConduitStreamSinkChannel</code>，分别用读和写。这两个channel内部其实是分别通过两个conduit 来实现，分别为<code>ConduitStreamSourceChannel</code> 及 <code>ConduitStreamSinkChannel</code> 。</p>

<p><code>NioSocketStreamConnection</code> 内部包含<code>NioSocketConduit</code>，这个类实现了 <code>ConduitStreamSourceChannel</code> 及 <code>ConduitStreamSinkChannel</code> 。在TCP场景下，<code>StreamConnection</code>中的读写channel正是指向了<code>NioSocketConduit</code>。这个层次包装得有点绕，需要慢慢梳理。</p>

<p>在accept的时候，得到的可以是<code>StreamConnection</code>，其实也就是得到了一个可读可写的channel，设计得也没问题。可以基于这个channel设置读写listener。但是如果想在读listener里发起写操作，由于在读listener里看到的是一个只读的channel，所以就没办法写。所以才会有其他包装的channel。</p>

<p>理清了以上关系，就可以不用那个deprecated的API来实现一个echo server：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">ReadListener</span> <span class="kd">implements</span> <span class="n">ChannelListener</span><span class="o">&lt;</span><span class="n">StreamSourceChannel</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="c1">// 保存一个可写的channel，才能在读listener里做写操作</span>
  <span class="kd">private</span> <span class="n">StreamSinkChannel</span> <span class="n">sinkChannel</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">ReadListener</span><span class="o">(</span><span class="n">StreamSinkChannel</span> <span class="n">sinkChannel</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">sinkChannel</span> <span class="o">=</span> <span class="n">sinkChannel</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleEvent</span><span class="o">(</span><span class="n">StreamSourceChannel</span> <span class="n">channel</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">ByteBuffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="mi">512</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">res</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="k">while</span> <span class="o">((</span><span class="n">res</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">buffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>
        <span class="n">Channels</span><span class="o">.</span><span class="na">writeBlocking</span><span class="o">(</span><span class="n">sinkChannel</span><span class="o">,</span> <span class="n">buffer</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="n">Channels</span><span class="o">.</span><span class="na">flushBlocking</span><span class="o">(</span><span class="n">sinkChannel</span><span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">res</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">channel</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">channel</span><span class="o">.</span><span class="na">resumeReads</span><span class="o">();</span>
      <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
      <span class="n">IoUtils</span><span class="o">.</span><span class="na">safeClose</span><span class="o">(</span><span class="n">channel</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="kd">final</span> <span class="n">ChannelListener</span><span class="o">&lt;</span><span class="n">AcceptingChannel</span><span class="o">&lt;</span><span class="n">StreamConnection</span><span class="o">&gt;&gt;</span> <span class="n">acceptListener</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ChannelListener</span><span class="o">&lt;</span><span class="n">AcceptingChannel</span><span class="o">&lt;</span><span class="n">StreamConnection</span><span class="o">&gt;&gt;()</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleEvent</span><span class="o">(</span><span class="n">AcceptingChannel</span><span class="o">&lt;</span><span class="n">StreamConnection</span><span class="o">&gt;</span> <span class="n">channel</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">StreamConnection</span> <span class="n">accepted</span><span class="o">;</span>
      <span class="c1">// channel is ready to accept zero or more connections</span>
      <span class="k">while</span> <span class="o">((</span><span class="n">accepted</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="na">accept</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;accepted &quot;</span>
            <span class="o">+</span> <span class="n">accepted</span><span class="o">.</span><span class="na">getPeerAddress</span><span class="o">());</span>
        <span class="c1">// stream channel has been accepted at this stage.</span>
        <span class="c1">// read listener is set; start it up</span>
        <span class="n">accepted</span><span class="o">.</span><span class="na">getSourceChannel</span><span class="o">().</span><span class="na">setReadListener</span><span class="o">(</span><span class="k">new</span> <span class="nf">ReadListener</span><span class="o">(</span><span class="n">accepted</span><span class="o">.</span><span class="na">getSinkChannel</span><span class="o">()));</span>
        <span class="n">accepted</span><span class="o">.</span><span class="na">getSourceChannel</span><span class="o">().</span><span class="na">resumeReads</span><span class="o">();</span>
      <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">ignored</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">};</span>
<span class="kd">final</span> <span class="n">XnioWorker</span> <span class="n">worker</span> <span class="o">=</span> <span class="n">Xnio</span><span class="o">.</span><span class="na">getInstance</span><span class="o">().</span><span class="na">createWorker</span><span class="o">(</span>
    <span class="n">OptionMap</span><span class="o">.</span><span class="na">EMPTY</span><span class="o">);</span>
<span class="c1">// Create the server.</span>
<span class="n">AcceptingChannel</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">StreamConnection</span><span class="o">&gt;</span> <span class="n">server</span> <span class="o">=</span> <span class="n">worker</span>
    <span class="o">.</span><span class="na">createStreamConnectionServer</span><span class="o">(</span><span class="k">new</span> <span class="nf">InetSocketAddress</span><span class="o">(</span><span class="mi">12345</span><span class="o">),</span>
        <span class="n">acceptListener</span><span class="o">,</span> <span class="n">OptionMap</span><span class="o">.</span><span class="na">EMPTY</span><span class="o">);</span>
<span class="c1">// lets start accepting connections</span>
<span class="n">server</span><span class="o">.</span><span class="na">resumeAccepts</span><span class="o">();</span></code></pre></div>


<p>完。</p>

<p class='post-footer'>
            原文地址：
            <a href='http://codemacro.com/2017/04/09/xnio-source/'>http://codemacro.com/2017/04/09/xnio-source/</a><br/>
            written by <a href='http://codemacro.com'>Kevin Lynx</a>
            &nbsp;posted at <a href='http://codemacro.com'>http://codemacro.com</a>
            </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实现JVM中的JIT]]></title>
    <link href="http://codemacro.com/2017/03/09/toy-jit/"/>
    <updated>2017-03-09T00:00:00+08:00</updated>
    <id>http://codemacro.com/2017/03/09/toy-jit</id>
    <content type="html"><![CDATA[<p>在JVM中，JIT (Just-in-Time) 即时编译指的是在Java程序运行过程中JVM优化部分指令为本地指令，从而大幅提升性能。在上一篇文章<a href="http://codemacro.com/2017/02/25/toy-jvm/">写一个玩具Java虚拟机</a>中实现了一个基本可以运行Java字节码的JVM。本篇文章描述我是如何在这个玩具JVM中实现JIT的。</p>

<p>推荐文章<a href="http://eli.thegreenplace.net/2013/11/05/how-to-jit-an-introduction/">&ldquo;How to JIT - an introduction&rdquo;</a>，介绍了JIT的基本实现原理。作者把JIT分为两个阶段：</p>

<ul>
<li>运行期生成机器代码(本地指令)</li>
<li>执行机器代码</li>
</ul>


<p>生成机器代码很好理解，就是一个JVM指令到机器指令的翻译；而执行机器代码，原理上是利用了OS提供了API可以分配可以执行的内存，然后往这块内存中写入机器码，从而实现运行期可以执行动态生成的机器码功能。</p>

<p>我们可以利用这个原理来实现JIT，但是未免太底层了点，需要做很多工作来完成这件事情。我们可以利用<a href="https://www.gnu.org/software/libjit/">libjit</a>来简化实现。这个作者博客里还有些libjit的教程，其中<a href="http://eli.thegreenplace.net/2013/10/17/getting-started-with-libjit-part-1">part 1</a>值得阅读。 简单来说，libjit对机器指令做了抽象，利用它的API来描述一个函数包含了哪些指令，实现了什么功能。然后具体的指令生成以及指令执行则交给libjit完成。</p>

<p>例如以下使用libjit的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// t = u
</span><span class='line'>jit_insn_store(F, t, u); // 类似 mov 指令
</span><span class='line'>// u = v
</span><span class='line'>jit_insn_store(F, u, v);
</span><span class='line'>
</span><span class='line'>// v = t % v
</span><span class='line'>jit_value_t rem = jit_insn_rem(F, t, v); // 求余指令
</span><span class='line'>jit_insn_store(F, v, rem);</span></code></pre></td></tr></table></div></figure>


<p>所以，我们需要做的，就是将JVM的字节码，翻译成一堆libjit的API调用。但是我希望能够稍微做点抽象，我们写个翻译器，能够将JVM这种基于栈的指令，翻译成基于寄存器的指令，才方便后面无论是使用libjit还是直接翻译成机器码。</p>

<!-- more -->


<h2>指令翻译</h2>

<p>要将基于栈的指令翻译成基于寄存器的指令（类似），仔细想想主要解决两个问题：</p>

<ul>
<li>去除操作数栈</li>
<li>跳转指令所需要的标签</li>
</ul>


<p>去除操作数栈，我使用了一个简单办法，因为JVM中执行字节码时，我们是可以知道每条指令执行时栈的具体情况的，也就是每条指令执行时，它依赖的操作数在栈的哪个位置是清楚的。例如，假设某个函数开头有以下指令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>opcode [04] - 0000: iconst_1   # [1]
</span><span class='line'>opcode [3C] - 0001: istore_1   # []
</span><span class='line'>opcode [1B] - 0002: iload_1    # [1]
</span><span class='line'>opcode [1A] - 0003: iload_0    # [1, N]
</span><span class='line'>opcode [68] - 0004: imul       # [1 * N]</span></code></pre></td></tr></table></div></figure>


<p>当执行imul指令时，就可以知道该指令使用栈s[0]、s[1]的值，做完计算后写回s[0]。所以，类似JVM中局部变量用数字来编号，我也为栈元素编号，这些编号的元素全部被视为局部变量，所以这些指令全部可以转换为基于局部变量的指令。为了和JVM中本身的局部变量统一，我们将栈元素编号从局部变量后面开始。假设以上函数有2个局部变量，那么栈元素从编号2开始，局部变量编号从0开始。以上指令可以翻译为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mov 1, $2   # 常量1写入变量2
</span><span class='line'>lod $2, $1  # 变量2写入变量1
</span><span class='line'>lod $1, $2  # 变量1写回变量2
</span><span class='line'>lod $0, $3  # 变量0写入变量3
</span><span class='line'>mul $3, $2  # 变量3与变量2相乘，写回变量2</span></code></pre></td></tr></table></div></figure>


<p>这里，我们定义了自己的中间指令集(IR)，这个中间指令集存在的意义在于，在将来翻译为某个平台的机器码时，它比JVM的指令集更容易理解。中间指令集是一种抽象，方便基于它们使用libjit或其他手段翻译成机器码。</p>

<p>不过，我们看到上面的指令非常冗余。要优化掉这种冗余相对比较复杂，所以本文暂时不讨论这个问题。</p>

<p>这个中间指令基于局部变量的方式，是利于JIT下游做各种具体实现的，例如是否直接转换为通用寄存器，即一定范围的局部变量数是可以直接使用寄存器实现，超出该范围的局部变量则放在栈上，用栈模拟；或者全部用栈模拟。注意在机器指令中栈元素是可以直接偏移访问的，不同于“基于栈的虚拟机”中的栈。</p>

<p>以上指令，我们可以简单地为每条指令设定如何翻译为libjit的调用，例如mov指令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void build_mov(BuildContext* context, const Instruction* inst) {
</span><span class='line'>  jit_value_t c = jit_value_create_nint_constant(context-&gt;F, jit_type_int, inst-&gt;op1); 
</span><span class='line'>  jit_insn_store(context-&gt;F, context-&gt;vars[inst-&gt;op2], c);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>例如mul指令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void build_mul(BuildContext* context, const Instruction* inst) {
</span><span class='line'>  // context-&gt;vars就是前面说的局部变量表，包含了JVM中的局部变量及操作数栈
</span><span class='line'>  jit_value_t tmp = jit_insn_mul(context-&gt;F, context-&gt;vars[inst-&gt;op1], context-&gt;vars[inst-&gt;op2]);
</span><span class='line'>  jit_insn_store(context-&gt;F, context-&gt;vars[inst-&gt;op1], tmp);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接下来说另一个问题：跳转指令的标签。在机器指令中，跳转指令跳转的目标位置是一个绝对地址，或者像JVM中一样，是一个相对地址。但是在我们的中间指令集中，是没有地址的概念的，在翻译为机器指令时，也无法获取地址。所以，我们一般是增加了一个特殊指令<code>label</code>，用于打上一个标签，设置一个标签编号，相当于是一个地址。在后面的跳转指令中，则跳转的是这个标签编号。</p>

<p>所以，我们需要在翻译JVM指令到我们的中间指令时，识别出哪些地方需要打标签；并且在翻译跳转类指令时，翻译为跳转到某个编号的标签。</p>

<p>例如以下指令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>opcode [04] - 0000: iconst_1
</span><span class='line'>opcode [3C] - 0001: istore_1
</span><span class='line'>opcode [1B] - 0002: iload_1     # 会被调整，需要在此打标签
</span><span class='line'>opcode [1A] - 0003: iload_0
</span><span class='line'>...
</span><span class='line'>opcode [1A] - 0010: iload_0
</span><span class='line'>opcode [9D] - 0011: ifgt -9     # pc-9，也就是跳转到0002位置</span></code></pre></td></tr></table></div></figure>


<p>为了打上标签，我们的翻译需要遍历两遍指令，第一遍用来找出所有标签，第二遍才做真正的翻译。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  // 该函数遍历所有指令，找出所有需要打标签的指令位置
</span><span class='line'>  private List&lt;Integer&gt; createLabels(List&lt;InstParser.Instruction&gt; jbytecode) {
</span><span class='line'>    List&lt;Integer&gt; labels = new LinkedList&lt;&gt;();
</span><span class='line'>    for (InstParser.Instruction i : jbytecode) {
</span><span class='line'>      LabelParser labelParser = labelParsers.get(i.opcode);
</span><span class='line'>      if (labelParser != null) { // 不为空时表示是跳转指令
</span><span class='line'>        int pc = labelParser.parse(i); // 不同的跳转指令地址解析不同，解析得到跳转的目标地址
</span><span class='line'>        labels.add(pc); // 保存起来返回
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>    return labels;
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>然后在翻译指令的过程中，发现当前翻译的指令地址是跳转的目标位置时，则生成标签指令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   List&lt;Integer&gt; labels = createLabels(jbytecode);
</span><span class='line'>   ...
</span><span class='line'>   Iterator&lt;InstParser.Instruction&gt; it = jbytecode.iterator();
</span><span class='line'>    while (it.hasNext()) {
</span><span class='line'>      InstParser.Instruction inst = it.next();
</span><span class='line'>      int label = labels.indexOf(inst.pc);
</span><span class='line'>      if (label &gt;= 0) {
</span><span class='line'>        state.addIR(new Inst(op_label, label)); // 生成标签指令，label就是标签编号
</span><span class='line'>      }</span></code></pre></td></tr></table></div></figure>


<p>在处理跳转指令时，则填入标签编号：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>translators.put(Opcode.op_ifgt, (state, inst, iterator) -&gt; {
</span><span class='line'>  short offset = (short)((inst.op1 &lt;&lt; 8) + inst.op2);
</span><span class='line'>  int pc = inst.pc + offset;
</span><span class='line'>  int label = state.findLabel(pc); // 找到标签编号
</span><span class='line'>  int var = state.popStack();
</span><span class='line'>  state.addIR(new Inst(op_jmp_gt, var, label));
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>我们的中间指令集中，跳转指令和标签指令就为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>label #N            // 打上标签N
</span><span class='line'>jmp_gt $var, #N     // 如果$var&gt;0，跳转到标签#N</span></code></pre></td></tr></table></div></figure>


<p>看下使用libjit如何翻译以上两条指令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void build_label(BuildContext* context, const Instruction* inst) {
</span><span class='line'>  // 打上标签，inst-&gt;op1为标签编号N，对应写到context-&gt;labels[N]中
</span><span class='line'>  jit_insn_label(context-&gt;F, &context-&gt;labels[inst-&gt;op1]);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static void build_jmp_gt(BuildContext* context, const Instruction* inst) {
</span><span class='line'>  jit_value_t const0 = jit_value_create_nint_constant(context-&gt;F, jit_type_int, 0);
</span><span class='line'>  // 是否&gt;0
</span><span class='line'>  jit_value_t cmp_v_0 = jit_insn_gt(context-&gt;F, context-&gt;vars[inst-&gt;op1], const0);
</span><span class='line'>  // 大于0则跳转到标签inst-&gt;op2
</span><span class='line'>  jit_insn_branch_if(context-&gt;F, cmp_v_0, &context-&gt;labels[inst-&gt;op2]);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>代码贴得有点多，大概懂原理就行了。</p>

<p>在JIT中还有个很重要的过程，就是判定哪些代码需要被JIT。这里只是简单地尝试对每一个函数进行JIT，发现所有指令都能够被JIT时就JIT。</p>

<h2>指令执行</h2>

<p>在上一篇文章中，执行每个JVM函数时，都会有一个Frame与之关联。所以，在这里只要函数被JIT了，对应的帧就会包含被编译的代码，也就是libjit中的<code>jit_function_t</code>。在该Frame被执行时，就调用libjit执行该函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  private void runNative() {
</span><span class='line'>    int arg_cnt = getArgsCount();
</span><span class='line'>    int[] args = new int[arg_cnt];
</span><span class='line'>    for (int i = 0; i &lt; arg_cnt; ++i) {
</span><span class='line'>      if (mLocals[i].type != Slot.Type.NUM) throw new RuntimeException("only supported number arg in jit");
</span><span class='line'>      args[i] = mLocals[i].i;
</span><span class='line'>    }
</span><span class='line'>    int ret = mJIT.invoke(args); // mJIT后面会看到，主要就是将参数以数组形式传递到libjit中，并做JIT函数调用
</span><span class='line'>    mThread.popFrame();
</span><span class='line'>    if (hasReturnType() && mThread.topFrame() != null) {
</span><span class='line'>      mThread.topFrame().pushInt(ret); // 目前只支持int返回类型
</span><span class='line'>    }
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<h2>实现</h2>

<p>以上就是整个JIT的过程，主要工作集中于JVM指令到中间指令，中间指令到libjit API调用。整个实现包含以下模块：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+-----------+       +----------+
</span><span class='line'>| ASM       |       | libjit   |
</span><span class='line'>|           | &lt;-----+ API call |
</span><span class='line'>+-----------+       +----+-----+
</span><span class='line'>                         ^
</span><span class='line'>                         |
</span><span class='line'>+-----------+       +----+-----+
</span><span class='line'>|  JVM      |       |  IR code |
</span><span class='line'>|  bytecode +-----&gt; |          |
</span><span class='line'>+-----------+       +----------+
</span></code></pre></td></tr></table></div></figure>


<p>JVM byte code及IR code的处理是在Java中完成的；处理完后将IR code输出为byte[]，通过JNI调用包装好的C API。这个C API则是基于libjit，将IR code翻译为libjit的API调用。指令翻译完后调用libjit的API得到最终的ASM机器指令。</p>

<p>同样，要执行指令时，也是通过JNI调用这个C API。JNI交互全部包装在以下类中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class ToyJIT {
</span><span class='line'>  private long jitPtr = 0;
</span><span class='line'>
</span><span class='line'>  public void initialize(byte[] bytes, int maxLocals, int maxLabels, int argCnt, int retType) {
</span><span class='line'>    jitPtr = compile(bytes, maxLocals, maxLabels, argCnt, retType);
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  public int invoke(int... args) {
</span><span class='line'>    return invoke(jitPtr, args);
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  static {
</span><span class='line'>    System.loadLibrary("toyjit");
</span><span class='line'>  }
</span><span class='line'>  private static native long compile(byte[] bytes, int maxLocals, int maxLabels, int argCnt, int retType);
</span><span class='line'>  private static native int invoke(long jitPtr, int[] args);</span></code></pre></td></tr></table></div></figure>


<p>即，<code>libtoyjit.so</code> 主要提供翻译接口 <code>compile</code> 及执行接口 <code>invoke</code>。</p>

<h2>性能对比</h2>

<p>简单测试了下一个阶乘计算函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  public static int fac2(int n) {
</span><span class='line'>    int r = 1;
</span><span class='line'>    do {
</span><span class='line'>      r = r * n;
</span><span class='line'>      n = n - 1;
</span><span class='line'>    } while (n &gt; 0);
</span><span class='line'>    return r;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'> ...
</span><span class='line'>    int i = 0;
</span><span class='line'>    for (; i &lt; 10000; ++i) {
</span><span class='line'>        fac2(100);
</span><span class='line'>    }
</span><span class='line'> ...</span></code></pre></td></tr></table></div></figure>


<p><code>fac2</code>函数会被JIT，测试发现不开启JIT时需要16秒，开启后1秒，差距还是很明显的。</p>

<p>最后奉上代码，<a href="https://github.com/kevinlynx/toy_jit">toy_jit</a>，就是前面说的C API部分，翻译IR到libjit API call，包装接口用于JNI调用。redhat 7.2下编译，需要先编译出libjit，我是直接clone的libjit master编译的。Java部分还是在<a href="https://github.com/kevinlynx/toy_jvm">toy_jvm</a>中。</p>

<p class='post-footer'>
            原文地址：
            <a href='http://codemacro.com/2017/03/09/toy-jit/'>http://codemacro.com/2017/03/09/toy-jit/</a><br/>
            written by <a href='http://codemacro.com'>Kevin Lynx</a>
            &nbsp;posted at <a href='http://codemacro.com'>http://codemacro.com</a>
            </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[写一个玩具Java虚拟机]]></title>
    <link href="http://codemacro.com/2017/02/25/toy-jvm/"/>
    <updated>2017-02-25T00:00:00+08:00</updated>
    <id>http://codemacro.com/2017/02/25/toy-jvm</id>
    <content type="html"><![CDATA[<p>本文描述了一个用Java实现的玩具JVM，用Java实现的好处是可以不用处理JVM中的垃圾回收。</p>

<p>Java虚拟机是基于栈的虚拟机。栈虚拟机的特点是所有临时操作数都存放在栈中。编译器生成的指令都会围绕着这个栈展开，相对而言，解释执行这些指令会比较容易。基于栈的虚拟机可能会生成如下指令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>push 3   # 把立即数3压栈
</span><span class='line'>push 4   # 把立即数4压栈
</span><span class='line'>add      # 从栈中弹出两个操作数进行相加，结果压回栈中</span></code></pre></td></tr></table></div></figure>


<p>Java .class文件存储的主要就是编译后的指令，一个玩具JVM，简单来说就是解释执行这里面的指令。接下来就说说为了让这个JVM跑起来需要实现哪些功能。</p>

<h2>class 文件解析</h2>

<p>推荐一下 <a href="https://www.codeproject.com/articles/35915/java-class-viewer">Java class viewer</a>，里面有个工具可以可视化class文件内容。另外我直接复用了他解析class文件的代码。</p>

<p>class文件描述的信息是以class为单位的，一个类如果有嵌套类，这个嵌套类也会生成为单独的class文件。从c/c++程序员的视角来看，class文件的生成有点类似编译，编译器在编译期间只做依赖符号存在与否的检查。所有引用其他class的地方，不同于c/c++，java class的引用都是在运行期定位的。这里看看一个简单的类class文件结构是怎样的：</p>

<!-- more -->


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package test;
</span><span class='line'>
</span><span class='line'>public class Simple {
</span><span class='line'>  private int data;
</span><span class='line'>
</span><span class='line'>  public int add(int a, int b) {
</span><span class='line'>    return a + b;
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><img src="http://i.imgur.com/VCk3vGO.jpg" alt="" /></p>

<p>一个class文件比较重要的有：</p>

<ul>
<li>constant pool(常量池)：存储字符串字面量、函数原型描述、类成员描述、class引用描述。字节码中经常会引用常量池中的内容，例如要设置某个成员变量，字节码中的操作数就是常量池索引，从索引中获取出具体是哪个成员变量</li>
<li>fields：描述类成员变量</li>
<li>methods: 描述类成员函数</li>
<li>attributes: 分布在很多地方，可能嵌套，用于描述method字节码、调试符号信息等。</li>
</ul>


<p>常量池非常重要，这里看看class文件中是如何使用常量池的。例如，一个field描述：</p>

<p><img src="http://i.imgur.com/dUnFttG.jpg" alt="" /></p>

<p>其中<code>name_index</code>和<code>descriptor_index</code>的值，指向的就是常量池索引，通过前面推荐的class viewer去常量池中找就会找到对应的值：</p>

<p><img src="http://i.imgur.com/8uqslfH.jpg" alt="" /></p>

<p><code>descriptor_index</code>描述field类型，<code>I</code>指的是整数。Java里有一套描述类型的规则，这个规则在函数定义的地方也会看到。</p>

<p>methods只要有实现，就都会有一个Code attribute，也就是这个函数的具体实现字节码，例如前面的add函数字节码为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>opcode [1B] - 0000: iload_1     # 将第1个局部变量值压栈
</span><span class='line'>opcode [1C] - 0001: iload_2     # 将第2个局部变量值压栈
</span><span class='line'>opcode [60] - 0002: iadd        # 弹出2个操作数相加，结果压栈
</span><span class='line'>opcode [AC] - 0003: ireturn     # 弹出1个操作数作为函数返回值</span></code></pre></td></tr></table></div></figure>


<p>解析出class文件中的信息后，玩具JVM就完成一半了。</p>

<h2>JVM指令</h2>

<p>JVM中已经有200多条指令了。但是这些指令很多都是相似的。具体实现这些指令时可以参考<a href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings">指令表</a>。JVM指令就像x86指令一样，由操作码以及可选的操作数组成。操作码表示具体是哪条指令，占1个字节；操作数表示该操作码需要的参数，变长。class文件中字节码连续存放，像上一节的例子就是4条指令，每条指令只有操作码没有操作数，他们存放在class文件中就是：1B 1C 60 AC。</p>

<p>JVM依次读取这些指令并解释执行。这个过程同真实计算机CPU执行过程类似。用代码描述为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>while (true) {
</span><span class='line'>  code = fetchOpCode()
</span><span class='line'>  if (code == iload_1) {
</span><span class='line'>    push(1)
</span><span class='line'>  } elif (code == iadd) {
</span><span class='line'>    i1 = pop()
</span><span class='line'>    i2 = pop()
</span><span class='line'>    push(i1 + i2)
</span><span class='line'>  } elif (code == bipush) { // 需要操作数的指令
</span><span class='line'>    b = fetchOpValue()
</span><span class='line'>    push(b)
</span><span class='line'>  }
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>程序执行过程中有一个虚拟指针PC，用于指示当前字节码处理到哪个位置了。有些跳转指令会强制改变PC。不同于c/c++程序，JVM中跳转指令跳转的都是相对位移。JVM启动时，不同于c/c++，也没有地址重定位的过程(修正相对地址为实际地址)。</p>

<h2>执行环境</h2>

<h3>线程执行环境</h3>

<p>JVM中每个线程都是独立的执行单元。但是对于类符号等信息则是全局共享，堆上创建的对象也是全局可访问的。单个线程中调用函数会产生帧(frame)，每一帧都有一个独立的栈用于存储该帧执行的临时数据。从main函数开始执行，每进入一个函数创建一个帧，函数退出(执行return系列指令)清除当前帧。这里的帧也可以被实现为一个栈，当这个栈里没有帧时就表示这个线程退出。这个过程可以描述为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>while (thread.topFrame() != null) {
</span><span class='line'>  thread.topFrame().run() // 内部实现就是从Code属性处不断地取指令执行
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// 执行到return语句时，就弹出该帧
</span><span class='line'>if (code == op_return) {
</span><span class='line'>  frame.getThread().popFrame()
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// 遇到函数调用时，就根据目标函数创建出一帧
</span><span class='line'>if (code == op_invoke) {
</span><span class='line'>  method = findMethod(ref) // 函数调用时操作数是常量池索引，需要加载目标类，获取目标方法
</span><span class='line'>  newFrame = createFrame(method) // 每个方法都会描述该方法内有多少局部变量，所需栈多大，根据这些信息初始化帧
</span><span class='line'>  frame.getThread().pushFrame(newFrame) 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注释中提到了，class文件中method包含了“有多少局部变”、“需要多大的栈”等信息。局部变量的实现是一个数组，数组的下标表示局部变量是第几个。字节码中要访问局部变量时，全部是以这个下标来查找的。例如指令<code>istore_1</code>，表示从栈中弹出一个整数，并写到局部变量1中。</p>

<p><img src="http://i.imgur.com/dUW6ukh.jpg" alt="" /></p>

<h3>全局环境</h3>

<p>由于使用Java实现，堆内存的管理完全不用操心。如果我们代码中创建了一个类对象，或者简单点调用了另一个类的静态方法，这个时候会发生什么以及如何处理？例如以下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int a = Simple2.inc(2);</span></code></pre></td></tr></table></div></figure>


<p>生成以下字节码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>opcode [05] - 0004: iconst_2  # 压入常量2到栈，作为函数调用的参数
</span><span class='line'>opcode [B8] - 0005: invokestatic 2 [Methodref: test.Simple2.inc, parameter = (int), returns = int]</span></code></pre></td></tr></table></div></figure>


<p>可以看出调用静态函数<code>invokestatic</code>的操作数是2，指向的是常量池中的2。工具直接显示了常量池2是一个method，及该method的原型。</p>

<p>遇到这样的指令时，我们就需要找到并加载目标类。所以，全局信息里需要维护类列表。考虑到Java中类与类之间是否相同，除了看类名（全限定名）外，还得看类的加载器(class loader)。所以，玩具JVM中也需要有class loader机制（至少是个简化版）。程序启动时设定一个默认的类加载器，加载主类，执行主类main方法，执行过程中遇到对其他类的引用时，就使用当前类加载器继续加载目标类，如果已经加载就直接返回。</p>

<h2>类加载及main方法</h2>

<p>前面已经提到了类加载。其实类加载本质上就是把目标class文件加载到内存，保存该class信息。在调用一个类的方法时，也是根据方法名(考虑到方法重载，还得考虑方法的原型，在class file中也就是descriptor)找到具体的方法，根据方法初始化调用帧，以及根据方法获得其要执行的字节码。</p>

<p>所以，我们的JVM要跑起来，也就是找到并加载主类，然后找到主类中的main函数并执行。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  public void run(String mainClass) {
</span><span class='line'>    Class clazz = mRootLoader.loadClass(mainClass);
</span><span class='line'>    MethodInfo method = clazz.findMethod("main", "([Ljava/lang/String;)V");
</span><span class='line'>    Thread thread = new Thread();
</span><span class='line'>    thread.run(clazz, method);
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>当然，这个过程严格来说还得判定类访问控制、方法访问控制等。</p>

<p><strong>至此，这个玩具JVM就可以跑起来了</strong>。可以设定它的class path，加载类，从main方法开始执行，调用其他类的静态方法，写写阶乘的实现是没有问题了。但是Java中还有很多其他特性：类对象、调用类实例方法、异常处理、调用native方法等待。接下来我再讲讲这些特性的实现，一窥Java核心语法的实现。</p>

<h2>扩展实现</h2>

<h3>类对象及实例方法调用</h3>

<p>类对象的创建通过<code>new</code>指令完成，本质上也就是分配个对象，并关联类信息到这个对象。我们的实现中自然会有一个类用来表示玩具JVM中所有的对象：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 为了与java.lang.Object区分开
</span><span class='line'>public class VObject {
</span><span class='line'>  // 简单起见，直接以field名作为key，来保存该对象所有的成员变量
</span><span class='line'>  private Map&lt;String, Slot&gt; mFields; 
</span><span class='line'>  // 与之关联的类信息
</span><span class='line'>  private final Class mClazz;
</span><span class='line'>    ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意这里的<code>Class</code>是我们自己定义的Class，而不是java.lang.Class。<code>Slot</code>类型用于存储整数或一个引用(其他对象)。<code>new</code>指令的大概实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>register(Opcode.op_new, (codes, frame) -&gt; {
</span><span class='line'>  int b1 = codes.readByte();
</span><span class='line'>  int b2 = codes.readByte();
</span><span class='line'>  int idx = (b1 &lt;&lt; 8) + b2; // 常量池索引，指向一个类信息描述
</span><span class='line'>  String clazzName = frame.getClazz().resolveClassName(idx); // 根据这个类信息描述解析到具体的类名
</span><span class='line'>  Class clazz = frame.getClazz().getClassLoader().loadClass(clazzName); // 使用当前的类加载器加载该类
</span><span class='line'>  initClass(frame.getThread(), clazz); 
</span><span class='line'>  VObject object = new VObject(clazz); // 创建该类对应的对象，完成new指令的对象创建动作
</span><span class='line'>  frame.pushRef(object); // 根据new指令的语义，我们需要将创建好的对象引用压回栈中
</span><span class='line'>});
</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是，当我们在Java中写下代码 <code>new SomeClass()</code> 时，实际会产生两个功能的指令：a) 创建对象；b) 调用类的构造函数(<init>)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>opcode [BB] - 0004: name_new 2 [Class: test.Simple2]  # new 指令，操作数是类信息常量池索引
</span><span class='line'>opcode [59] - 0007: dup 
</span><span class='line'>opcode [B7] - 0008: invokespecial 3 [Methodref: test.Simple2. , parameter = (), returns = void] # 调用目标类的构造函数，也就是&lt;init&gt;方法</span></code></pre></td></tr></table></div></figure>


<p>调用类构造函数同普通类实例方法原理相同，都会先压入对象引用。<code>invokespecial</code>指令用于调用类对象实例方法，从栈顶依次出栈参数，最后出栈类对象实例引用。具体可以看看指令表里的描述。</p>

<h3>类静态区域初始化</h3>

<p>首次加载某个类时，会执行其static区域代码。这个写测试看下生成的代码就懂了，就是生成一个<cinit>的静态方法，在加载类时先执行这个方法。</p>

<h3>异常处理</h3>

<p>当一个方法中有try/catch时，该方法就会生成出一个异常处理表，存储在Code属性中。如下图：</p>

<p><img src="http://i.imgur.com/Ms1qPYr.jpg" alt="" /></p>

<p>异常处理表每一项都包含：<code>start_pc</code>、<code>end_pc</code>、<code>handler_pc</code> 及<code>catch_type</code>，表示在start_pc/end_pc间发现异常，且异常类型是catch_type时，则跳转到handler_pc处执行代码，也就是异常处理代码。其中catch_type也是常量池中的索引，当其为0时，则不是常量池索引，而是表示catch所有类型，其实就是finally块。从这里也可以看出，常量池索引是从1开始，而不是0。</p>

<p>当异常发生时，JVM首先从当前帧对应的方法中的异常处理表查找异常处理代码，没有的话则弹出当前帧，回到上一帧，也就是调用者继续查找，直到找完所有调用帧。这个实现相对较多，就不列举代码了。</p>

<h3>调用本地方法</h3>

<p>前面实现的JVM都没有输出字符串的能力，要提供一个类似<code>System.out.println</code>的方法，就需要注册本地方法到JVM中。这里可以简单地为整个JVM设置一个本地方法表，在JVM启动时完成注册。类似以下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static void native println(String s);</span></code></pre></td></tr></table></div></figure>


<p>也会在class文件中留下一个method，但这个method会被标记为native，自然也没有Code属性，没有字节码可执行。当执行<code>invoke</code>系列指令时，发现调用的是native方法，就需要从全局本地方法表中查找。注册本地方法类似：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mMethods.put(makeKey("java/lang/System", "println", "(Ljava/lang/String;)V"), (frame) -&gt; {
</span><span class='line'>  String s = (String) frame.popRef();
</span><span class='line'>  System.out.println(s);
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>本地方法执行时，通过<code>frame</code>参数就可以取出调用该方法传入的参数。</p>

<p>在实现了本地方法后，就可以给这个玩具JVM添加一些系统库，类似OpenJDK中jre目录下的lib。这些系统库可以包含java.lang.System.println、java.lang.String、java.lang.StringBuilder。简单起见，我实现的这些类和Java标准库有些不同。</p>

<h2>最后</h2>

<p>完整代码<a href="https://github.com/kevinlynx/toy_jvm">这里</a>。实现的指令很有限，可以跑通<a href="https://github.com/kevinlynx/toy_jvm/blob/master/test/AllTest.java">test/AllTest.java</a>中的代码。对于long/double等类型没有支持，各种限定访问的判断也没有。总之就是简单到仅仅可以一窥原理。基于java8，测试例子class文件java7编译(应该没关系)。祝玩得开心。</p>

<p class='post-footer'>
            原文地址：
            <a href='http://codemacro.com/2017/02/25/toy-jvm/'>http://codemacro.com/2017/02/25/toy-jvm/</a><br/>
            written by <a href='http://codemacro.com'>Kevin Lynx</a>
            &nbsp;posted at <a href='http://codemacro.com'>http://codemacro.com</a>
            </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RequireJS最简实现]]></title>
    <link href="http://codemacro.com/2017/02/05/mini-requirejs/"/>
    <updated>2017-02-05T00:00:00+08:00</updated>
    <id>http://codemacro.com/2017/02/05/mini-requirejs</id>
    <content type="html"><![CDATA[<p>网上有不少解析RequireJS源码的文章，我觉得意义不大。阅读源代码的目的不是为了熟悉代码，而是为了学习核心实现原理。相对RequireJS的源码，<a href="https://github.com/zengjialuo/kittyjs">kitty.js</a>的实现更简单，更容易理解。本文正是抄了kitty.js的实现，是一个更精简的RequireJS，用于理解RequireJS的实现原理。</p>

<p><a href="https://github.com/kevinlynx/dummy-requirejs">github dummy-requirejs</a>。这个实现仅支持核心feature：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>require(deps, callback) // deps 是依赖数组
</span><span class='line'>define(id, deps, factory) // factory是一个函数
</span></code></pre></td></tr></table></div></figure>


<p>例子参考git中rect.js/main.js。</p>

<p>从实现来看，require/define是基本一致的，require的callback等同于define的factory：都会要求deps被加载且被执行，获得deps的exports作为整个module传入callback/factory。不同的是，factory的返回值会被作为define出来的模块的export，可被视为模块本身；而callback返回值被忽略。</p>

<p>从用法来看，define仅是定义了模块，这个模块可能被作为deps被其他模块依赖，但define传入的factory此时是不执行的；而require则会触发各个模块的factory执行。</p>

<!-- more -->


<h2>实现</h2>

<p>主要实现分为3部分内容，其中关键的地方在于模块载入。</p>

<h3>数据结构</h3>

<p>既然是模块加载器，并且需要处理模块之间的依赖问题，所以设置一个哈希表保存所有的模块。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var mods = {} // &lt;id, Module&gt;
</span><span class='line'>
</span><span class='line'>function Module(id) {
</span><span class='line'>    var mod = this
</span><span class='line'>    mod.id = id
</span><span class='line'>    mod.uri = id // 简单起见，根据id拼出uri: abc.js
</span><span class='line'>    mod.deps = []  // 依赖的模块id列表
</span><span class='line'>    mod.factory = blank // 定义模块时的factory
</span><span class='line'>    mod.callback = blank // 模块加载完毕后回调
</span><span class='line'>    mod.exports = {} // 模块导出的对象
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>define的实现就比较简单，主要就是往<code>mods</code>里添加一个<code>Module</code>对象，简单来说就是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function define(id, deps, factory) {
</span><span class='line'>    var mod = getModule(id) // mods存在就返回，否则就往mods里新增
</span><span class='line'>    mod.deps = deps
</span><span class='line'>    mod.factory = factory
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h3>模块载入</h3>

<p>遇到require时就会产生模块载入的动作。模块载入时可能发生以下动作：</p>

<ul>
<li>往页面添加script标签以让浏览器从服务端拉取js文件</li>
<li>js文件中可能遇到define从而立即添加模块 (非AMD模块不考虑)</li>
<li>define定义的模块可能有其他依赖模块，递归载入这些模块，直到所有模块载入完毕</li>
</ul>


<p>这里的模块载入只是把模块js文件载入到浏览器环境中。以上过程对应的大概代码为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Module.prototype.load = function() {
</span><span class='line'>    var mod = this
</span><span class='line'>    if (mod.status == STATUS.FETCHING) return
</span><span class='line'>    if (mod.status == STATUS.UNFETCH) {
</span><span class='line'>        return mod.fetch() // 添加script标签从服务端拉取文件
</span><span class='line'>    }
</span><span class='line'>    mod.status = STATUS.LOADING
</span><span class='line'>    mod.remain = mod.deps.length // 所有依赖载入完毕后通知回调
</span><span class='line'>    function callback() {
</span><span class='line'>        mod.remain--
</span><span class='line'>        if (mod.remain === 0) {
</span><span class='line'>            mod.onload() // 通知回调
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    each(mod.deps, function (dep) {
</span><span class='line'>        var m = getModule(dep)  // 获取依赖模块对象，依赖模块可能已经被载入也可能没有
</span><span class='line'>        if (m.status &gt;= STATUS.LOADED || m.status == STATUS.LOADING) { // 已经载入
</span><span class='line'>            mod.remain--
</span><span class='line'>            return
</span><span class='line'>        }
</span><span class='line'>        m.listeners.push(callback)
</span><span class='line'>        if (m.status &lt; STATUS.LOADING) {
</span><span class='line'>            m.load()
</span><span class='line'>        }
</span><span class='line'>    })
</span><span class='line'>    if (mod.remain == 0) {
</span><span class='line'>        mod.onload()
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p><code>load</code>的实现由于混合了异步问题，所以理解起来会有点难。<code>fetch</code>的实现就是一般的往页面添加script及设置回调的过程。在fetch完毕后会重新调用<code>load</code>以完成递归载入该模块的依赖：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 该函数回调时，该js文件已经被浏览器执行，其内容包含define则会添加模块（当然已经被添加过了）
</span><span class='line'>// 可以回头看上面的define调用的是getModule，此时会重新设置deps/factory等属性
</span><span class='line'>function onloadListener() {
</span><span class='line'>    var readyState = script.readyState;
</span><span class='line'>    if (typeof readyState === 'undefined' || /^(loaded|complete)$/.test(readyState)) {
</span><span class='line'>        mod.status = STATUS.FETCHED
</span><span class='line'>        mod.load()
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h3>模块生效</h3>

<p>模块载入后模块其实还没生效，还无法使用模块中定义的各种符号。要让模块生效，就得执行模块定义的factory函数。在直接间接依赖的模块被全部载入完成后，最终回调到我们的callback。此时可以看看require的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 前面提到require/define实现类似，所以这里创建了Module对象，只是复用代码
</span><span class='line'>function require(deps, callback) {
</span><span class='line'>    var mod = new Module(getId())
</span><span class='line'>    mod.deps = deps
</span><span class='line'>    mod.factory = callback
</span><span class='line'>    mod.callback = function () {
</span><span class='line'>        mod.exec()
</span><span class='line'>    }
</span><span class='line'>    mod.status = STATUS.FETCHED
</span><span class='line'>    mod.load()
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>就是简单地调用了<code>load</code>，完成后调用了<code>exec</code>。<code>exec</code>又是一个涉及到递归的函数，它会递归执行所有模块的factory。factory的执行需要各个模块的exports对象，只有模块exec后才会得到exports对象。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Module.prototype.exec = function() {
</span><span class='line'>    var mod = this
</span><span class='line'>    if (mod.status &gt;= STATUS.EXECUTED) { return mod.exports }
</span><span class='line'>    // 获取依赖模块的exports列表
</span><span class='line'>    var args = mod.getDepsExport()
</span><span class='line'>    var ret = mod.factory.apply(null, args)
</span><span class='line'>    // factory 返回值作为该模块的exports
</span><span class='line'>    mod.exports = ret 
</span><span class='line'>    mod.status = STATUS.EXECUTED
</span><span class='line'>    return mod.exports
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码主要是实现这样的功能：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 将依赖[d1, d2]的exports作为参数d1,d2传入
</span><span class='line'>define('my-module', ['d1', 'd2'], function (d1, d2) {
</span><span class='line'>    return {func: function() {}}
</span><span class='line'>})</span></code></pre></td></tr></table></div></figure>


<p><code>getDepsExport</code>就是一个取依赖模块exports的过程：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Module.prototype.getDepsExport = function() {
</span><span class='line'>    var mod = this
</span><span class='line'>    var exports = []
</span><span class='line'>    var deps = mod.deps
</span><span class='line'>    var argsLen = mod.factory.length &lt; deps.length ? mod.factory.length : deps.length
</span><span class='line'>    for (var i = 0; i &lt; argsLen; i++) {
</span><span class='line'>        exports.push(mod.require(deps[i]))
</span><span class='line'>    }
</span><span class='line'>    return exports
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>Module.require(id)</code>用于exec目标模块并返回其exports：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Module.prototype.require = function(dep) {
</span><span class='line'>    // 由于之前已经递归载入过所有模块，所以该依赖模块必然是已经存在的，可以被exec的
</span><span class='line'>    var mod = getModule(dep)
</span><span class='line'>    return mod.exec()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>于是又回到了<code>exec</code>，实现了递归执行所有依赖模块的功能。<code>exec</code>主要是获取依赖模块exports并调用factory，所以最初的require将用户的callback作为factory传入那个临时Module，最终使得调用到用户的callback。</p>

<p>通过以上过程，实际上就已经走通了从define到require实现的整个过程。整个代码不到200行。基于此可以添加更多RequireJS的附加功能。完。</p>

<p class='post-footer'>
            原文地址：
            <a href='http://codemacro.com/2017/02/05/mini-requirejs/'>http://codemacro.com/2017/02/05/mini-requirejs/</a><br/>
            written by <a href='http://codemacro.com'>Kevin Lynx</a>
            &nbsp;posted at <a href='http://codemacro.com'>http://codemacro.com</a>
            </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactJS项目中基于webpack实现页面插件]]></title>
    <link href="http://codemacro.com/2017/01/08/react-plugin/"/>
    <updated>2017-01-08T00:00:00+08:00</updated>
    <id>http://codemacro.com/2017/01/08/react-plugin</id>
    <content type="html"><![CDATA[<p>整个Web页面是基于ReactJS的，js打包用的webpack，现在想在Web页面端实现一种插件机制，可以动态载入第三方写的js插件。这个插件有一个约定的入口，插件被载入后调用该入口函数，插件内部实现渲染逻辑。插件的实现也使用了ReactJS，当然理论上也可以不使用。预期的交互关系是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 主页面
</span><span class='line'>load('/plugin/my-plugin.js', function (plugin) {
</span><span class='line'>    plugin.init($('#plugin-main'), args)
</span><span class='line'>})
</span><span class='line'>
</span><span class='line'>// 基于ReactJS的插件
</span><span class='line'>function init($elem, args) {
</span><span class='line'>    ReactDOM.render((&lt;Index /&gt;), $elem)
</span><span class='line'>}
</span><span class='line'>export {init}</span></code></pre></td></tr></table></div></figure>


<p>在主页面上支持这种插件机制，有点类似一个应用市场，主页面作为应用平台，插件就是应用，用户可以在主页面上选用各种插件。</p>

<h2>问题</h2>

<p>目前主页面里ReactJS被webpack打包进了bundle.js，如果插件也把ReactjS打包进去，最终在载入插件后，浏览器环境中就会初始化两次ReactJS。<strong>而ReactJS是不能被初始化多次的</strong>。此外，为了插件编写方便，我把一些可重用的组件打包成一个单独的库，让主页面和插件都去依赖。这个库自然也不能把ReactJS打包进来。何况还有很多三方库，例如underscore、ReactDOM最好也能避免重复打包，从而可以去除重复的内容。所以，这里就涉及到如何在webpack中拆分这些库。</p>

<p>需要解决的问题：</p>

<ul>
<li>拆分三方库，避免打包进bundle.js</li>
<li>动态载入js文件，且能拿到其module，或者至少能知道js什么时候被载入，才能调用其入口函数</li>
</ul>


<!-- more -->


<p>关于第二个问题，我选用了RequireJS，但其实它不是用于我这种场景的，不过我不想自己写一个js载入器。用RequireJS在我这种场景下会带来一些问题：webpack在打包js文件时会检查是否有AMD模块加载器，如果有则会把打包的代码作为AMD模块来加载。对于三方库的依赖就需要做一些适配。</p>

<h2>实现</h2>

<p>开始做这件事时我是不熟悉RequireJS/AMD的，导致踩了不少坑。过程不表，这里就记录一些关键步骤。</p>

<p>公共组件库及插件是必须要打包为library的，否则没有导出符号：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// webpack.config.js
</span><span class='line'>config.output = {
</span><span class='line'>  filename: 'drogo_components.js',
</span><span class='line'>  path: path.join(__dirname, 'dist'),
</span><span class='line'>  libraryTarget: 'umd',
</span><span class='line'>  library: 'drogo_components'
</span><span class='line'>};
</span></code></pre></td></tr></table></div></figure>


<p>此外，为了不打包三方库进bundle.js，需要设置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// webpack.config.js
</span><span class='line'>config.externals = {
</span><span class='line'>  'react': 'React',
</span><span class='line'>  'underscore': '_',
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p><code>externals</code>中key为代码中<code>require</code>或<code>import xxx from 'xxx'</code>中的名字，value为输出代码中的名字。以上设置后，webpack打包出来的代码类似于：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(function webpackUniversalModuleDefinition(root, factory) {
</span><span class='line'>    if(typeof exports === 'object' && typeof module === 'object')
</span><span class='line'>        module.exports = factory(require("React"), require("_"));
</span><span class='line'>    else if(typeof define === 'function' && define.amd)
</span><span class='line'>        define(["React", "_"], factory);
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>了解了RequireJS后就能看懂上面的代码，意思是定义我这里说的插件或公共库为一个模块，其依赖<code>React</code>及<code>_</code>模块。</p>

<p>插件及公共库如何编写？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 入口main.js中
</span><span class='line'>import React from 'react'
</span><span class='line'>import ReactDOM from 'react-dom'
</span><span class='line'>import Test from './components/test'
</span><span class='line'>import Index from './components/index'
</span><span class='line'>
</span><span class='line'>function init($elem, data) {
</span><span class='line'>    ReactDOM.render((&lt;Index biz={data.biz} /&gt;), $elem)
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>export {Index, Test, init}
</span></code></pre></td></tr></table></div></figure>


<p>入口js中export的内容就会成为这个library被require载入后能拿到的符号。这个库在webpack中引用时同理。注意需要设置库的入口文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// package.json
</span><span class='line'>  "main": "static/js/main.bundle.js",</span></code></pre></td></tr></table></div></figure>


<p>对于本地库，可以通过以下方法在本地使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 打包本地库，生成库.tgz文件
</span><span class='line'>npm pack
</span><span class='line'>// 切换到要使用该库的工程下安装
</span><span class='line'>npm install ../xxx/xxx.tgz</span></code></pre></td></tr></table></div></figure>


<p><code>package.json</code>中也不需要依赖该文件，如果不自己install，也是可以在package.json中依赖的，类似：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"xxxx": "file:../xxx/xxx.tgz"</span></code></pre></td></tr></table></div></figure>


<p>经过以上步骤后，在主页面中载入插件打包的bundle.js时，会得到错误，说找不到React模块。我这里并没有完全改造为RequireJS的模块，所以我在页面中是静态引入react的，即：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;script src="static/js/react-with-addons.js"&gt;&lt;/script&gt;
</span><span class='line'>&lt;script src="static/js/react-dom.min.js"&gt;&lt;/script&gt;</span></code></pre></td></tr></table></div></figure>


<p>当执行插件后，RequireJS会去重新载入react.js，如果能load成功，就又会导致浏览器环境中出现两份ReactJS，解决方法是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>define('react', [], function() {
</span><span class='line'>  return React
</span><span class='line'>})
</span><span class='line'>
</span><span class='line'>define('react-dom', [], function() {
</span><span class='line'>  return ReactDOM
</span><span class='line'>})
</span><span class='line'>
</span><span class='line'>define('_', [], function () {
</span><span class='line'>  return _
</span><span class='line'>})</span></code></pre></td></tr></table></div></figure>


<p>即，因为react被静态引入，就会存在全局变量window.React，所以这里是告诉RequireJS我们定义<code>react</code>模块就是全局变量React。此时webpack中打出的文件中<code>require(['react'], xx</code>时，就不会导致RequireJS再去从服务端载入react.js文件。</p>

<p>使用RequireJS后，要动态载入插件，代码就类似于：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>window.require(['/api/plug/content/1'], function (m) {
</span><span class='line'>  m.init($('#app-main')[0], args)
</span><span class='line'>})</span></code></pre></td></tr></table></div></figure>


<p>最后，之所以没有把页面全部改造为RequireJS，例如通过require载入主页面，主页面依赖react、公共组件库等，是因为我发现RequireJS的载入顺序与项目中使用的部分界面库有冲突，导致一些<code>&lt;a&gt;</code>的事件监听丢失（如下拉菜单不可用），根本原因还没找到。</p>

<p class='post-footer'>
            原文地址：
            <a href='http://codemacro.com/2017/01/08/react-plugin/'>http://codemacro.com/2017/01/08/react-plugin/</a><br/>
            written by <a href='http://codemacro.com'>Kevin Lynx</a>
            &nbsp;posted at <a href='http://codemacro.com'>http://codemacro.com</a>
            </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一次逆向网页内容加密]]></title>
    <link href="http://codemacro.com/2016/08/16/reverse_html/"/>
    <updated>2016-08-16T00:00:00+08:00</updated>
    <id>http://codemacro.com/2016/08/16/reverse_html</id>
    <content type="html"><![CDATA[<p>最近写一个爬虫要从这个<a href="http://cpquery.sipo.gov.cn/txnQueryFeeData.do?select-key:shenqingh=2007200071873&amp;select-key:zhuanlilx=2&amp;select-key:gonggaobj=&amp;select-key:backPage=http%3A%2F%2Fcpquery.sipo.gov.cn%2FtxnQueryOrdinaryPatents.do%3Fselect-key%3Ashenqingh%3D2015204531832%26select-key%3Azhuanlimc%3D%26select-key%3Ashenqingrxm%3D%26select-key%3Azhuanlilx%3D%26select-key%3Ashenqingr_from%3D%26select-key%3Ashenqingr_to%3D%26inner-flag%3Aopen-type%3Dwindow%26inner-flag%3Aflowno%3D1470846836440&amp;inner-flag:open-type=window&amp;inner-flag:flowno=1471142917509">网页</a>爬取内容。以往爬取网页内容复杂点的，一般就是处理下页面内容动态载入，动态载入的内容可能会要求复杂奇怪的参数，或者找到这个动态载入的HTTP接口在哪里麻烦点。但是这个网页不同。类似：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;td&gt;&lt;span name="record_yijiaof:feiyongzldm" title="pos||"&gt;&lt;span id="5d299905633d4aa288b65f5bf74e414c" class="nlkfqirnlfjerldfgzxcyiuro"&gt;专&lt;/span&gt;&lt;span id="546c73d012f74931aa5d45707121eb50" class="nlkfqirnlfjerldfgzxcyiuro"&gt;实&lt;/span&gt;&lt;span id="e0285e05974b4577b23b2ced8e453005" class="nlkfqirnlfjerldfgzxcyiuro"&gt;新&lt;/span&gt;&lt;span id="82b9e003de4e4577aa7617681a0d3777" class="nlkfqirnlfjerldfgzxcyiuro"&gt;用&lt;/span&gt;&lt;span id="417aaf4c6ad14b7781db02a688a4f885" class="nlkfqirnlfjerldfgzxcyiuro"&gt;用&lt;/span&gt;&lt;span id="a3f326efa35e4fe898d2f751e77d6777" class="nlkfqirnlfjerldfgzxcyiuro"&gt;新&lt;/span&gt;&lt;span id="c6c5135b931c48c09c6529735f4c6434" class="nlkfqirnlfjerldfgzxcyiuro"&gt;型&lt;/span&gt;&lt;span id="8c55b119929147ddbe178776903554e5" class="nlkfqirnlfjerldfgzxcyiuro"&gt;专&lt;/span&gt;&lt;span id="f8e47702c9f5420198a6f9b9aa132c9c" class="nlkfqirnlfjerldfgzxcyiuro"&gt;利&lt;/span&gt;&lt;span id="60cc2e23682e4ca2b850a92f55029458" class="nlkfqirnlfjerldfgzxcyiuro"&gt;第9年年费&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;</span></code></pre></td></tr></table></div></figure>


<p>最终希望得到的内容其实是<code>实用新型专利第9年年费</code>，但是得到的网页确实乱序后的字符串，并且每次刷新得到的乱序还不一样，试过几次也看不出规律。</p>

<p>按照以往的思路，猜测肯定是某个js文件中包含了还原算法，我的目的，就是找出这个算法，在爬虫程序中实现这个算法，以还原出可读的字符串。</p>

<p>js中要完成这样的事，首先得找到网页元素，包括：根据外层span <code>name=record_yijiaof:feiyongzldm</code>；根据再外层的table；根据内层span <code>class='nlkfqirnlfjerldfgzxcyiuro'</code>。以前我一直想要个工具，可以在某网页载入的所有js文件中搜索特定字符串，从而帮助逆向，但是一直没有这个工具。所以这次也只有人肉看每个js。根据js的名字猜测这个逻辑会放在哪里。</p>

<!-- more -->


<p>看了几个可能的js文件，在文件中都没有搜索出我认为可能的字符串。于是我又人肉搜索其他不太可能的js文件，均未果。此时陷入死胡同。</p>

<p>网页文件末尾会有个超长id的span元素，类似：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;span style="display: none" id="3535346033366237393b6c3c38343d3e71702777202021272f28282a797f2b2f0c1910411d4016171b4d4f1f49191b18075053040204010100085b0b580e0908776d2370227674712d2f2b7879287a2935696b6b306730606d683f6c6b39686857564e00520653565b5c08525f5c0d5b4812424a17434345414e494e1a491d49b4b2b6afbce6b3b2eab8bbb2b5bfb7bea4a6f6f7f6f0a7a0a0aeadada5adadaa9595c79688c39ec29c9e9d9b9ece97c985858083858c8ed68edf83d985dcdf8ef3f3a1faa7e9f0f7abaaf8aefefef8f7e2b4e6b0b5e7b4efede9bbe2eebbebead0d3dbd7d1ddcad2d0d88fdfd88fdddc9695c6c79693c595cd9fcbcacb989f9b32303a373236372b3039383f3e34683a71262b2120237722207b2279792c2d2d1043411b131017170411181a48151a4b0307570a01015255015b5e5e5e0d0f0624767374222377232d65282f2a282c2d69656a35626362663b3d633f3f39673e53555a015c04545f505a460d5f585a5a13464015174c14434f4a49434845184fb5b9e6b5e7e4e5e1bbbdeca7eab9bdb6f6a5a4f1a4a3a0f6acaaaaadfda5aea890c4c6c696c6c797999d92c980cbc89ad5828383848dd2828e8dd88ed984d88aa1a4f0a0a5a3a3f6abf8acaaf5e1fcfce2e3b0b5edb6e6efeabbeeeabebee6eb8685d0d186848486dbd18edcd8dfc2d7c39593cac6cdc7cecaccc9cfcb9e9f9d31623b3a61303465383132336a3f372322297322702d21717a782b7d287c287e194041161417431e104d4c124e491b181c005355025153540d09025d5e090b5d727973717d75277278797c7a2f7b792a347d6061306630606d6e696d3e386a3a58575a01545351515c5b09095c0f0a5744175e10454743144a1d42484948484be3b8b5bbb7e3bfb5bdebbebdbdebb9b8a6a7f3bff2f7a3a5abffaffdafacfdab9494c193c5929196c99bcb9c94c89c9dd2818ad5988c8680d98d8fda8b8b8adca6f5f4a6a2a7a5a1faadabfcaaf8f9adb2e2b0b2e5f</span></code></pre></td></tr></table></div></figure>


<p>这个字符串不像base64加密，看这个网页带了md5的js，怀疑跟md5有关，但md5不应该用来加密字符内容，js文件中也未看到可能的API。</p>

<p>后来发现乱序的字符串中有些字符是不显示的，通过这个css控制：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nlkfqirnlfjerldfgzxcyiuro {
</span><span class='line'>    display: none!important;
</span><span class='line'>    visibility: hidden!important;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>网页载入经过js处理后，显示出来的字符看起来是相同的css class <code>nlkfqirnlfjer1dfgzxcyiuro</code>，开始觉得奇怪，研究了下这个的差异。折腾了好久发现被人戏弄了：nlkfqirnlfje<strong>r1d</strong>fgzxcyiuro与nlkfqirnlfje<strong>rld</strong>fgzxcyiuro，前一个是<code>r1d</code>后一个是<code>rld</code>，分别是数字1和字母L！WTF</p>

<p>原始网页中所有字符的css class都是不显示的，所以可以推测js中经过一定算法将需要显示的字符改了css class。但是此刻还是没有思路。</p>

<p>后来尝试了chrome的DOM breakpoint，可以在DOM元素被改变时断点，但是用起来不是特别好用，没有带来任何帮助。</p>

<p>绝望之际把整个网页另存下来，另存下来的网页是经过js处理后的，手工将css改回原始内容，本地载入网页发现还是可以正常显示，证明处理逻辑真的还在js文件中。然后我逐个删除每一个js文件，还是想找出具体是哪个js文件包含了这个还原算法。</p>

<p>然后发现竟然是jquery-1.7.2.min.js。但我想这不能说明问题，因为作者肯定是通过jQuery来获取元素的，删除jQuery.js作者的代码不能work，当然就显示不出来。这个时候我开始清理html中的js代码，发现所有js代码都被清除完后，网页内容依然可以还原，所以断定还原算法就在jQuery.js中。然而这个文件是min版本的，网上找了个还原工具，其实就是重新格式化方便阅读。</p>

<p>但是此刻发现在这个文件中依然搜索不到可能的字符串，例如前面提到的找元素的一些线索，如span css，如span name等等。此时重新通过chrome的DOM断点来获取调用堆栈。这次直接断css class会被改变的span元素，竟然发现可行。此时无非是断点，看效果，继续下更精确的断点，最后发现源头：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>b(function() {
</span><span class='line'>    b.mix()
</span><span class='line'>});
</span><span class='line'>
</span><span class='line'>...
</span><span class='line'>mix: function() {
</span><span class='line'>    var b0 = bF("s" + "p" + "a" + "n");
</span><span class='line'>    if (b0 && b0[b0.length - 1]) {
</span><span class='line'>        var b5 = b0[b0.length - 1].getAttribute("i" + "d");
</span><span class='line'>        if (!b5) {
</span><span class='line'>            return
</span><span class='line'>        }
</span><span class='line'>        var b2 = "";
</span><span class='line'>        var b4 = 0;
</span><span class='line'>        for (var b3 = 0; b3 &lt; b5.length; b3 += 2) {
</span><span class='line'>            if (b4 &gt; 255) {
</span><span class='line'>                b4 = 0
</span><span class='line'>            }
</span><span class='line'>            var b1 = parseInt(parseInt(b5.substring(b3, b3 + 2), 16) ^ b4++);
</span><span class='line'>            b2 += String.fromCharCode(b1)
</span><span class='line'>        }
</span><span class='line'>        if (b2) {
</span><span class='line'>            // ... 省略
</span></code></pre></td></tr></table></div></figure>


<p>首先看到的是<code>"s" + "p" + "a" + "n"</code>，这不就是<code>span</code>！看前面几行代码很快就明白这是在取网页的最后一个<code>span</code>元素，也就是那个包含超长id属性的span元素。此时需要提下，之前也是对这个页尾span元素做过实验，发现必须是span元素且为最后一个元素才能正确还原网页内容，可以推断这个span是多么关键的一个线索。感兴趣的可以把这个网页的jQuery-1.7.2.min.js还原后查看<code>mix</code>函数实现。</p>

<p>翻译过来还原函数非常简单，写一个java版本：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static String parseSipoIds(String enStr) {
</span><span class='line'>  int b4 = 0;
</span><span class='line'>  StringBuilder sb = new StringBuilder();
</span><span class='line'>  for (int i = 0; i &lt; enStr.length(); i += 2) {
</span><span class='line'>    if (b4 &gt; 255) b4 = 0;
</span><span class='line'>    int c = Integer.parseInt(enStr.substring(i, i + 2), 16) ^ b4++;
</span><span class='line'>    sb.append((char)c);
</span><span class='line'>  }
</span><span class='line'>  return sb.toString();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>即这个span元素就是需要显示出来的span元素id集合，以逗号分隔。</p>

<p>以前还爬过一个日本政府网站，防爬也是做得很过分，不过主要是配合服务器，每一个网页的url是动态变化的，且需要从最原始的网页经过一定的操作才能获得。流程复杂让人痛苦不堪，最后还是一路携带cookie，真的模拟人的操作流程走下来。具体也记不清了。</p>

<p>最后吐槽一下，作者把还原算法写到jQuery.js里，也真是苦费心机。</p>

<p class='post-footer'>
            原文地址：
            <a href='http://codemacro.com/2016/08/16/reverse_html/'>http://codemacro.com/2016/08/16/reverse_html/</a><br/>
            written by <a href='http://codemacro.com'>Kevin Lynx</a>
            &nbsp;posted at <a href='http://codemacro.com'>http://codemacro.com</a>
            </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记一次线程局部存储与动态库引起的core]]></title>
    <link href="http://codemacro.com/2016/05/08/tls_so_coredump/"/>
    <updated>2016-05-08T00:00:00+08:00</updated>
    <id>http://codemacro.com/2016/05/08/tls_so_coredump</id>
    <content type="html"><![CDATA[<p>线上的服务退出时coredump，显示堆栈为：</p>

<p><img src="http://codemacro.com/assets/res/tls_so_core/core.JPG" alt="" /></p>

<p>google一下发现<a href="http://www.tuicool.com/articles/YJ3A7f">有人遇到过</a>，产生这个core的条件为：</p>

<ul>
<li>使用TLS时注册了destructor (<code>pthread_key_create</code>)，这个回调函数会在线程退出时被调用</li>
<li>这个destructor符号位于.so中</li>
<li>在线程退出时，这个.so已经被dlclose</li>
</ul>


<p>我们的程序模型中，类似于一个Web App server，有一个线程池包装了IO处理，将请求派发给应用插件，处理完后回应给客户端。应用插件是一个.so，被动态载入(dlopen)，该.so由于实现需要引入了较多的第三方.so(隐式载入)。初步排查时，整个实现是没有问题的，线程池是在.so close前关闭的。</p>

<p>没有线索，于是尝试找到该TLS是哪个模块引入的。通过gdb断<code>pthread_key_create</code>，以及不为空的destructor回调可以确定几个模块，但范围不够小，这些模块基本还是些基础模块，如zookeeper/mxml以及网络模块。</p>

<p>多看了几个core，发现这个回调的偏移地址都是固定的960，如上图中的<code>0x7f0f26c9f960</code>。.so被载入时，基址是会变的，但偏移是不会变的，例如通过nm查看.so中的符号时：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$nm lib/libsp_kit.so | grep loadConfig
</span><span class='line'>00000000002de170 T _ZN8sp_basic14SortRailConfig10loadConfigEPKc</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>其中<code>2de170</code>中<code>170</code>是确定不变的。所以范围可以进一步缩小，destructor是<code>pthread_key_create</code>第二个参数，每次断点触发时查看<code>rsi</code>寄存器的值就可以确定，然后发现落在了mxml库里的符号：</p>

<p><img src="http://codemacro.com/assets/res/tls_so_core/mxml.JPG" alt="" /></p>

<p>程序在启动时载入配置，触发了mxml在当前线程创建了TLS，这个线程是程序主线程。主线程当然是在.so被close后才退出的。如果这是问题，那应该很早前就会暴露。这是一个问题，后面会解释。但是问题排查到这个地方，又陷入了僵局。</p>

<p>回头再看下core环境，可以从线程环境确定是哪个模块：</p>

<p><img src="http://codemacro.com/assets/res/tls_so_core/arpc-threads.JPG" alt="" /></p>

<p>core的线程31956和线程31955靠近，查看31955堆栈，发现是我们内部的rpc库(arpc)线程。那可以确定core的线程有可能和arpc有关系。函数在调用时，返回地址留在堆栈中，堆栈不一定会被其他内容覆盖，所以可以查看线程堆栈里的符号地址，大概确定是什么模块。<code>x/200a $rsp-0x300</code>查看core线程堆栈：</p>

<p><img src="http://codemacro.com/assets/res/tls_so_core/arpc-stack.JPG" alt="" /></p>

<p>可以看到其中确实有arpc库里的符号信息，综合线程号关系，基本可以确定core的线程是arpc线程。这个时候就突然灵关一闪，想起我们程序中有热切换机制。该机制会在收到arpc请求时，重新载入所有配置，而这个动作是发生在arpc开的线程里。查看相关代码，发现arpc资源释放确实是晚于.so的close的。于是做了下实验，程序开启后进行一次热切换，退出后果然必core。程序在生产环境时，只在业务上线时进行一次热切换，而每天又会被自动重启，重启后并不进行热切换，所以线上基本上没有暴露出来，只在部分灰度环境偶尔触发(连续两次业务上线)。</p>

<p>回过头来，主线程问题怎么解释？google一圈发现，<strong>主线程退出，是不会调用TLS destructor的</strong>。参考<a href="https://github.com/rust-lang/rust/issues/28129">这里</a>，<a href="http://stackoverflow.com/questions/6357154/destruction-order-of-the-main-thread-and-the-use-of-pthread-key-create">这里</a>，以及<a href="https://github.com/rust-lang/rust/issues/19776">这里</a>。但是可以在主线程中显示调用<code>pthread_exit</code>来触发，普通线程会默认调用<code>pthread_exit</code>。</p>

<p>完。</p>

<p class='post-footer'>
            原文地址：
            <a href='http://codemacro.com/2016/05/08/tls_so_coredump/'>http://codemacro.com/2016/05/08/tls_so_coredump/</a><br/>
            written by <a href='http://codemacro.com'>Kevin Lynx</a>
            &nbsp;posted at <a href='http://codemacro.com'>http://codemacro.com</a>
            </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中隔离容器的实现]]></title>
    <link href="http://codemacro.com/2015/09/05/java-lightweight-container/"/>
    <updated>2015-09-05T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/09/05/java-lightweight-container</id>
    <content type="html"><![CDATA[<p>Java中隔离容器用于隔离各个依赖库环境，解决Jar包冲突问题。</p>

<h2>问题</h2>

<p>应用App依赖库LibA和LibB，而LibA和LibB又同时依赖LibBase，而LibA和LibB都是其他团队开发的，其中LibA发布了一个重要的修复版本，但是依赖LibBase v2.0，而LibB还没有升级版本，LibBase还不是兼容的，那么此时升级就会面临困难。在生产环境中这种情况往往更恶劣，可能是好几层的间接依赖关系。</p>

<p>隔离容器用于解决这种问题。它把LibA和LibB的环境完全隔离开来，LibBase即使类名完全相同也不互相冲突，使得LibA和LibB的升级互不影响。众所周知，Java中判定两个类是否相同，看的是类名和其对应的class loader，两者同时相同才表示相等。隔离容器正是利用这种特性实现的。</p>

<h2>KContainer</h2>

<p>这里我实现了一个demo，称为KContainer，源码见<a href="https://github.com/kevinlynx/kcontainer">github kcontainer</a>。这个container模仿了一些OSGI的东西，这里把LibA和LibB看成是两个bundle，bundle之间是互相隔离的，每个bundle有自己所依赖的第三方库，bundle之间的第三方库完全对外隐藏。bundle可以导出一些类给其他bundle用，bundle可以开启自己的服务。由于是个demo，我只实现关键的部分。</p>

<p>KContainer的目录结构类似：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.
</span><span class='line'>|-- bundle
</span><span class='line'>    |-- test1
</span><span class='line'>        |-- test1.prop
</span><span class='line'>        |-- classes
</span><span class='line'>        |-- lib
</span><span class='line'>            |-- a.jar
</span><span class='line'>            |-- b.jar
</span><span class='line'>    |-- test2
</span><span class='line'>        |-- test2.prop
</span><span class='line'>        |-- classes
</span><span class='line'>|-- lib
</span><span class='line'>    |-- kcontainer.jar
</span><span class='line'>    |-- kcontainer.interface.jar</span></code></pre></td></tr></table></div></figure>


<p>bundle目录存放了所有会被自动载入的bundle。每一个bundle都有一个配置文件<code>bundle-name.prop</code>，用于描述自己导出哪些类，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>init=com.codemacro.test.B
</span><span class='line'>export-class=com.codemacro.test.Export; com.codemacro.test.Export2</span></code></pre></td></tr></table></div></figure>


<p><code>init</code>指定bundle启动时需要调用的类，用户可以在这个类里开启自己的服务；<code>export-class</code>描述需要导出的类列表。bundle之间的所有类都是隔离的，但<code>export-class</code>会被统一放置，作为所有bundle共享的类。后面会描述KContainer如何处理类加载问题，这也是隔离容器的主要内容。</p>

<!-- more -->


<p>bundle依赖的类可以直接以<code>*.class</code>文件存放到<code>classes</code>目录，也可以作为<code>*.jar</code>放到<code>lib</code>目录。作为extra pratice，我还会把<code>*.jar</code>中的jar解压同时作为类加载的路径。</p>

<p>KContainer本身可以作为一个framework被使用。为了示例，我写了一个入口类，加载启动完所有bundle后就退出了，这个仅作为例子，用不了生产。</p>

<h2>隔离的核心实现</h2>

<p>隔离的目的是分开各个bundle中的类。利用的语言特性包括：</p>

<ul>
<li>class的区分由class name和载入其的class loader共同决定</li>
<li>当在class A中使用了class B时，JVM默认会用class A的class loader去加载class B</li>
<li>class loader中的双亲委托机制</li>
<li><code>URLClassLoader</code>会从指定的目录及*.jar中加载类</li>
</ul>


<p>KContainer的主要任务，就是为bundle实现一个自定义的class loader。</p>

<p>当KContainer加载一个bundle时，在处理其<code>export-class</code>或<code>init</code>时，都是需要加载bundle中的类的。在这之前，我给每一个bundle关联一个独立的<code>BundleClassLoader</code>。然后用这个class loader去加载bundle中的类，利用class loader传递特性，使得一个bundle中的所有类都是由其关联的class loader加载的，从而实现bundle之间类隔离效果。</p>

<p>实现class loader时，是实现<code>loadClass</code>还是<code>findClass</code>？通过实现<code>loadClass</code>我们可以改变class loader的双亲委托模式，制定加载类的具体顺序。但我的目的仅仅是隔离bundle，想了下其实实现<code>findClass</code>就可以达成目的。关于<code>loadClass</code>和<code>findClass</code>的区别可以参考这里 (<a href="http://blog.csdn.net/fenglibing/article/details/17471659">实现自己的类加载时，重写方法loadClass与findClass的区别</a>)。简单来说，就是<code>findClass</code>只有在类确实找不到的情况下才会被调用，在此之前，<code>loadClass</code>默认都是走的双亲委托模式。</p>

<p><code>BundleClassLoader</code>派生于<code>URLClassLoader</code>，默认的parent class loader就是<code>system class loader</code> (<code>app class loader</code>)。这使得KContainer中的bundle类加载有三层选择：自己的class path；其他bundle共享的classes；jvm的class path。通过实现<code>findClass</code>，在默认路径都无法加载到类时，才尝试bundle共享的class，优先级最低。</p>

<p>其实现大概为：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BundleClassLoader</span> <span class="kd">extends</span> <span class="n">URLClassLoader</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nf">BundleClassLoader</span><span class="o">(</span><span class="n">File</span> <span class="n">home</span><span class="o">,</span> <span class="n">SharedClassList</span> <span class="n">sharedClasses</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// getClassPath将bundle目录下的classes和各个jar作为class path传给URLClassLoader</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">getClassPath</span><span class="o">(</span><span class="n">home</span><span class="o">));</span> 
    <span class="k">this</span><span class="o">.</span><span class="na">sharedClasses</span> <span class="o">=</span> <span class="n">sharedClasses</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">findClass</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
    <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&quot;try find class {}&quot;</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>
    <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">claz</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">claz</span> <span class="o">=</span> <span class="kd">super</span><span class="o">.</span><span class="na">findClass</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">claz</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">claz</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&quot;load from class path for {}&quot;</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>
      <span class="k">return</span> <span class="n">claz</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">claz</span> <span class="o">=</span> <span class="n">sharedClasses</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">claz</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&quot;load from shared class for {}&quot;</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>
      <span class="k">return</span> <span class="n">claz</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">logger</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">&quot;not found class {}&quot;</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">ClassNotFoundException</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>


<p>完整代码参看<a href="https://github.com/kevinlynx/kcontainer/blob/master/kcontainer/src/main/java/com/codemacro/container/BundleClassLoader.java">BundleClassLoader.java</a></p>

<p>创建bundle时，会为其创建自己的class loader，并使用这个class loader来载入<code>export-class</code>和<code>init-class</code>：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="n">Bundle</span> <span class="nf">create</span><span class="o">(</span><span class="n">File</span> <span class="n">home</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">SharedClassList</span> <span class="n">sharedClasses</span><span class="o">,</span> 
      <span class="n">BundleConf</span> <span class="n">conf</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">BundleClassLoader</span> <span class="n">loader</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">BundleClassLoader</span><span class="o">(</span><span class="n">home</span><span class="o">,</span> <span class="n">sharedClasses</span><span class="o">);</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">exports</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="na">getExportClassNames</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">exports</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;load exported classes for {}&quot;</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>
      <span class="n">loadExports</span><span class="o">(</span><span class="n">loader</span><span class="o">,</span> <span class="n">sharedClasses</span><span class="o">,</span> <span class="n">exports</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">Bundle</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">conf</span><span class="o">.</span><span class="na">getInitClassName</span><span class="o">(),</span> <span class="n">loader</span><span class="o">);</span>
  <span class="o">}</span>
  
  <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">loadExports</span><span class="o">(</span><span class="n">ClassLoader</span> <span class="n">loader</span><span class="o">,</span> <span class="n">SharedClassList</span> <span class="n">sharedClasses</span><span class="o">,</span>
      <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">exports</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="nl">claz_name:</span> <span class="n">exports</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
          <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">claz</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span><span class="n">claz_name</span><span class="o">);</span> <span class="c1">// 载入class</span>
          <span class="n">sharedClasses</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">claz_name</span><span class="o">,</span> <span class="n">claz</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">logger</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">&quot;load class {} failed&quot;</span><span class="o">,</span> <span class="n">claz_name</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="o">}</span>
  <span class="o">}</span></code></pre></div>


<p>以上。</p>

<h2>扩展</h2>

<p>扩展的地方有很多，例如支持导出package，导出一个完整的jar。当然可能需要实现<code>loadClass</code>，以改变类加载的优先级，让共享类的优先级高于jvm class path的优先级。</p>

<h2>其他</h2>

<h3>线程ContextClassLoader</h3>

<p>提到class loader，我们看下最常接触的几类：</p>

<ul>
<li><code>XX.class.getClassLoader</code>，获取加载类<code>XX</code>的class loader</li>
<li><code>Thread.currentThread().getContextClassLoader()</code>，获取当前线程的ContextClassLoader</li>
<li><code>ClassLoader.getSystemClassLoader()</code>，获取system class loader</li>
</ul>


<p>system class loader的parent就是ext class loader，再上面就是bootstrap class loader了 (不是java类，实际获取不到)。默认情况下以上三个class loader都是一个：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ClassLoader</span><span class="o">.</span><span class="na">getSystemClassLoader</span><span class="o">());</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Main</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">());</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getContextClassLoader</span><span class="o">());</span></code></pre></div>


<p>Output:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sun.misc.Launcher$AppClassLoader@157c2bd
</span><span class='line'>sun.misc.Launcher$AppClassLoader@157c2bd
</span><span class='line'>sun.misc.Launcher$AppClassLoader@157c2bd</span></code></pre></td></tr></table></div></figure>


<p>创建线程时，新的线程ContextClassLoader就是父线程的ContextClassLoader。在载入一个新的class时，推荐优先使用线程context class loader，例如框架<a href="http://jodd.org/">Jodd</a>中包装的。关于线程context class loader和<code>Class.getClassLoader</code>这里有个解释算是相对合理：<a href="http://www.xcoder.cn/html/web/j2ee/2013/0506/5557.html">ContextClassLoader浅析</a></p>

<p>即，当你把一个对象A传递到另一个线程中，这个线程由对象B创建，A/B两个对象对应的类关联的class loader不同，在B的线程中调用A.some_method，some_method加载资源或类时，如果使用了<code>Class.getClassLoader</code>或<code>Class.forName</code>时，实际使用的是A的class loader，而这个行为可能不是预期的。这个时候就需要将代码改为<code>Thread.currentThread().getContextClassLoader()</code>。</p>

<p>完。</p>

<p class='post-footer'>
            原文地址：
            <a href='http://codemacro.com/2015/09/05/java-lightweight-container/'>http://codemacro.com/2015/09/05/java-lightweight-container/</a><br/>
            written by <a href='http://codemacro.com'>Kevin Lynx</a>
            &nbsp;posted at <a href='http://codemacro.com'>http://codemacro.com</a>
            </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java GC总结]]></title>
    <link href="http://codemacro.com/2015/08/10/java-gc-summary/"/>
    <updated>2015-08-10T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/08/10/java-gc-summary</id>
    <content type="html"><![CDATA[<p>Java GC相关的文章有很多，本文只做概要性总结，主要内容来源于&lt;深入理解Java虚拟机>。</p>

<h2>对象存活性判定</h2>

<p>对象存活性判定用于确定一个对象是死是活，死掉的对象则需要被垃圾回收。主要包括的方法：</p>

<ul>
<li>引用计数</li>
<li>可达性分析</li>
</ul>


<p>可达性分析的基本思想是：</p>

<blockquote><p>通过一系列的称为&#8221;GC Roots&#8221;的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链项链时，则证明此对象是不可用的。</p></blockquote>

<p>在Java中有很多种类的对象可以作为GC Roots，例如类静态属性引用的对象。</p>

<h2>垃圾收集算法</h2>

<p>确定了哪些对象是需要回收之后，就可以运用各种垃圾收集算法收集这些对象，例如直接回收内存，或者回收并移动整理内存。</p>

<p>主要包括：</p>

<ul>
<li>标记清除(Mark-Sweep)算法：首先标记出需要回收的对象，然后统一回收被标记的对象</li>
<li>复制(Copying)算法：将可用内存分块，当一块内存用完后将存活对象复制到其他块，并统一回收不使用的块。Java中新生代对象一般使用该方法</li>
<li>标记整理(Mark-Compact)算法：基本同标记清除，不同的是回收时是把可用对象进行移动，以避免内存碎片问题</li>
<li>分代收集，将内存分区域，不同区域采用不同的算法，例如Java中的新生代及老年代</li>
</ul>


<!-- more -->


<p><img src="http://codemacro.com/assets/res/heap-structure.png" alt="" /></p>

<p>如上，Java Hotspot虚拟机实现中将堆内存分为3大区域，即新生代、老年代、永久代。新生代中又分了eden、survivor0及survivor1，采用复制算法；老年代则采用标记清除及标记整理；永久代存放加载的类，类似于代码段，但同样会发生GC。</p>

<h2>垃圾收集器</h2>

<p>垃圾收集算法在实现时会略有不同，不同的实现称为垃圾收集器。不同的垃圾收集器适用的范围还不一样，有些收集器仅能用于新生代，有些用于老年代，有些新生代老年代都可以被使用。垃圾收集器可通过JVM启动参数指定。</p>

<p><img src="http://codemacro.com/assets/res/hotspot-gc-collectors.png" alt="" /></p>

<p>上图中展示了新生代（年轻代）和老年代可用的各种垃圾收集器，图中的连线表示两种收集器可以配合使用。</p>

<ul>
<li>Serial收集器，单线程收集，复制算法</li>
<li>ParNew收集器，Serial收集器的多线程版本</li>
<li>Parallel Scavenge收集器，复制算法，吞吐量优先的收集器，更高效率地利用CPU时间，适合用于服务器程序</li>
<li>Serial Old收集器，单线程收集，标记整理算法</li>
<li>Parallel Old收集器，标记整理算法，Parallel Scavenge收集器的老年代版本</li>
<li>CMS(Concurrent Mark Sweep)收集器，标记清除算法，以获取最短停顿时间为目标的收集器</li>
<li>G1收集器，较新的收集器实现</li>
</ul>


<p>JVM有些参数组合了各种收集器，例如：</p>

<ul>
<li><code>UseConcMarkSweepGC</code>：使用ParNew + CMS + Serial Old收集器</li>
<li><code>UseParallelGC</code>，运行在server模式下的默认值，使用Parallel Scavenge + Serial Old 收集器</li>
</ul>


<h2>GC日志</h2>

<p>生产服务器一般会配置GC日志，以在故障时能够分析问题所在，一般的应用可配置以下JVM参数：</p>

<pre><code>-XX:+UseParallelGC -XX:+DisableExplicitGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:./logs/gc.log 
</code></pre>

<p>输出日志类似：</p>

<pre><code>1456772.057: [GC [PSYoungGen: 33824K-&gt;96K(33920K)] 53841K-&gt;20113K(102208K), 0.0025050 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
1456863.534: [GC [PSYoungGen: 33824K-&gt;96K(33920K)] 53841K-&gt;20113K(102208K), 0.0020050 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
1456962.061: [GC [PSYoungGen: 33824K-&gt;128K(33920K)] 53841K-&gt;20145K(102208K), 0.0014150 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]
</code></pre>

<ul>
<li><code>1456772.057</code>，自JVM启动后的时间值</li>
<li><code>GC</code> 表示本次进行的是一次minor GC，即年轻代中的GC</li>
<li><code>PSYoungGen</code> 垃圾收集器类型，这里是Parallel Scavenge</li>
<li><code>33824K-&gt;96K(33920K)</code>，收集前后新生代大小，<code>33920K</code>为新生代总大小(eden+ 1 survivor)</li>
<li><code>53841K-&gt;20113K(102208K)</code>，堆总大小及GC前后大小</li>
<li><code>0.0025050 secs</code>，GC时停顿时间</li>
</ul>


<h2>常见策略</h2>

<p>JVM GC相关的有一些策略值得注意：</p>

<ul>
<li>对象优先在eden分配，当回收时（Eden区可用内存不够），将Eden和当前Survivor还存活着的对象一次性复制到另外一块Survivor，最后清理Eden和刚才用过的Survivor。这个过程称为一次MinorGC，每次MinorGC就会增加活着对象的年龄，当年龄超过某值(-XX:MaxTenuringThreashold)时，就会被转移到老年代(Tenured)。老年代发生GC时被称为FullGC</li>
<li>每一次发生MinorGC而存活下来的对象其年龄都会加1，较老的对象会进入老年代</li>
<li>当分配大对象(> PretenureSizeThreshold)时，其就会直接进入老年代</li>
<li>当年轻代(Eden+Survivor)不足以容纳存活对象时，这些对象会被全部放入老年代(分配担保机制)</li>
</ul>


<p class='post-footer'>
            原文地址：
            <a href='http://codemacro.com/2015/08/10/java-gc-summary/'>http://codemacro.com/2015/08/10/java-gc-summary/</a><br/>
            written by <a href='http://codemacro.com'>Kevin Lynx</a>
            &nbsp;posted at <a href='http://codemacro.com'>http://codemacro.com</a>
            </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[写了一个分布式名字服务JCM]]></title>
    <link href="http://codemacro.com/2015/07/04/jcm/"/>
    <updated>2015-07-04T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/07/04/jcm</id>
    <content type="html"><![CDATA[<p>之前在公司里维护了一个名字服务，这个名字服务日常管理了近4000台机器，有4000个左右的客户端连接上来获取机器信息，由于其基本是一个单点服务，所以某些模块接近瓶颈。后来倒是有重构计划，详细设计做了，代码都写了一部分，结果由于某些原因重构就被终止了。</p>

<p><a href="https://github.com/kevinlynx/jcm">JCM</a>是我业余时间用Java重写的一个版本，功能上目前只实现了基础功能。由于它是个完全分布式的架构，所以理论上可以横向扩展，大大增强系统的服务能力。</p>

<h2>名字服务</h2>

<p>在分布式系统中，某个服务为了提升整体服务能力，通常部署了很多实例。这里我把这些提供相同服务的实例统称为集群(<code>cluster</code>)，每个实例称为一个节点(<code>Node</code>)。一个应用可能会使用很多cluster，每次访问一个cluster时，就通过名字服务获取该cluster下一个可用的node。那么，名字服务至少需要包含的功能：</p>

<ul>
<li>根据cluster名字获取可用的node</li>
<li>对管理的所有cluster下的所有node进行健康度的检测，以保证始终返回可用的node</li>
</ul>


<p>有些名字服务仅对node管理，不参与应用与node间的通信，而有些则可能作为应用与node间的通信转发器。虽然名字服务功能简单，但是要做一个分布式的名字服务还是比较复杂的，因为数据一旦分布式了，就会存在同步、一致性问题的考虑等。</p>

<h2>What&rsquo;s JCM</h2>

<p>JCM围绕前面说的名字服务基础功能实现。包含的功能：</p>

<ul>
<li>管理cluster到node的映射</li>
<li>分布式架构，可水平扩展以实现管理10,000个node的能力，足以管理一般公司的后台服务集群</li>
<li>对每个node进行健康检查，健康检查可基于HTTP协议层的检测或TCP连接检测</li>
<li>持久化cluster/node数据，通过zookeeper保证数据一致性</li>
<li>提供JSON HTTP API管理cluster/node数据，后续可提供Web管理系统</li>
<li>以库的形式提供与server的交互，库本身提供各种负载均衡策略，保证对一个cluster下node的访问达到负载均衡</li>
</ul>


<p>项目地址<a href="https://github.com/kevinlynx/jcm">git jcm</a></p>

<p>JCM主要包含两部分：</p>

<ul>
<li>jcm.server，JCM名字服务，需要连接zookeeper以持久化数据</li>
<li>jcm.subscriber，客户端库，负责与jcm.server交互，提供包装了负载均衡的API给应用使用</li>
</ul>


<!-- more -->


<h3>架构</h3>

<p>基于JCM的系统整体架构如下：</p>

<p><img src="https://raw.githubusercontent.com/kevinlynx/jcm/master/doc/asset/simple-arch.jpg" alt="simple-arch.jpg" /></p>

<p>cluster本身是不需要依赖JCM的，要通过JCM使用这些cluster，只需要通过JCM HTTP API注册这些cluster到jcm.server上。要通过jcm.server使用这些cluster，则是通过jcm.subscriber来完成。</p>

<h3>使用</h3>

<p>可参考<a href="https://github.com/kevinlynx/jcm/blob/master/README.md">git READMe.md</a></p>

<p>需要jre1.7+</p>

<ol>
<li>启动zookeeper</li>
<li>下载jcm.server <a href="https://github.com/kevinlynx/jcm/tree/master/dist">git jcm.server-0.1.0.jar</a></li>
<li>在<code>jcm.server-0.1.0.jar</code>目录下建立<code>config/application.properties</code>文件进行配置，参考<a href="https://github.com/kevinlynx/jcm/blob/master/jcm.server/config/application.properties">config/application.properties</a></li>
<li><p>启动jcm.server</p>

<pre><code> java -jar jcm.server-0.1.0.jar
</code></pre></li>
<li><p>注册需要管理的集群，参考cluster描述：<a href="https://github.com/kevinlynx/jcm/blob/master/doc/cluster_sample.json">doc/cluster_sample.json</a>，通过HTTP API注册：</p>

<pre><code> curl -i -X POST http://10.181.97.106:8080/c -H "Content-Type:application/json" --data-binary @./doc/cluster_sample.json
</code></pre></li>
</ol>


<p>部署好了jcm.server，并注册了cluster后，就可以通过jcm.subscriber使用：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 传入需要使用的集群名hello9/hello，以及传入jcm.server地址，可以多个：127.0.0.1:8080</span>
<span class="n">Subscriber</span> <span class="n">subscriber</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Subscriber</span><span class="o">(</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">&quot;127.0.0.1:8080&quot;</span><span class="o">),</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">&quot;hello9&quot;</span><span class="o">,</span> <span class="s">&quot;hello&quot;</span><span class="o">));</span>
<span class="c1">// 使用轮询负载均衡策略</span>
<span class="n">RRAllocator</span> <span class="n">rr</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">RRAllocator</span><span class="o">();</span>
<span class="n">subscriber</span><span class="o">.</span><span class="na">addListener</span><span class="o">(</span><span class="n">rr</span><span class="o">);</span>
<span class="n">subscriber</span><span class="o">.</span><span class="na">startup</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// rr.alloc 根据cluster名字获取可用的node</span>
  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">rr</span><span class="o">.</span><span class="na">alloc</span><span class="o">(</span><span class="s">&quot;hello9&quot;</span><span class="o">,</span> <span class="n">ProtoType</span><span class="o">.</span><span class="na">HTTP</span><span class="o">));</span>
<span class="o">}</span>
<span class="n">subscriber</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span></code></pre></div>


<h2>JCM实现</h2>

<p>JCM目前的实现比较简单，参考模块图：</p>

<p><img src="https://raw.githubusercontent.com/kevinlynx/jcm/master/doc/asset/impl-module.jpg" alt="impl-module" /></p>

<ul>
<li>model，即cluster/node这些数据结构的描述，同时被jcm.server和jcm.subscriber依赖</li>
<li>storage，持久化数据到zookeeper，同时包含jcm.server实例之间的数据同步</li>
<li>health check，健康检查模块，对各个node进行健康检查</li>
</ul>


<p>以上模块都不依赖Spring，基于以上模块又有：</p>

<ul>
<li>http api，使用spring-mvc，包装了一些JSON HTTP API</li>
<li>Application，基于spring-boot，将各个基础模块组装起来，提供standalone的模式启动，不用部署到tomcat之类的servlet容器中</li>
</ul>


<p>jcm.subscriber的实现更简单，主要是负责与jcm.server进行通信，以更新自己当前的model层数据，同时提供各种负载均衡策略接口：</p>

<ul>
<li>subscriber，与jcm.server通信，定期增量拉取数据</li>
<li>node allocator，通过listener方式从subscriber中获取数据，同时实现各种负载均衡策略，对外统一提供<code>alloc node</code>的接口</li>
</ul>


<p>接下来看看关键功能的实现</p>

<h3>数据同步</h3>

<p>既然jcm.server是分布式的，每一个jcm.server instance(实例)都是支持数据读和写的，那么当jcm.server管理着一堆cluster上万个node时，每一个instance是如何进行数据同步的？jcm.server中的数据主要有两类：</p>

<ul>
<li>cluster本身的数据，包括cluster/node的描述，例如cluster name、node IP、及其他附属数据</li>
<li>node健康检查的数据</li>
</ul>


<p>对于cluster数据，因为cluster对node的管理是一个两层的树状结构，而对cluster有增删node的操作，所以并不能在每一个instance上都提供真正的数据写入，这样会导致数据丢失。假设同一时刻在instance A和instance B上同时对cluster c1添加节点N1和N2，那么instance A写入c1(N1)，而instance B还没等到数据同步就写入c1(N2)，那么c1(N1)就被覆盖为c1(N2)，从而导致添加的节点N1丢失。</p>

<p>所以，jcm.server instance是分为<code>leader</code>和<code>follower</code>的，真正的写入操作只有leader进行，follower收到写操作请求时转发给leader。leader写数据优先更新内存中的数据再写入zookeeper，内存中的数据更新当然是需要加锁互斥的，从而保证数据的正确性。</p>

<p><img src="https://raw.githubusercontent.com/kevinlynx/jcm/master/doc/asset/write-watch.jpg" alt="write-watch.jpg" /></p>

<p>leader和follower是如何确定角色的？这个很简单，标准的利用zookeeper来进行主从<a href="https://github.com/kevinlynx/jcm/blob/master/jcm.server/src/main/java/com/codemacro/jcm/util/ZookeeperLeaderElector.java">选举的实现</a>。</p>

<p>jcm.server instance数据间的同步是基于zookeeper watch机制的。这个可以算做是一个JCM的一个瓶颈，每一个instance都会作为一个watch，使得实际上jcm.server并不能无限水平扩展，扩展到一定程度后，watch的效率就可能不足以满足性能了，参考<a href="http://codemacro.com/2014/09/21/zk-watch-benchmark/">zookeeper节点数与watch的性能测试</a> (那个时候我就在考虑对我们系统的重构了) 。</p>

<p>jcm.server中对node健康检查的数据采用同样的同步机制，但node健康检查数据是每一个instance都会写入的，下面看看jcm.server是如何通过分布式架构来分担压力的。</p>

<h3>健康检查</h3>

<p>jcm.server的另一个主要功能的是对node的健康检查，jcm.server集群可以管理几万的node，既然已经是分布式了，那么显然是要把node均分到多个instance的。这里我是以cluster来分配的，方法就是简单的使用一致性哈希。通过一致性哈希，决定一个cluster是否属于某个instance负责。每个instance都有一个server spec，也就是该instance对外提供服务的地址(IP+port)，这样在任何一个instance上，它看到的所有instance server spec都是相同的，从而保证在每一个instance上计算cluster的分配得到的结果都是一致的。</p>

<p>健康检查按cluster划分，可以简化数据的写冲突问题，在正常情况下，每个instance写入的健康检查结果都是不同的。</p>

<p><img src="https://raw.githubusercontent.com/kevinlynx/jcm/master/doc/asset/health-check.jpg" alt="health-check.jpg" /></p>

<p>健康检查一般以1秒的频率进行，jcm.server做了优化，当检查结果和上一次一样时，并不写入zookeeper。写入的数据包含了node的完整key (IP+Port+Spec)，这样可以简化很多地方的数据同步问题，但会增加写入数据的大小，写入数据的大小是会影响zookeeper的性能的，所以这里简单地对数据进行了压缩。</p>

<p>健康检查是可以支持多种检查实现的，目前只实现了HTTP协议层的检查。健康检查自身是单个线程，在该线程中基于异步HTTP库，发起异步请求，实际的请求在其他线程中发出。</p>

<h3>jcm.subscriber通信</h3>

<p>jcm.subscriber与jcm.server通信，主要是为了获取最新的cluster数据。subscriber初始化时会拿到一个jcm.server instance的地址列表，访问时使用轮询策略以平衡jcm.server在处理请求时的负载。subscriber每秒都会请求一次数据，请求中描述了本次请求想获取哪些cluster数据，同时携带一个cluster的version。每次cluster在server变更时，version就变更（时间戳）。server回复请求时，如果version已最新，只需要回复node的状态。</p>

<p>subscriber可以拿到所有状态的node，后面可以考虑只拿正常状态的node，进一步减少数据大小。</p>

<h2>压力测试</h2>

<p>目前只对健康检查部分做了压测，详细参考<a href="https://github.com/kevinlynx/jcm/blob/master/test/beanchmark/benchmark.md">test/benchmark.md</a>。在A7服务器上测试，发现写zookeeper及zookeeper的watch足以满足要求，jcm.server发起的HTTP请求是主要的性能热点，单jcm.server instance大概可以承载20000个node的健康监测。</p>

<p>网络带宽：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Time              ---------------------traffic--------------------
</span><span class='line'>Time               bytin  bytout   pktin  pktout  pkterr  pktdrp
</span><span class='line'>01/07/15-21:30:48   3.2M    4.1M   33.5K   34.4K    0.00    0.00
</span><span class='line'>01/07/15-21:30:50   3.3M    4.2M   33.7K   35.9K    0.00    0.00
</span><span class='line'>01/07/15-21:30:52   2.8M    4.1M   32.6K   41.6K    0.00    0.00</span></code></pre></td></tr></table></div></figure>


<p>CPU，通过jstack查看主要的CPU消耗在HTTP库实现层，以及健康检查线程：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
</span><span class='line'>13301 admin     20   0 13.1g 1.1g  12m R 76.6  2.3   2:40.74 java         httpchecker
</span><span class='line'>13300 admin     20   0 13.1g 1.1g  12m S 72.9  2.3   0:48.31 java
</span><span class='line'>13275 admin     20   0 13.1g 1.1g  12m S 20.1  2.3   0:18.49 java</span></code></pre></td></tr></table></div></figure>


<p>代码中增加了些状态监控：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>checker HttpChecker stat count 20 avg check cost(ms) 542.05, avg flush cost(ms) 41.35</span></code></pre></td></tr></table></div></figure>


<p>表示平均每次检查耗时542毫秒，写数据因为开启了cache没有参考价值。</p>

<p>虽然还可以从我自己的代码中做不少优化，但既然单机可以承载20000个节点的检测，一般的应用远远足够了。</p>

<h2>总结</h2>

<p>名字服务在分布式系统中虽然是基础服务，但往往承担了非常重要的角色，数据同步出现错误、节点状态出现瞬时的错误，都可能对整套系统造成较大影响，业务上出现较大故障。所以名字服务的健壮性、可用性非常重要。实现中需要考虑很多异常情况，包括网络不稳定、应用层的错误等。为了提高足够的可用性，一般还会加多层的数据cache，例如subscriber端的本地cache，server端的本地cache，以保证在任何情况下都不会影响应用层的服务。</p>

<p class='post-footer'>
            原文地址：
            <a href='http://codemacro.com/2015/07/04/jcm/'>http://codemacro.com/2015/07/04/jcm/</a><br/>
            written by <a href='http://codemacro.com'>Kevin Lynx</a>
            &nbsp;posted at <a href='http://codemacro.com'>http://codemacro.com</a>
            </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于servlet实现一个web框架]]></title>
    <link href="http://codemacro.com/2015/06/07/servlet-web-framework/"/>
    <updated>2015-06-07T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/06/07/servlet-web-framework</id>
    <content type="html"><![CDATA[<p>servlet作为一个web规范，其本身就算做一个web开发框架，但是其web action (响应某个URI的实现)的实现都是基于类的，不是很方便，并且3.0之前的版本还必须通过web.xml配置来增加新的action。servlet中有一个filter的功能，可以配置所有URI的功能都经过filter。我们可以基于filter的功能来实现一个简单的web框架。在这个框架中，主要改进URI action的映射，就像<a href="https://www.playframework.com/">play framework</a>中route的配置：</p>

<pre><code>GET     /hello      com.codemacro.webdemo.test.TestController.hello
GET     /route      com.codemacro.webdemo.test.TestController.route
POST    /hello      com.codemacro.webdemo.test.TestController.sayHello
</code></pre>

<p>即把某个URI映射到类接口级别。基于servlet实现web框架的好处不仅实现简单，还能运行在所有支持servlet容器规范的web server上，例如Tomcat、Jetty。</p>

<p>本文提到的web framework demo可以从我的github 上取得：<a href="https://github.com/kevinlynx/servlet-web-framework-demo">servlet-web-framework-demo</a></p>

<h2>功能</h2>

<p>这个web framework URI action部分（或者说URI routing）如同前面描述，action的编写如：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestController</span> <span class="kd">extends</span> <span class="n">BaseController</span> <span class="o">{</span>
  <span class="c1">// 返回字符串</span>
  <span class="kd">public</span> <span class="n">Result</span> <span class="nf">index</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">ok</span><span class="o">(</span><span class="s">&quot;hello world&quot;</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="c1">// HTTP 404</span>
  <span class="kd">public</span> <span class="n">Result</span> <span class="nf">code404</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">status</span><span class="o">(</span><span class="mi">404</span><span class="o">,</span> <span class="s">&quot;not found&quot;</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="c1">// 使用JSP模板渲染</span>
  <span class="kd">public</span> <span class="n">Result</span> <span class="nf">template</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">String</span><span class="o">[]</span> <span class="n">langs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[]</span> <span class="o">{</span><span class="s">&quot;c++&quot;</span><span class="o">,</span> <span class="s">&quot;java&quot;</span><span class="o">,</span> <span class="s">&quot;python&quot;</span><span class="o">};</span>
    <span class="k">return</span> <span class="nf">ok</span><span class="o">(</span><span class="n">jsp</span><span class="o">(</span><span class="s">&quot;index.jsp&quot;</span><span class="o">)</span>
        <span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">,</span> <span class="s">&quot;kevin&quot;</span><span class="o">)</span>
        <span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;langs&quot;</span><span class="o">,</span>  <span class="n">langs</span><span class="o">)</span>
        <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>




<!-- more -->


<p>有了action之后，配置<code>route</code>文件映射URI即可：</p>

<pre><code>GET /index  com.codemacro.webdemo.test.TestController.index
GET /404    com.codemacro.webdemo.test.TestController.code404
GET /index.jsp com.codemacro.webdemo.test.TestController.template
</code></pre>

<p>然后配置<code>web.xml</code>，增加一个filter：</p>

<pre><code>&lt;filter&gt;
  &lt;filter-name&gt;MyWebFilter&lt;/filter-name&gt;
  &lt;filter-class&gt;com.codemacro.webdemo.MyServletFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
  &lt;filter-name&gt;MyWebFilter&lt;/filter-name&gt;
  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>

<p>最后以war的形式部署到Jetty <code>webapps</code>下即可运行。想想下次要再找个什么lightweight Java web framework，直接用这个demo就够了。接下来讲讲一些关键部分的实现。</p>

<h2>servlet basic</h2>

<p>基于servlet开发的话，引入servlet api是必须的：</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
    &lt;version&gt;2.5&lt;/version&gt;
    &lt;type&gt;jar&lt;/type&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<p>servlet filter的接口包含：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyServletFilter</span> <span class="kd">implements</span> <span class="n">Filter</span> <span class="o">{</span>
  <span class="c1">// web app启动时调用一次，可用于web框架初始化</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">(</span><span class="n">FilterConfig</span> <span class="n">conf</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ServletException</span> <span class="o">{</span> <span class="o">}</span>

  <span class="c1">// 满足filter url-pattern时就会调用；req/res分别对应HTTP请求和回应</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doFilter</span><span class="o">(</span><span class="n">ServletRequest</span> <span class="n">req</span><span class="o">,</span> <span class="n">ServletResponse</span> <span class="n">res</span><span class="o">,</span>
    <span class="n">FilterChain</span> <span class="n">chain</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">ServletException</span> <span class="o">{</span> <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>
<span class="o">}</span></code></pre></div>


<p><code>init</code>接口可用于启动时载入<code>routes</code>配置文件，并建立URI到action的映射。</p>

<h2>action manager</h2>

<p><code>ActionManager</code>负责启动时载入<code>routes</code>配置，建立URI到action的映射。一个URI包含了HTTP method和URI String，例如<code>GET /index</code>。action既然映射到了类接口上，那么可以在启动时就同过Java反射找到对应的类及接口。简单起见，每次收到URI的请求时，就创建这个类对应的对象，然后调用映射的接口即可。</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 例如：registerAction(&quot;com.codemacro.webdemo.test.TestController&quot;, &quot;index&quot;, &quot;/index&quot;, &quot;GET&quot;);</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">registerAction</span><span class="o">(</span><span class="n">String</span> <span class="n">clazName</span><span class="o">,</span> <span class="n">String</span> <span class="n">methodName</span><span class="o">,</span> <span class="n">String</span> <span class="n">uri</span><span class="o">,</span> <span class="n">String</span> <span class="n">method</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="n">uri</span> <span class="o">=</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">appName</span> <span class="o">+</span> <span class="n">uri</span><span class="o">;</span>
    <span class="c1">// 载入对应的class</span>
    <span class="n">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">BaseController</span><span class="o">&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="o">(</span><span class="n">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">BaseController</span><span class="o">&gt;)</span> <span class="n">loadClass</span><span class="o">(</span><span class="n">clazName</span><span class="o">);</span>
    <span class="c1">// 取得对应的接口</span>
    <span class="n">Method</span> <span class="n">m</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="n">methodName</span><span class="o">,</span> <span class="o">(</span><span class="n">Class</span><span class="o">&lt;?&gt;[])</span><span class="kc">null</span><span class="o">);</span>
    <span class="c1">// 接口要求必须返回Result</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">getReturnType</span><span class="o">()</span> <span class="o">!=</span> <span class="n">Result</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">&quot;action method return type mismatch: &quot;</span> <span class="o">+</span> <span class="n">uri</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">ActionKey</span> <span class="n">k</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ActionKey</span><span class="o">(</span><span class="n">uri</span><span class="o">,</span> <span class="n">getMethod</span><span class="o">(</span><span class="n">method</span><span class="o">));</span>
    <span class="n">ActionValue</span> <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ActionValue</span><span class="o">(</span><span class="n">clazz</span><span class="o">,</span> <span class="n">m</span><span class="o">);</span>
    <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&quot;register action {} {} {} {}&quot;</span><span class="o">,</span> <span class="n">clazName</span><span class="o">,</span> <span class="n">methodName</span><span class="o">,</span> <span class="n">uri</span><span class="o">,</span> <span class="n">method</span><span class="o">);</span>
    <span class="c1">// 建立映射</span>
    <span class="n">actions</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">&quot;registerAction failed: &quot;</span> <span class="o">+</span> <span class="n">uri</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>


<p>controller都要求派生于<code>BaseController</code>，这样才可以利用<code>BaseController</code>更方便地获取请求数据之类，例如query string/cookie 等。</p>

<p>收到请求时，就需要根据请求的HTTP Method和URI string取得之前建立的映射，并调用之：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">req</span><span class="o">,</span> <span class="n">HttpServletResponse</span> <span class="n">resp</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
  <span class="n">String</span> <span class="n">uri</span> <span class="o">=</span> <span class="n">req</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">();</span>
  <span class="n">String</span> <span class="n">method</span> <span class="o">=</span> <span class="n">req</span><span class="o">.</span><span class="na">getMethod</span><span class="o">().</span><span class="na">toUpperCase</span><span class="o">();</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="c1">// 取得之前建立的映射，Map查找</span>
    <span class="n">ActionValue</span> <span class="n">v</span> <span class="o">=</span> <span class="n">getAction</span><span class="o">(</span><span class="n">uri</span><span class="o">,</span> <span class="n">method</span><span class="o">);</span>
    <span class="c1">// 创建新的controller对象</span>
    <span class="n">BaseController</span> <span class="n">ctl</span> <span class="o">=</span> <span class="o">(</span><span class="n">BaseController</span><span class="o">)</span> <span class="n">v</span><span class="o">.</span><span class="na">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
    <span class="n">ctl</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">resp</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
    <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&quot;invoke action {}&quot;</span><span class="o">,</span> <span class="n">uri</span><span class="o">);</span>
    <span class="c1">// 调用绑定的接口</span>
    <span class="n">Result</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="n">Result</span><span class="o">)</span> <span class="n">v</span><span class="o">.</span><span class="na">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">ctl</span><span class="o">,</span> <span class="o">(</span><span class="n">Object</span><span class="o">[])</span> <span class="kc">null</span><span class="o">);</span>
    <span class="c1">// 渲染结果</span>
    <span class="n">result</span><span class="o">.</span><span class="na">render</span><span class="o">();</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>


<h2>结果渲染</h2>

<p>结果渲染无非就是把框架用户返回的结果渲染为字符串，写进<code>HttpServletResponse</code>。这个渲染过程可以是直接的<code>Object.toString</code>，或者经过模板引擎渲染，或者格式化为JSON。</p>

<p>通过实现具体的<code>Result</code>类，可以扩展不同的渲染方式，例如最基础的<code>Result</code>就是调用返回对象的<code>toString</code>：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Result</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">render</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">ServletException</span> <span class="o">{</span>
    <span class="n">PrintWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">getWriter</span><span class="o">();</span>
    <span class="c1">// result是controller action里返回的</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>


<p>为了简单，不引入第三方库，可以直接通过JSP来完成。JSP本身在servlet容器中就会被编译成一个servlet对象。</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JSPResult</span> <span class="kd">extends</span> <span class="n">Result</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">render</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">ServletException</span> <span class="o">{</span>
    <span class="c1">// 传入一些对象到模板中</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">content</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">request</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="c1">// 委托给JSP来完成渲染</span>
    <span class="n">request</span><span class="o">.</span><span class="na">getRequestDispatcher</span><span class="o">(</span><span class="n">file</span><span class="o">).</span><span class="na">forward</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>


<p>JSP中可以使用传统的scriptlets表达式，也可以使用新的EL方式，例如：</p>

<pre><code>&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%&gt;
&lt;h4&gt;By EL&lt;/h4&gt;
&lt;c:forEach var="lang" items="${langs}"&gt;
  &lt;span&gt;${lang}&lt;/span&gt;|
&lt;/c:forEach&gt;

&lt;% String[] langs = (String[]) request.getAttribute("langs"); %&gt;
&lt;% if (langs != null) { %&gt;
&lt;% for (String lang : langs) { %&gt;
  &lt;span&gt;&lt;%= lang %&gt;&lt;/span&gt;|
&lt;% } } %&gt;
</code></pre>

<p>使用EL的话需要引入<code>&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%&gt;</code></p>

<h2>BaseController</h2>

<p><code>BaseController</code>是一种template pattern实现，其包装了一些方便的接口给具体的controller使用，例如：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BaseController</span> <span class="o">{</span>
  <span class="c1">// 取得/index?name=kevin中的name参数值</span>
  <span class="kd">protected</span> <span class="n">String</span> <span class="nf">getQueryString</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">request</span><span class="o">.</span><span class="na">getParameter</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">protected</span> <span class="n">Result</span> <span class="nf">status</span><span class="o">(</span><span class="kt">int</span> <span class="n">code</span><span class="o">,</span> <span class="n">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">response</span><span class="o">.</span><span class="na">setStatus</span><span class="o">(</span><span class="n">code</span><span class="o">);</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">Result</span><span class="o">(</span><span class="n">response</span><span class="o">,</span> <span class="n">text</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="c1">// 默认是HTTP 200</span>
  <span class="kd">protected</span> <span class="n">Result</span> <span class="nf">ok</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">Result</span><span class="o">(</span><span class="n">response</span><span class="o">,</span> <span class="n">obj</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">protected</span> <span class="n">Result</span> <span class="nf">ok</span><span class="o">(</span><span class="n">Result</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">protected</span> <span class="n">JSPResult</span> <span class="nf">jsp</span><span class="o">(</span><span class="n">String</span> <span class="n">file</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">JSPResult</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">,</span> <span class="n">file</span><span class="o">,</span> <span class="n">actionMgr</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>


<h2>Reverse routing</h2>

<p>Reverse routing指的是在开发web过程中，要引入某个URL时，我们不是直接写这个URL字符串，而是写其映射的接口，以使代码更易维护（因为URL可能会随着项目进展而改变）。并且，servlet app部署后URL会带上这个app的名字前缀，例如<code>/web-demo/index</code>中的<code>/web-demo</code>。在模板文件中，例如要链接到其他URI，更好的方式当然是直接写<code>/index</code>。</p>

<p>这里的实现比较丑陋，还是基于字符串的形式，例如：</p>

<pre><code>&lt;a href='&lt;route:reverse action="com.codemacro.webdemo.test.TestController.hello" name="kevin"/&gt;'&gt;index&lt;/a&gt;
</code></pre>

<p>通过自定义一个EL function <code>reverse</code>来实现。这里需要引入一个JSP的库：</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
    &lt;version&gt;2.0&lt;/version&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>

<p>首先实现一个<code>SimpleTagSupport</code>，为了支持<code>?name=kevin</code>这种动态参数，还需要<code>implements DynamicAttributes</code>：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JSPRouteTag</span> <span class="kd">extends</span> <span class="n">SimpleTagSupport</span> <span class="kd">implements</span> <span class="n">DynamicAttributes</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="c1">// 输出最终的URL</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doTag</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="n">JspContext</span> <span class="n">context</span> <span class="o">=</span> <span class="n">getJspContext</span><span class="o">();</span>
    <span class="n">ActionManager</span> <span class="n">actionMgr</span> <span class="o">=</span> <span class="o">(</span><span class="n">ActionManager</span><span class="o">)</span> <span class="n">context</span><span class="o">.</span><span class="na">findAttribute</span><span class="o">(</span><span class="n">ACTION_MGR</span><span class="o">);</span>
    <span class="n">JspWriter</span> <span class="n">out</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getOut</span><span class="o">();</span>
    <span class="n">String</span> <span class="n">uri</span> <span class="o">=</span> <span class="n">actionMgr</span><span class="o">.</span><span class="na">getReverseAction</span><span class="o">(</span><span class="n">action</span><span class="o">,</span> <span class="n">attrMap</span><span class="o">);</span>
    <span class="n">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">uri</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="c1">// name=&quot;kevin&quot; 时调用</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDynamicAttribute</span><span class="o">(</span><span class="n">String</span> <span class="n">uri</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Object</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">JspException</span> <span class="o">{</span>
    <span class="n">attrMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="c1">// `action=&quot;xxx&quot;` 时会调用`setAction`</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAction</span><span class="o">(</span><span class="n">String</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">action</span> <span class="o">=</span> <span class="n">action</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>


<p>为了访问到<code>ActionManager</code>，这里是通过写到<code>Request context</code>中实现的，相当hack。</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">JSPResult</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">req</span><span class="o">,</span> <span class="n">HttpServletResponse</span> <span class="n">resp</span><span class="o">,</span> <span class="n">String</span> <span class="n">file</span><span class="o">,</span> 
    <span class="n">ActionManager</span> <span class="n">actionMgr</span><span class="o">)</span> <span class="o">{</span>
  <span class="kd">super</span><span class="o">(</span><span class="n">resp</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
  <span class="o">..</span>
  <span class="n">put</span><span class="o">(</span><span class="n">JSPRouteTag</span><span class="o">.</span><span class="na">ACTION_MGR</span><span class="o">,</span> <span class="n">actionMgr</span><span class="o">);</span>
<span class="o">}</span></code></pre></div>


<p>第二步增加一个描述这个新tag的文件 <code>WEB-INF/route_tag.tld</code>：</p>

<pre><code>&lt;taglib&gt;
    &lt;tlibversion&gt;1.0&lt;/tlibversion&gt;
    &lt;jspversion&gt;1.1&lt;/jspversion&gt;
    &lt;shortname&gt;URLRouteTags&lt;/shortname&gt;
    &lt;uri&gt;/myweb-router&lt;/uri&gt;
    &lt;info&gt;&lt;/info&gt;

    &lt;tag&gt;
        &lt;name&gt;reverse&lt;/name&gt;
        &lt;tagclass&gt;com.codemacro.webdemo.result.JSPRouteTag&lt;/tagclass&gt;
        &lt;bodycontent&gt;&lt;/bodycontent&gt;
        &lt;info&gt;&lt;/info&gt;
        &lt;attribute&gt;
            &lt;name&gt;action&lt;/name&gt;
            &lt;required&gt;true&lt;/required&gt;
        &lt;/attribute&gt;
        &lt;dynamic-attributes&gt;true&lt;/dynamic-attributes&gt;
    &lt;/tag&gt;
&lt;/taglib&gt;
</code></pre>

<p>最后在需要使用的JSP中引入这个自定义tag：</p>

<pre><code>&lt;%@ taglib prefix="route" uri="/myweb-router" %&gt;
</code></pre>

<h2>参考资料</h2>

<ul>
<li><a href="http://www.cnblogs.com/cuiliang/archive/2011/10/21/2220671.html">Servlet生命周期与工作原理</a></li>
<li><a href="http://www.blogjava.net/fancydeepin/archive/2013/09/30/fan_servlet.html">JSP/Servlet工作原理</a></li>
<li><a href="http://www.cnblogs.com/xushuai123/archive/2013/03/24/2979711.html">EL表达式</a></li>
<li><a href="http://www.codedata.com.tw/java/java-tutorial-the-3rd-class-3-servlet-jsp/">使用Servlet、JSP开发Web程序</a></li>
<li><a href="http://www.itzhai.com/java-web-notes-servlet-filters-in-the-filter-writing-the-introduction-and-use-of-filters.html#read-more">Java Web笔记 – Servlet中的Filter过滤器的介绍和使用 编写过滤器</a></li>
<li><a href="http://blog.csdn.net/bingduanlbd/article/details/38349737">实现一个简单的Servlet容器</a></li>
</ul>


<p class='post-footer'>
            原文地址：
            <a href='http://codemacro.com/2015/06/07/servlet-web-framework/'>http://codemacro.com/2015/06/07/servlet-web-framework/</a><br/>
            written by <a href='http://codemacro.com'>Kevin Lynx</a>
            &nbsp;posted at <a href='http://codemacro.com'>http://codemacro.com</a>
            </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中的反射及Bean容器的实现]]></title>
    <link href="http://codemacro.com/2015/05/31/java-refect-ioc/"/>
    <updated>2015-05-31T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/05/31/java-refect-ioc</id>
    <content type="html"><![CDATA[<p>编程语言中的反射(Refection)指的是可以在程序运行期动态加载一个类。与之相关的是自省(Introspection)，这个指的是程序自己可以获取一个类型的描述信息，例如获取一个类的所有接口定义、一个接口的所有形参。当编程语言有了这些语言特性之后，可以在很大程度上解决代码耦合问题，所以在Java的世界里，可以看到很多库/框架使用了反射技术。</p>

<p>类似Spring的Bean容器实现就是大量运用了反射机制。Bean容器维护了一些Bean对象，简单来说就是一些普通对象。Bean容器可以根据配置创建这些对象，创建时如果这些对象依赖了其他对象，Bean容器还会负责将依赖的对象注入到目标对象中，也就是所谓的依赖注入(dependence injection)。放在模块设计中，又衍生出控制反转(IoC, Inverse of Control)概念，用于描述应用程序在使用一个框架时，不是框架来控制/限制应用程序的架构模式，而是由应用程序来控制框架。</p>

<p>本文就简单描述下Bean容器是如何使用反射来实现的，最终代码参考<a href="https://github.com/kevinlynx/ioc-sample">github ioc-sample</a></p>

<h2>类的动态加载</h2>

<p>可以简单地使用<code>Class.forName</code>，传入某个class的完整名：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">loadClass</span><span class="o">(</span><span class="n">String</span> <span class="n">fullName</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">fullName</span><span class="o">);</span>
<span class="o">}</span></code></pre></div>


<p>类的加载涉及到class loader，这块内容是可以进一步深化的。加载了类之后就可以创建出类的实例，但还没有完成依赖注入的功能：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">loadClass</span><span class="o">(</span><span class="s">&quot;com.codemacro.bean.test.Test1&quot;</span><span class="o">);</span>
<span class="n">Object</span> <span class="n">o</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span></code></pre></div>




<!-- more -->


<h2>通过set接口注入</h2>

<p>我们的类可以包含<code>set</code>接口，用于设置某个成员：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test2</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">Test1</span> <span class="n">test1</span><span class="o">;</span>
  
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setTest1</span><span class="o">(</span><span class="n">Test1</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">test1</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>


<p>那么可以通过<code>setXXX</code>接口将<code>Test1</code>注入到<code>Test2</code>中：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// props指定哪些成员需要注入，例如{&quot;Test1&quot;, &quot;test1&quot;}，Test1指的是setTest1，test1指的是bean名字</span>
<span class="kd">public</span> <span class="n">Object</span> <span class="nf">buildWithSetters</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">c</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">props</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="c1">// ClassSetMethods 类获取Class&lt;?&gt;中所有setXX这种接口</span>
    <span class="n">ClassSetMethods</span> <span class="n">setMethods</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ClassSetMethods</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
    <span class="n">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">entrys</span> <span class="o">:</span> <span class="n">props</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">String</span> <span class="n">pname</span> <span class="o">=</span> <span class="n">entrys</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
      <span class="n">String</span> <span class="n">beanName</span> <span class="o">=</span> <span class="n">entrys</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
      <span class="c1">// 取得setXXX这个Method</span>
      <span class="n">Method</span> <span class="n">m</span> <span class="o">=</span> <span class="n">setMethods</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pname</span><span class="o">);</span>
      <span class="n">Object</span> <span class="n">val</span> <span class="o">=</span> <span class="n">getBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
      <span class="c1">// 调用</span>
      <span class="n">m</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">obj</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">beans</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">obj</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">&quot;build bean failed&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>


<p><code>ClassSetMethod</code>自省出一个Class中所有的<code>setXXX(xx)</code>接口：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">ClassSetMethods</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">Method</span><span class="o">[]</span> <span class="n">methods</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">getMethods</span><span class="o">();</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">Method</span> <span class="n">m</span> <span class="o">:</span> <span class="n">methods</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">mname</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
    <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">ptypes</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">getParameterTypes</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mname</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">&quot;set&quot;</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">ptypes</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">m</span><span class="o">.</span><span class="na">getReturnType</span><span class="o">()</span> <span class="o">==</span> <span class="n">Void</span><span class="o">.</span><span class="na">TYPE</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">mname</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="s">&quot;set&quot;</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
      <span class="k">this</span><span class="o">.</span><span class="na">methods</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">m</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>


<p>以上就可以看出Java中的自省能力，例如<code>Class&lt;?&gt;.getMethods</code>、<code>Method.getReturnType</code>、<code>Method.getParameterTypes</code>。</p>

<h2>通过构造函数注入</h2>

<p>类似于Spring中的：</p>

<pre><code>&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
  &lt;constructor-arg type="int" value="2001"/&gt;
  &lt;constructor-arg type="java.lang.String" value="Zara"/&gt;
</code></pre>

<p>   </bean></p>

<p>可以将依赖的Bean通过构造函数参数注入到目标对象中：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">params</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
<span class="n">params</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;test1&quot;</span><span class="o">);</span>
<span class="n">bf</span><span class="o">.</span><span class="na">buildWithConstructor</span><span class="o">(</span><span class="s">&quot;test2&quot;</span><span class="o">,</span> <span class="n">Test2</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">params</span><span class="o">);</span></code></pre></div>


<p>其实现：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">Object</span> <span class="nf">buildWithConstructor</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">c</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">beanNames</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="n">Constructor</span><span class="o">&lt;?&gt;[]</span> <span class="n">ctors</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">getConstructors</span><span class="o">();</span> <span class="c1">// 取得Class构造函数列表</span>
    <span class="k">assert</span> <span class="n">ctors</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">;</span>
    <span class="n">Constructor</span><span class="o">&lt;?&gt;</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">ctors</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> 
    <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">ptypes</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="na">getParameterTypes</span><span class="o">();</span> <span class="c1">// 取得构造函数参数类型列表</span>
    <span class="k">assert</span> <span class="n">ptypes</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">beans</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="n">ptypes</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">beanNames</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span> 
      <span class="n">args</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">getBean</span><span class="o">(</span><span class="n">beanNames</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span> <span class="c1">// 构造调用构造函数的实参列表</span>
    <span class="o">}</span>
    <span class="n">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">args</span><span class="o">);</span> <span class="c1">// 通过构造函数创建对象</span>
    <span class="n">beans</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">obj</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">&quot;build bean failed&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>


<p>这个接口的使用约定<code>beanNames</code>保存的是bean名称，并与构造函数参数一一对应。</p>

<h2>通过注解注入</h2>

<p>我们可以通过注解标注某个数据成员是需要被自动注入的。我这里简单地获取注解标注的成员类型，找到该类型对应的Bean作为注入对象。当然复杂点还可以指定要注入Bean的名字，或自动查找类型的派生类实现。</p>

<p>一个空的注解即可：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Retention</span><span class="o">(</span><span class="n">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Target</span><span class="o">(</span><span class="n">ElementType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">Inject</span> <span class="o">{</span>
<span class="o">}</span></code></pre></div>


<p>实现：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">Object</span> <span class="nf">buildWithInject</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="n">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
    <span class="n">Field</span><span class="o">[]</span> <span class="n">fields</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">getDeclaredFields</span><span class="o">();</span> <span class="c1">// 获取该类所有定义的成员</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Field</span> <span class="n">f</span> <span class="o">:</span><span class="n">fields</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">Inject</span> <span class="n">inject</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">Inject</span><span class="o">.</span><span class="na">class</span><span class="o">);</span> <span class="c1">// 获取数据成员的注解</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">inject</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 如果被Inject注解标注</span>
        <span class="n">Object</span> <span class="n">bean</span> <span class="o">=</span> <span class="n">getBeanByType</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">getType</span><span class="o">());</span> <span class="c1">// 根据成员的类型找到对应的Bean</span>
        <span class="n">f</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">obj</span><span class="o">,</span> <span class="n">bean</span><span class="o">);</span> <span class="c1">// 注入</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">&quot;not found bean &quot;</span> <span class="o">+</span> <span class="n">f</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">beans</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">obj</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">&quot;build bean failed&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>


<p><code>getBeanByType</code>就是根据<code>Class</code>匹配所有的Bean。使用时：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test2</span> <span class="o">{</span>
  <span class="nd">@Inject</span>
  <span class="kd">public</span> <span class="n">Test1</span> <span class="n">test1</span><span class="o">;</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></div>


<p>完。</p>

<p class='post-footer'>
            原文地址：
            <a href='http://codemacro.com/2015/05/31/java-refect-ioc/'>http://codemacro.com/2015/05/31/java-refect-ioc/</a><br/>
            written by <a href='http://codemacro.com'>Kevin Lynx</a>
            &nbsp;posted at <a href='http://codemacro.com'>http://codemacro.com</a>
            </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Drill中实现HTTP storage plugin]]></title>
    <link href="http://codemacro.com/2015/05/30/drill-http-plugin/"/>
    <updated>2015-05-30T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/05/30/drill-http-plugin</id>
    <content type="html"><![CDATA[<p>Apache Drill可用于大数据的实时分析，引用一段介绍：</p>

<blockquote><p>受到Google Dremel启发，Apache的Drill项目是对大数据集进行交互式分析的分布式系统。Drill并不会试图取代已有的大数据批处理框架（Big Data batch processing framework），如Hadoop MapReduce或流处理框架（stream processing framework），如S4和Storm。相反，它是要填充现有空白的——对大数据集的实时交互式处理</p></blockquote>

<p>简单来说，Drill可接收SQL查询语句，然后后端从多个数据源例如HDFS、MongoDB等获取数据并分析产出分析结果。在一次分析中，它可以汇集多个数据源的数据。而且基于分布式的架构，可以支持秒级查询。</p>

<p>Drill在架构上是比较灵活的，它的前端可以不一定是SQL查询语言，后端数据源也可以接入Storage plugin来支持其他数据来源。这里我就实现了一个从HTTP服务获取数据的Storage plugin demo。这个demo可以接入基于GET请求，返回JSON格式的HTTP服务。源码可从我的Github获取：<a href="https://github.com/kevinlynx/drill-storage-http">drill-storage-http</a></p>

<p>例子包括：</p>

<pre><code>select name, length from http.`/e/api:search` where $p=2 and $q='avi'
select name, length from http.`/e/api:search?q=avi&amp;p=2` where length &gt; 0 
</code></pre>

<h2>实现</h2>

<p>要实现一个自己的storage plugin，目前Drill这方面文档几乎没有，只能从已有的其他storage plugin源码入手，例如mongodb的，参考Drill子项目<code>drill-mongo-storage</code>。实现的storage plugin打包为jar放到<code>jars</code>目录，Drill启动时会自动载入，然后web上配置指定类型即可。</p>

<p>主要需要实现的类包括：</p>

<pre><code>AbstractStoragePlugin
StoragePluginConfig
SchemaFactory
BatchCreator
AbstractRecordReader
AbstractGroupScan
</code></pre>

<!-- more -->


<h3>AbstraceStoragePlugin</h3>

<p><code>StoragePluginConfig</code>用于配置plugin，例如：</p>

<pre><code>{
  "type" : "http",
  "connection" : "http://xxx.com:8000",
  "resultKey" : "results",
  "enabled" : true
}
</code></pre>

<p>它必须是可JSON序列化/反序列化的，Drill会把storage配置存储到<code>/tmp/drill/sys.storage_plugins</code>中，例如windows下<code>D:\tmp\drill\sys.storage_plugins</code>。</p>

<p><code>AbstractStoragePlugin</code> 是plugin的主类，它必须配合<code>StoragePluginConfig</code>，实现这个类时，构造函数必须遵循参数约定，例如：</p>

<pre><code>public HttpStoragePlugin(HttpStoragePluginConfig httpConfig, DrillbitContext context, String name)
</code></pre>

<p>Drill启动时会自动扫描<code>AbstractStoragePlugin</code>实现类(<code>StoragePluginRegistry</code>)，并建立<code>StoragePluginConfig.class</code>到<code>AbstractStoragePlugin constructor</code>的映射。<code>AbstractStoragePlugin</code>需要实现的接口包括：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 相应地需要实现AbstraceGroupScan</span>
    <span class="c1">// selection包含了database name和table name，可用可不用</span>
    <span class="kd">public</span> <span class="n">AbstractGroupScan</span> <span class="nf">getPhysicalScan</span><span class="o">(</span><span class="n">String</span> <span class="n">userName</span><span class="o">,</span> <span class="n">JSONOptions</span> <span class="n">selection</span><span class="o">)</span> 

    <span class="c1">// 注册schema</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">registerSchemas</span><span class="o">(</span><span class="n">SchemaConfig</span> <span class="n">schemaConfig</span><span class="o">,</span> <span class="n">SchemaPlus</span> <span class="n">parent</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span>

    <span class="c1">// StoragePluginOptimizerRule 用于优化Drill生成的plan，可实现也可不实现</span>
    <span class="kd">public</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">StoragePluginOptimizerRule</span><span class="o">&gt;</span> <span class="nf">getOptimizerRules</span><span class="o">()</span></code></pre></div>


<p>Drill中的schema用于描述一个database，以及处理table之类的事务，必须要实现，否则任意一个SQL查询都会被认为是找不到对应的table。<code>AbstraceGroupScan</code>用于一次查询中提供信息，例如查询哪些columns。</p>

<p>Drill在查询时，有一种中间数据结构(基于JSON)叫Plan，其中又分为Logic Plan和Physical Plan。Logic Plan是第一层中间结构，用于完整表达一次查询，是SQL或其他前端查询语言转换后的中间结构。完了后还要被转换为Physical Plan，又称为Exectuion Plan，这个Plan是被优化后的Plan，可用于与数据源交互进行真正的查询。<code>StoragePluginOptimizerRule</code>就是用于优化Physical Plan的。这些Plan最终对应的结构有点类似于语法树，毕竟SQL也可以被认为是一种程序语言。<code>StoragePluginOptimizerRule</code>可以被理解为改写这些语法树的。例如Mongo storage plugin就实现了这个类，它会把<code>where</code>中的filter转换为mongodb自己的filter(如{&lsquo;$gt&rsquo;: 2})，从而优化查询。</p>

<p>这里又牵扯出Apache的另一个项目：<a href="https://github.com/apache/incubator-calcite">calcite</a>，前身就是OptiQ。Drill中整个关于SQL的执行，主要是依靠这个项目。要玩转Plan的优化是比较难的，也是因为文档欠缺，相关代码较多。</p>

<h3>SchemaFactory</h3>

<p><code>registerSchemas</code>主要还是调用<code>SchemaFactory.registerSchemas</code>接口。Drill中的Schema是一种树状结构，所以可以看到<code>registerSchemas</code>实际就是往parent中添加child：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">registerSchemas</span><span class="o">(</span><span class="n">SchemaConfig</span> <span class="n">schemaConfig</span><span class="o">,</span> <span class="n">SchemaPlus</span> <span class="n">parent</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">HttpSchema</span> <span class="n">schema</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">HttpSchema</span><span class="o">(</span><span class="n">schemaName</span><span class="o">);</span>
        <span class="n">parent</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">schema</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">schema</span><span class="o">);</span>
    <span class="o">}</span></code></pre></div>


<p><code>HttpSchema</code>派生于<code>AbstractSchema</code>，主要需要实现接口<code>getTable</code>，因为我这个http storage plugin中的table实际就是传给HTTP service的query，所以table是动态的，所以<code>getTable</code>的实现比较简单：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">Table</span> <span class="nf">getTable</span><span class="o">(</span><span class="n">String</span> <span class="n">tableName</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// table name can be any of string</span>
        <span class="n">HttpScanSpec</span> <span class="n">spec</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">HttpScanSpec</span><span class="o">(</span><span class="n">tableName</span><span class="o">);</span> <span class="c1">// will be pass to getPhysicalScan</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">DynamicDrillTable</span><span class="o">(</span><span class="n">plugin</span><span class="o">,</span> <span class="n">schemaName</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">spec</span><span class="o">);</span>
    <span class="o">}</span></code></pre></div>


<p>这里的<code>HttpScanSpec</code>用于保存查询中的一些参数，例如这里保存了table name，也就是HTTP service的query，例如<code>/e/api:search?q=avi&amp;p=2</code>。它会被传到<code>AbstraceStoragePlugin.getPhysicalScan</code>中的<code>JSONOptions</code>：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">AbstractGroupScan</span> <span class="nf">getPhysicalScan</span><span class="o">(</span><span class="n">String</span> <span class="n">userName</span><span class="o">,</span> <span class="n">JSONOptions</span> <span class="n">selection</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">HttpScanSpec</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">selection</span><span class="o">.</span><span class="na">getListWith</span><span class="o">(</span><span class="k">new</span> <span class="nf">ObjectMapper</span><span class="o">(),</span> <span class="k">new</span> <span class="n">TypeReference</span><span class="o">&lt;</span><span class="n">HttpScanSpec</span><span class="o">&gt;()</span> <span class="o">{});</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">HttpGroupScan</span><span class="o">(</span><span class="n">userName</span><span class="o">,</span> <span class="n">httpConfig</span><span class="o">,</span> <span class="n">spec</span><span class="o">);</span>
    <span class="o">}</span></code></pre></div>


<p><code>HttpGroupScan</code>后面会看到用处。</p>

<h3>AbstractRecordReader</h3>

<p><code>AbstractRecordReader</code>负责真正地读取数据并返回给Drill。<code>BatchCreator</code>则是用于创建<code>AbstractRecordReader</code>。</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HttpScanBatchCreator</span> <span class="kd">implements</span> <span class="n">BatchCreator</span><span class="o">&lt;</span><span class="n">HttpSubScan</span><span class="o">&gt;</span> <span class="o">{</span>

      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="n">CloseableRecordBatch</span> <span class="nf">getBatch</span><span class="o">(</span><span class="n">FragmentContext</span> <span class="n">context</span><span class="o">,</span>
          <span class="n">HttpSubScan</span> <span class="n">config</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">RecordBatch</span><span class="o">&gt;</span> <span class="n">children</span><span class="o">)</span>
          <span class="kd">throws</span> <span class="n">ExecutionSetupException</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">RecordReader</span><span class="o">&gt;</span> <span class="n">readers</span> <span class="o">=</span> <span class="n">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">();</span>
        <span class="n">readers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nf">HttpRecordReader</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">config</span><span class="o">));</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ScanBatch</span><span class="o">(</span><span class="n">config</span><span class="o">,</span> <span class="n">context</span><span class="o">,</span> <span class="n">readers</span><span class="o">.</span><span class="na">iterator</span><span class="o">());</span>
      <span class="o">}</span>
    <span class="o">}</span></code></pre></div>


<p>既然<code>AbstractRecordReader</code>负责真正读取数据，那么它肯定是需要知道传给HTTP service的query的，但这个query最早是在<code>HttpScanSpec</code>中，然后传给了<code>HttpGroupScan</code>，所以马上会看到<code>HttpGroupScan</code>又把参数信息传给了<code>HttpSubScan</code>。</p>

<p>Drill也会自动扫描<code>BatchCreator</code>的实现类，所以这里就不用关心<code>HttpScanBatchCreator</code>的来历了。</p>

<p><code>HttpSubScan</code>的实现比较简单，主要是用来存储<code>HttpScanSpec</code>的：</p>

<pre><code>public class HttpSubScan extends AbstractBase implements SubScan // 需要实现SubScan
</code></pre>

<p>回到<code>HttpGroupScan</code>，必须实现的接口：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">SubScan</span> <span class="nf">getSpecificScan</span><span class="o">(</span><span class="kt">int</span> <span class="n">minorFragmentId</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// pass to HttpScanBatchCreator</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">HttpSubScan</span><span class="o">(</span><span class="n">config</span><span class="o">,</span> <span class="n">scanSpec</span><span class="o">);</span> <span class="c1">// 最终会被传递到HttpScanBatchCreator.getBatch接口</span>
      <span class="o">}</span></code></pre></div>


<p>最终query被传递到<code>HttpRecordReader</code>，该类需要实现的接口包括：<code>setup</code>和<code>next</code>，有点类似于迭代器。<code>setup</code>中查询出数据，然后<code>next</code>中转换数据给Drill。转换给Drill时可以使用到<code>VectorContainerWriter</code>和<code>JsonReader</code>。这里也就是Drill中传说的vector数据格式，也就是列存储数据。</p>

<h3>总结</h3>

<p>以上，就包含了plugin本身的创建，及查询中query的传递。查询中类似<code>select titile, name</code> 中的columns会被传递到<code>HttpGroupScan.clone</code>接口，只不过我这里并不关注。实现了这些，就可以通过Drill查询HTTP service中的数据了。</p>

<p>而<code>select * from xx where xx</code>中的<code>where</code> filter，Drill自己会对查询出来的数据做过滤。如果要像mongo plugin中构造mongodb的filter，则需要实现<code>StoragePluginOptimizerRule</code>。</p>

<p>我这里实现的HTTP storage plugin，本意是觉得传给HTTP service的query可能会动态构建，例如：</p>

<pre><code>select name, length from http.`/e/api:search` where $p=2 and $q='avi' # p=2&amp;q=avi 就是动态构建，其值可以来源于其他查询结果
select name, length from http.`/e/api:search?q=avi&amp;p=2` where length &gt; 0  # 这里就是静态的
</code></pre>

<p>第一条查询就需要借助<code>StoragePluginOptimizerRule</code>，它会收集所有where中的filter，最终作为HTTP serivce的query。但这里的实现还不完善。</p>

<p>总体而言，由于Drill项目相对较新，要进行扩展还是比较困难的。尤其是Plan优化部分。</p>

<p class='post-footer'>
            原文地址：
            <a href='http://codemacro.com/2015/05/30/drill-http-plugin/'>http://codemacro.com/2015/05/30/drill-http-plugin/</a><br/>
            written by <a href='http://codemacro.com'>Kevin Lynx</a>
            &nbsp;posted at <a href='http://codemacro.com'>http://codemacro.com</a>
            </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[无锁有序链表的实现]]></title>
    <link href="http://codemacro.com/2015/05/05/lock_free_list/"/>
    <updated>2015-05-05T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/05/05/lock_free_list</id>
    <content type="html"><![CDATA[<p>无锁有序链表可以保证元素的唯一性，使其可用于哈希表的桶，甚至直接作为一个效率不那么高的map。普通链表的无锁实现相对简单点，因为插入元素可以在表头插，而有序链表的插入则是任意位置。</p>

<p>本文主要基于论文<a href="http://www.research.ibm.com/people/m/michael/spaa-2002.pdf">High Performance Dynamic Lock-Free Hash Tables</a>实现。</p>

<h2>主要问题</h2>

<p>链表的主要操作包含<code>insert</code>和<code>remove</code>，先简单实现一个版本，就会看到问题所在，以下代码只用作示例：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="kt">node_t</span> <span class="p">{</span>
        <span class="kt">key_t</span> <span class="n">key</span><span class="p">;</span>
        <span class="kt">value_t</span> <span class="n">val</span><span class="p">;</span>
        <span class="kt">node_t</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="kt">int</span> <span class="nf">l_find</span><span class="p">(</span><span class="kt">node_t</span> <span class="o">**</span><span class="n">pred_ptr</span><span class="p">,</span> <span class="kt">node_t</span> <span class="o">**</span><span class="n">item_ptr</span><span class="p">,</span> <span class="kt">node_t</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">key_t</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">node_t</span> <span class="o">*</span><span class="n">pred</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="kt">node_t</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">KEY_CMP</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">pred_ptr</span> <span class="o">=</span> <span class="n">pred</span><span class="p">;</span>
                <span class="o">*</span><span class="n">item_ptr</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="nl">TRUE</span> <span class="p">:</span> <span class="n">FALSE</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span> 
        <span class="o">*</span><span class="n">pred_ptr</span> <span class="o">=</span> <span class="n">pred</span><span class="p">;</span>
        <span class="o">*</span><span class="n">item_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">l_insert</span><span class="p">(</span><span class="kt">node_t</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">value_t</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">node_t</span> <span class="o">*</span><span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="o">*</span><span class="n">new_item</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">l_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pred</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">new_item</span> <span class="o">=</span> <span class="p">(</span><span class="kt">node_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">node_t</span><span class="p">));</span>
            <span class="n">new_item</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
            <span class="n">new_item</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
            <span class="n">new_item</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
            <span class="c1">// A. 如果pred本身被移除了</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">CAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">new_item</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">free</span><span class="p">(</span><span class="n">new_item</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">l_remove</span><span class="p">(</span><span class="kt">node_t</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">key_t</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">node_t</span> <span class="o">*</span><span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pred</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// B. 如果pred被移除；如果item也被移除</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">CAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">haz_free</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre></div>




<!-- more -->


<p><code>l_find</code>函数返回查找到的前序元素和元素本身，代码A和B虽然拿到了<code>pred</code>和<code>item</code>，但在<code>CAS</code>的时候，其可能被其他线程移除。甚至，在<code>l_find</code>过程中，其每一个元素都可能被移除。问题在于，<strong>任何时候拿到一个元素时，都不确定其是否还有效</strong>。元素的有效性包括其是否还在链表中，其指向的内存是否还有效。</p>

<h2>解决方案</h2>

<p><strong>通过为元素指针增加一个有效性标志位，配合CAS操作的互斥性</strong>，就可以解决元素有效性判定问题。</p>

<p>因为<code>node_t</code>放在内存中是会对齐的，所以指向<code>node_t</code>的指针值低几位是不会用到的，从而可以在低几位里设置标志，这样在做CAS的时候，就实现了DCAS的效果，相当于将两个逻辑上的操作变成了一个原子操作。想象下引用计数对象的线程安全性，其内包装的指针是线程安全的，但对象本身不是。</p>

<p>CAS的互斥性，在若干个线程CAS相同的对象时，只有一个线程会成功，失败的线程就可以以此判定目标对象发生了变更。改进后的代码（代码仅做示例用，不保证正确）：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">typedef</span> <span class="kt">size_t</span> <span class="kt">markable_t</span><span class="p">;</span>
    <span class="c1">// 最低位置1，表示元素被删除</span>
    <span class="cp">#define HAS_MARK(p) ((markable_t)p &amp; 0x01)</span>
    <span class="cp">#define MARK(p) ((markable_t)p | 0x01)</span>
    <span class="cp">#define STRIP_MARK(p) ((markable_t)p &amp; ~0x01)</span>

    <span class="kt">int</span> <span class="nf">l_insert</span><span class="p">(</span><span class="kt">node_t</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">value_t</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">node_t</span> <span class="o">*</span><span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="o">*</span><span class="n">new_item</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">l_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pred</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="p">{</span> 
                <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">new_item</span> <span class="o">=</span> <span class="p">(</span><span class="kt">node_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">node_t</span><span class="p">));</span>
            <span class="n">new_item</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
            <span class="n">new_item</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
            <span class="n">new_item</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
            <span class="c1">// A. 虽然find拿到了合法的pred，但是在以下代码之前pred可能被删除，此时pred-&gt;next被标记</span>
            <span class="c1">//    pred-&gt;next != item，该CAS会失败，失败后重试</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">CAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">new_item</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">free</span><span class="p">(</span><span class="n">new_item</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">l_remove</span><span class="p">(</span><span class="kt">node_t</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">key_t</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">node_t</span> <span class="o">*</span><span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pred</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="kt">node_t</span> <span class="o">*</span><span class="n">inext</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="c1">// B. 删除item前先标记item-&gt;next，如果CAS失败，那么情况同insert一样，有其他线程在find之后</span>
            <span class="c1">//    删除了item，失败后重试</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">inext</span><span class="p">,</span> <span class="n">MARK</span><span class="p">(</span><span class="n">inext</span><span class="p">)))</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// C. 对同一个元素item删除时，只会有一个线程成功走到这里</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">CAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">STRIP_MARK</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)))</span> <span class="p">{</span>
                <span class="n">haz_defer_free</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">l_find</span><span class="p">(</span><span class="kt">node_t</span> <span class="o">**</span><span class="n">pred_ptr</span><span class="p">,</span> <span class="kt">node_t</span> <span class="o">**</span><span class="n">item_ptr</span><span class="p">,</span> <span class="kt">node_t</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">key_t</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">node_t</span> <span class="o">*</span><span class="n">pred</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="kt">node_t</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="kt">hazard_t</span> <span class="o">*</span><span class="n">hp1</span> <span class="o">=</span> <span class="n">haz_get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="kt">hazard_t</span> <span class="o">*</span><span class="n">hp2</span> <span class="o">=</span> <span class="n">haz_get</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">haz_set_ptr</span><span class="p">(</span><span class="n">hp1</span><span class="p">,</span> <span class="n">pred</span><span class="p">);</span>
            <span class="n">haz_set_ptr</span><span class="p">(</span><span class="n">hp2</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
            <span class="cm">/* </span>
<span class="cm">             如果已被标记，那么紧接着item可能被移除链表甚至释放，所以需要重头查找</span>
<span class="cm">            */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">HAS_MARK</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">))</span> <span class="p">{</span> 
                <span class="k">return</span> <span class="n">l_find</span><span class="p">(</span><span class="n">pred_ptr</span><span class="p">,</span> <span class="n">item_ptr</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">KEY_CMP</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">pred_ptr</span> <span class="o">=</span> <span class="n">pred</span><span class="p">;</span>
                <span class="o">*</span><span class="n">item_ptr</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="nl">TRUE</span> <span class="p">:</span> <span class="n">FALSE</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span> 
        <span class="o">*</span><span class="n">pred_ptr</span> <span class="o">=</span> <span class="n">pred</span><span class="p">;</span>
        <span class="o">*</span><span class="n">item_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span></code></pre></div>


<p><code>haz_get</code>、<code>haz_set_ptr</code>之类的函数是一个hazard pointer实现，用于支持多线程下内存的GC。上面的代码中，要删除一个元素<code>item</code>时，会标记<code>item-&gt;next</code>，从而使得<code>insert</code>时中那个<code>CAS</code>不需要做任何调整。总结下这里的线程竞争情况：</p>

<ul>
<li><code>insert</code>中<code>find</code>到正常的<code>pred</code>及<code>item</code>，<code>pred-&gt;next == item</code>，然后在<code>CAS</code>前有线程删除了<code>pred</code>，此时<code>pred-&gt;next == MARK(item)</code>，<code>CAS</code>失败，重试；删除分为2种情况：a) 从链表移除，得到标记，<code>pred</code>可继续访问；b) <code>pred</code>可能被释放内存，此时再使用<code>pred</code>会错误。为了处理情况b，所以引入了类似hazard pointer的机制，可以有效保障任意一个指针<code>p</code>只要还有线程在使用它，它的内存就不会被真正释放</li>
<li><code>insert</code>中有多个线程在<code>pred</code>后插入元素，此时同样由<code>insert</code>中的<code>CAS</code>保证，这个不多说</li>
<li><code>remove</code>中情况同<code>insert</code>，<code>find</code>拿到了有效的<code>pred</code>和<code>next</code>，但在<code>CAS</code>的时候<code>pred</code>被其他线程删除，此时情况同<code>insert</code>，<code>CAS</code>失败，重试</li>
<li>任何时候改变链表结构时，无论是<code>remove</code>还是<code>insert</code>，都需要重试该操作</li>
<li><code>find</code>中遍历时，可能会遇到被标记删除的<code>item</code>，此时<code>item</code>根据<code>remove</code>的实现很可能被删除，所以需要重头开始遍历</li>
</ul>


<h2>ABA问题</h2>

<p>ABA问题还是存在的，<code>insert</code>中：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">if</span> <span class="p">(</span><span class="n">CAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">new_item</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="p">}</span></code></pre></div>


<p>如果<code>CAS</code>之前，<code>pred</code>后的<code>item</code>被移除，又以相同的地址值加进来，但其value变了，此时<code>CAS</code>会成功，但链表可能就不是有序的了。<code>pred-&gt;val &lt; new_item-&gt;val &gt; item-&gt;val</code></p>

<p>为了解决这个问题，可以利用指针值地址对齐的其他位来存储一个计数，用于表示<code>pred-&gt;next</code>的改变次数。当<code>insert</code>拿到<code>pred</code>时，<code>pred-&gt;next</code>中存储的计数假设是0，<code>CAS</code>之前其他线程移除了<code>pred-&gt;next</code>又新增回了<code>item</code>，此时<code>pred-&gt;next</code>中的计数增加，从而导致<code>insert</code>中<code>CAS</code>失败。</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// 最低位留作删除标志</span>
    <span class="cp">#define MASK ((sizeof(node_t) - 1) &amp; ~0x01)</span>

    <span class="cp">#define GET_TAG(p) ((markable_t)p &amp; MASK)</span>
    <span class="cp">#define TAG(p, tag) ((markable_t)p | (tag))</span>
    <span class="cp">#define MARK(p) ((markable_t)p | 0x01)</span>
    <span class="cp">#define HAS_MARK(p) ((markable_t)p &amp; 0x01)</span>
    <span class="cp">#define STRIP_MARK(p) ((node_t*)((markable_t)p &amp; ~(MASK | 0x01)))</span></code></pre></div>


<p><code>remove</code>的实现：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cm">/* 先标记再删除 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitem</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">inext</span><span class="p">,</span> <span class="n">MARK</span><span class="p">(</span><span class="n">inext</span><span class="p">)))</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">GET_TAG</span><span class="p">(</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">TAG</span><span class="p">(</span><span class="n">STRIP_MARK</span><span class="p">(</span><span class="n">sitem</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">),</span> <span class="n">tag</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">haz_defer_free</span><span class="p">(</span><span class="n">sitem</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="p">}</span></code></pre></div>


<p><code>insert</code>中也可以更新<code>pred-&gt;next</code>的计数。</p>

<h2>总结</h2>

<p>无锁的实现，本质上都会依赖于<code>CAS</code>的互斥性。从头实现一个lock free的数据结构，可以深刻感受到lock free实现的tricky。最终代码可以从<a href="https://github.com/kevinlynx/lockfree-list">这里github</a>获取。代码中为了简单，实现了一个不是很强大的hazard pointer，可以<a href="http://codemacro.com/2015/05/03/hazard-pointer/">参考之前的博文</a>。</p>

<p class='post-footer'>
            原文地址：
            <a href='http://codemacro.com/2015/05/05/lock_free_list/'>http://codemacro.com/2015/05/05/lock_free_list/</a><br/>
            written by <a href='http://codemacro.com'>Kevin Lynx</a>
            &nbsp;posted at <a href='http://codemacro.com'>http://codemacro.com</a>
            </p>

]]></content>
  </entry>
  
</feed>
