<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 堆栈 | loop in codes]]></title>
  <link href="http://codemacro.com/tags/堆栈/atom.xml" rel="self"/>
  <link href="http://codemacro.com/"/>
  <updated>2014-02-02T13:51:31+08:00</updated>
  <id>http://codemacro.com/</id>
  <author>
    <name><![CDATA[Kevin Lynx]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[记一次堆栈平衡错误]]></title>
    <link href="http://codemacro.com/2013/08/15/debug-esp-bug/"/>
    <updated>2013-08-15T00:00:00+08:00</updated>
    <id>http://codemacro.com/2013/08/15/debug-esp-bug</id>
    <content type="html"><![CDATA[<p>最近在一个使用Visual Studio开发的C++程序中，出现了如下错误：</p>

<blockquote><p>Run-Time Check Failure #0 - The value of ESP was not properly saved across a function call.  This is usually a result of calling a function declared with one calling convention with a function pointer declared with a different calling convention.</p></blockquote>

<p>这个错误主要指的就是函数调用堆栈不平衡。在C/C++程序中，调用一个函数前会保存当前堆栈信息，目标函数返回后会把堆栈恢复到调用前的状态。函数的参数、局部变量会影响堆栈。而函数堆栈不平衡，一般是因为函数调用方式和目标函数定义方式不一致导致，例如：</p>

<p><div class="highlight"><pre><code class="c"><span class="kt">void</span> <span class="kr">__stdcall</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">funcptr</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
<span class="n">funcptr</span> <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">funcptr</span><span class="p">)</span> <span class="n">func</span><span class="p">;</span>
<span class="n">ptr</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 返回后导致堆栈不平衡</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</code></pre>
</div></p>

<p><code>__stdcall</code>修饰的函数，其函数参数的出栈由被调用者自己完成，而<code>__cdecl</code>，也就是C/C++函数的默认调用约定，则是调用者完成参数出栈。</p>

<!-- more -->


<p>Visual Studio在debug模式下会在我们的代码中加入不少检查代码，例如以上代码对应的汇编中，就会增加一个检查堆栈是否平衡的函数调用，当出现问题时，就会出现提示<code>Run-Time Check Failure...</code>这样的错误对话框：</p>

<pre><code>call dword ptr [ptr]  ; ptr(1)
add  esp,4  ; cdecl方式，调用者清除参数
cmp  esi,esp  
call @ILT+1345(__RTC_CheckEsp) (0B01546h) ; 检查堆栈是否平衡
</code></pre>

<p>但是我们的程序不是这种低级错误。我们调用的函数是放在dll中的，调用约定显示定义为<code>__stdcall</code>，函数声明和实现一致。大致的结构如下：</p>

<p><div class="highlight"><pre><code class="c"><span class="n">IParser</span> <span class="o">*</span><span class="n">parser</span> <span class="o">=</span> <span class="n">CreateParser</span><span class="p">();</span>
<span class="n">parser</span><span class="o">-&gt;</span><span class="n">Begin</span><span class="p">();</span>
<span class="p">...</span>
<span class="p">...</span>
<span class="n">parser</span><span class="o">-&gt;</span><span class="n">End</span><span class="p">();</span>
<span class="n">parser</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span> <span class="c1">// 返回后导致堆栈不平衡</span>
</code></pre>
</div></p>

<p>IParser的实现在一个dll里，这反而是一个误导人的信息。<code>parser-&gt;Release</code>返回后，堆栈不平衡，<strong>并且仅仅少了一个字节</strong>。一个字节怎么来的？</p>

<p>解决这个问题主要的手段就是跟反汇编，在关键位置查看寄存器和堆栈的内容。编译器生成的代码是正确的，而我们自己的代码乍看上去也没问题。最后甚至使用最傻逼的调试手段--逐行语句注释查错。</p>

<p>具体查错过程就不细说了。解决问题往往需要更多的冷静，和清晰的思路。最终我使用的方法是，在进入<code>Release</code>之前记录堆栈指针的值，堆栈指针的值会被压入堆栈，以在函数返回后从堆栈弹出，恢复堆栈指针。<code>Release</code>的实现很简单，就是删除一个<code>Parser</code>这个对象，但这个对象的析构会导致很多其他对象被析构。我就逐层地检查，是在哪个函数里改变了堆栈里的内容。</p>

<p>理论上，函数本身是操作不到调用者的堆栈的。而现在看来，确实是被调用函数，也就是<code>Release</code>改写了调用者的堆栈内容。要改变堆栈的内容，只有通过局部变量的地址才能做到。</p>

<p>最终，我发现在调用完以下函数后，我跟踪的堆栈地址内容发生了改变：</p>

<pre><code>call llvm::RefCountedBase&lt;clang::TargetOptions&gt;::Release (10331117h)
</code></pre>

<p>因为注意到<code>TargetOptions</code>这个字眼，想起了在<code>parser-&gt;Begin</code>里有涉及到这个类的使用，类似于：</p>

<p><div class="highlight"><pre><code class="c"><span class="n">TargetOptions</span> <span class="n">TO</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">TargetInfo</span> <span class="o">*</span><span class="n">TI</span> <span class="o">=</span> <span class="n">TargetInfo</span><span class="o">::</span><span class="n">CreateTargetInfo</span><span class="p">(</span><span class="n">m_inst</span><span class="p">.</span><span class="n">getDiagnostics</span><span class="p">(),</span> <span class="n">TO</span><span class="p">);</span>
</code></pre>
</div></p>

<p>这部分初始化代码，是直接从网上复制的，因为并不影响主要逻辑，所以从来没对这块代码深究。查看<code>CreateTargetInfo</code>的源码，<strong>发现这个函数将<code>TO</code>这个局部变量的地址保存了下来</strong>。</p>

<p>而在<code>Release</code>中，则会对这个保存的临时变量进行删除操作，形如：</p>

<p><div class="highlight"><pre><code class="c"><span class="kt">void</span> <span class="n">Delete</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">ref_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="s">&quot;Reference count is already zero.&quot;</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">ref_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">delete</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div></p>

<p>但是，<strong>问题并不在于对一个局部变量地址进行delete</strong>，<code>delete</code>在调试模式下是做了内存检测的，那会导致一种断言。</p>

<p><code>TargetOptions</code>包含了<code>ref_cnt</code>这个成员。当出了<code>Begin</code>作用域后，parser保存的<code>TargetOptions</code>的地址，指向的内容（堆栈）发生了改变，也就是<code>ref_cnt</code>这个成员变量的值不再正常。由于一些巧合，主要是代码中各个局部变量、函数调用顺序、函数参数个数（曾尝试去除<code>Begin</code>的参数，可以避免错误提示），导致在调用<code>Release</code>前堆栈指针恰好等于之前保存的<code>TargetOptions</code>的地址。注意，之前保存的<code>TargetOptions</code>的地址，和调用<code>Release</code>前的堆栈指针值相同了。</p>

<p>而在<code>TargetOptions</code>的<code>Delete</code>函数中，进行了<code>--ref_cnt</code>，这个变量是<code>TargetOptions</code>的第一个成员，它的减1，也就导致了堆栈内容的改变。</p>

<p>至此，整个来龙去脉算是摸清。</p>
]]></content>
  </entry>
  
</feed>
