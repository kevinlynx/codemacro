<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: ICE | loop in codes]]></title>
  <link href="http://codemacro.com/tags/ice/atom.xml" rel="self"/>
  <link href="http://codemacro.com/"/>
  <updated>2013-08-28T20:49:07+08:00</updated>
  <id>http://codemacro.com/</id>
  <author>
    <name><![CDATA[Kevin Lynx]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用ActionScript开发Ice Web客户端]]></title>
    <link href="http://codemacro.com/2013/06/09/ice-web-client/"/>
    <updated>2013-06-09T00:00:00+08:00</updated>
    <id>http://codemacro.com/2013/06/09/ice-web-client</id>
    <content type="html"><![CDATA[<p>我们目前的项目服务器端使用了<a href="http://codemacro.com/2013/02/15/ice-overview/">Ice</a>来构建。Ice有一套自己的网络协议，客户端和服务器端可以基于此协议来交互。由于Ice使用Slice这种中间语言来描述服务器和客户端的交互接口，所以它可以做到极大限度地屏蔽网络协议这个细节。也就是说，我们只要借助Ice和Slice，我们可以轻松地编写网络程序。</p>

<p>然后，我们的后端现在需要一个运行在Web浏览器上的客户端。要与Ice做交互，如果使用TCP协议的话，得保证是长连接的。但HTTP是短连接的。而另一方面，我们还需要选择一个Ice支持的和Web相关的语言来做这件事情。如果要在浏览器端直接与Ice服务建立连接，可供选择的语言/平台包括：</p>

<ul>
<li>Flash</li>
<li>Silverlight</li>
</ul>


<p>因为我之前用erlang简单写了个Ice的客户端库，所以我对Ice底层协议有一定了解，可以不一定使用Ice支持的语言，所以HTML5其实也是个选择。此外，如果在浏览器端使用Applet，Java可能也是个选择。</p>

<p>其实几个月前在这块的技术选择问题上我就做过简单的研究，当时确定的方案是使用Flash。但是，后来人员招聘上遇到了问题，看起来要招一个会ActionScript和前端页面技术的程序员来做我们这种项目，似乎大材小用，成本显高了。</p>

<p>那么，考虑到团队里有现成的Java程序员，而且看起来招一个会用Java写网站的程序员简单又便宜，似乎是排除技术原因的最好选择。但是，如果不在浏览器端直接连接服务器来做交互，而是让Web服务器端来做中转的话，会面临不少问题：</p>

<ul>
<li>浏览器端操作结果的获取问题，说白了就是非实时了，得用Ajax等等技术去模拟实时，代价就是不断轮训，也就是通常说的poll</li>
<li>Web服务器端需要编写大量代码：对用户操作的映射，结果缓存等等</li>
</ul>


<p>如果能用Flash包装与服务器交互的部分，而把UI相关的东西留给HTML/JS/CSS去做，那是不是可行一点？如果只是用ActionScript编写与服务器端的交互逻辑代码，我就不需要花时间去系统学习ActionScript，甚至如何用Flash做界面，我甚至不用搞懂这些技术之间的关系。基本上看些Ice for ActionScript的例子代码，就可以完成这件事情。</p>

<p>以下记录一些主要的过程/方法：</p>

<!-- more -->


<h2>ActionScript程序的开发</h2>

<p>开发一个嵌入到网页中的FLASH，只需要Flex SDK。SDK里自带了一些编译器相关工具。我不打算使用IDE，因为看起来IDE更复杂。简单的google之后，基本就可以构建出一个Flash文件：</p>

<ul>
<li>构建基本的程序需要一个mxml文件，这个文件里主要用来捕获Flash在页面上初始化完成这个事件，以初始化内部逻辑</li>
<li>编写ActionScript源码，看起来其文件、类的组织方式很像Java</li>
<li><p>使用Flex SDK中的mxmlc程序来编译，生成swf文件，例如：</p>

<p>  mxmlc myflexapp.mxml -library-path+=xxx.swc</p></li>
<li><p>嵌入到网页中，简单的做法可以借助swfobject.js这个库，嵌入的方式：</p></li>
</ul>


<p><div class="highlight"><pre><code class="html"><span class="nt">&lt;/p&gt;</span>

<span class="nt">&lt;pre&gt;&lt;code&gt;</span><span class="ni">&amp;lt;</span>script type=&quot;text/javascript&quot; src=&quot;swfobject.js&quot;<span class="ni">&amp;gt;&amp;lt;</span>/script<span class="ni">&amp;gt;</span>
<span class="ni">&amp;lt;</span>script type=&quot;text/javascript&quot;<span class="ni">&amp;gt;</span>
    var flashvars = {};
    var params = {};
  params.play = &quot;true&quot;;
    params.quality = &quot;high&quot;;
    params.bgcolor = &quot;white&quot;;
    params.allowscriptaccess = &quot;always&quot;;
    params.allowfullscreen = &quot;true&quot;;
    var attributes = {};
    attributes.id = &quot;asclient&quot;;
    attributes.name = &quot;asclient&quot;;
    attributes.align = &quot;middle&quot;;
    swfobject.embedSWF(&quot;asclient.swf&quot;, &quot;flashContent&quot;, &quot;1&quot;, &quot;1&quot;,
        &quot;0&quot;, &quot;&quot;, 
        flashvars, params, attributes);
    swfobject.createCSS(&quot;#flashContent&quot;, &quot;display:none;&quot;);
<span class="ni">&amp;lt;</span>/script<span class="ni">&amp;gt;</span>
<span class="nt">&lt;/code&gt;&lt;/pre&gt;</span>

<span class="nt">&lt;p&gt;</span>
</code></pre>
</div></p>

<p>自然，页面中需加入flashContent这个div：</p>

<p><div class="highlight"><pre><code class="html"><span class="nt">&lt;/p&gt;</span>

<span class="nt">&lt;pre&gt;&lt;code&gt;</span><span class="ni">&amp;lt;</span>div id=&quot;flashContent&quot;<span class="ni">&amp;gt;</span>
    <span class="ni">&amp;lt;</span>p<span class="ni">&amp;gt;</span>no flash<span class="ni">&amp;lt;</span>/p<span class="ni">&amp;gt;</span>
<span class="ni">&amp;lt;</span>/div<span class="ni">&amp;gt;</span>
<span class="nt">&lt;/code&gt;&lt;/pre&gt;</span>

<span class="nt">&lt;p&gt;</span>
</code></pre>
</div></p>

<p>我的mxml文件也很简单：</p>

<p><div class="highlight"><pre><code class="xml"><span class="ni">&amp;lt;</span>?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
<span class="ni">&amp;lt;</span>s:Application<span class="nt">&lt;/p&gt;</span>

<span class="nt">&lt;pre&gt;&lt;code&gt;</span>xmlns:fx=&quot;http://ns.adobe.com/mxml/2009&quot; 
xmlns:s=&quot;library://ns.adobe.com/flex/spark&quot; 
xmlns:mx=&quot;library://ns.adobe.com/flex/mx&quot;
applicationComplete=&quot;doApplicationComplete()&quot; <span class="ni">&amp;gt;</span>
<span class="ni">&amp;lt;</span>fx:Script<span class="ni">&amp;gt;</span>
<span class="ni">&amp;lt;</span>![CDATA[
   import ASClient.Coordinator;
   import flash.external.ExternalInterface;

   private var _coordinator:Coordinator;

   public function doApplicationComplete():void
   {
        trace(&quot;doApplicationComplete&quot;);
        _coordinator = new Coordinator();
        _coordinator.reg_methods();
        ExternalInterface.call(&quot;as_ready&quot;); 
   } 
 ]]<span class="ni">&amp;gt;</span>
<span class="ni">&amp;lt;</span>/fx:Script<span class="ni">&amp;gt;</span>
<span class="nt">&lt;/code&gt;&lt;/pre&gt;</span>

<span class="nt">&lt;p&gt;</span><span class="ni">&amp;lt;</span>/s:Application&gt;
</code></pre>
</div></p>

<h2>ActionScript日志</h2>

<p>我通过日志来调试ActionScript代码。最简单的方式就是通过trace函数来输出日志。要成功输出日志包含以下步骤：</p>

<ul>
<li>给浏览器安装调试版本的Flash Player</li>
<li><p>日志是输出到用户目录下的，并且需要手动创建日志目录(Administrator替换为用户名)：</p>

<pre><code>  C:\Users\Administrator\AppData\Roaming\Macromedia\Flash Player\Logs
</code></pre></li>
<li><p>用户目录下新建配置文件mm.cfg：</p>

<pre><code>  AS3StaticProfile=0
  AS3Verbose=0
  TraceOutputFileEnable=1 
  TraceOutputBuffered=0
  ErrorReportingEnable=1  
  AS3Trace=0
</code></pre></li>
<li><p>编译DEBUG版本的Flash文件，可以修改flex sdk下的flex-config.xml文件，里面增加debug=true配置即可</p></li>
</ul>


<p>在开发过程中需要注意浏览器缓存问题，当编译出新的Flash文件后，浏览器即使页面刷新也可能使用的是缓存里的Flash。当然，最重要的，是通过浏览器来访问这个包含了Flash的网页，Web服务器随意。</p>

<h2>Flash Policy文件</h2>

<p>在Flash的某个版本后，Flash中如果要向外建立socket连接，是首先要取得目标主机返回的policy文件的。也就是在建立连接前，Flash底层会先向目标主机询问得到一个描述访问权限的文件。</p>

<p>简单来说，目标主机需要在843端口上建立TCP监听，一旦有网络连接，就发送以下内容，内容后需添加0x00用于标示结束。（当然，具体细节还挺多，自行google）</p>

<pre><code>&lt;cross-domain-policy&gt;
     &lt;allow-access-from domain="*" to-ports="*" /&gt;
&lt;/cross-domain-policy&gt;
</code></pre>

<p>最开始我使用的是朋友给的现成的Policy服务，虽然我写的Flash可以成功连接我的Ice服务，但始终要等待2秒以上的时间。google Flash Policy相关内容，可以发现确实存在一个延时，但那是因为目标主机没有在843端口服务。后来我自己用erlang写了个Policy服务，延时就没有了。猜测可能是他的Policy服务没有添加0x00作为结束导致。</p>

<h2>ActionScript与JavaScript的交互</h2>

<p>既然我使用ActionScript来包装与服务器的交互，那么JavaScript就必然需要和ActionScript通信。这个通信过程也就是在JavaScript中调用ActionScript中的函数，反过来亦然。这个过程很简单：</p>

<p>在JavaScript中调用ActionScript函数：</p>

<p>首先是ActionScript需要注册哪些函数可以被调用：</p>

<pre><code>ExternalInterface.addCallback("service_loadall", loadAll);
</code></pre>

<p>通过<code>ExternalInterface.addCallback</code>注册的函数，其实是个closure，所以在类中注册自己的成员函数都可以（因为成员函数会使用this，形成了一个closure）。</p>

<p>然后在JavaScript中调用：</p>

<p><div class="highlight"><pre><code class="javascript"><span class="o">&lt;</span><span class="err">/p&gt;</span>

<span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="kd">function</span> <span class="nx">asObject</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// asclient是嵌入Flash时填入的name和(或?)id</span>
    <span class="k">return</span> <span class="nb">window</span><span class="p">.</span><span class="nb">document</span><span class="p">.</span><span class="nx">asclient</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">as</span> <span class="o">=</span> <span class="nx">asObject</span><span class="p">();</span>
<span class="nx">as</span><span class="p">.</span><span class="nx">service_loadall</span><span class="p">();</span>
<span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span>

<span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>
</code></pre>
</div></p>

<p>在ActionScript中调用JavaScript中调用则更简单，一句话：</p>

<pre><code>ExternalInterface.call("service_load_done", args);
</code></pre>

<p>至于在两者之间的函数参数传递，其类型都可以自动映射。但因为我的应用里数据较为复杂，我就将数据转换为JSON格式，在JavaScript这边操作较为简单。</p>

<h2>页面切换</h2>

<p>这里我们需要的Web前端页面，更像是一个管理系统，所以页面切换是很有可能的。问题在于，当出现页面跳转时，Flash对象会重新初始化，新的页面无法使用前一个页面建立好的网络连接（或者能？）。为了解决这个问题，服务器当然可以设计一种重登录机制，方便客户端以一种特殊的方式进入系统，绕过正常的登录环节。但是我们使用了Glacier2这个网关，在这个网关上有针对连接的超时管理，这样反复建立新的连接对资源太浪费了。</p>

<p>综上，我想只能通过前端去规避这个问题。例如，前端开发人员依然可以分开设计很多页面，页面里也可以使用正常的链接。我们编写一些JavaScript代码，将页面里的链接替换成对应的JavaScript代码，动态载入新的页面内容，然后对页面内的部分内容进行替换，从而尽可能让页面设计人员编写正常的网页，同时也解决页面切换问题。</p>

<p>这是个蹩脚的方法，但在我有限的前端知识体系下，似乎也只能这样干了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[erlang使用感受]]></title>
    <link href="http://codemacro.com/2013/05/08/thought-about-erlang/"/>
    <updated>2013-05-08T00:00:00+08:00</updated>
    <id>http://codemacro.com/2013/05/08/thought-about-erlang</id>
    <content type="html"><![CDATA[<p>用erlang也算写了些代码了，主要包括<a href="http://codemacro.com/2013/04/11/rabbitmq-erlang/">使用RabbitMQ的练习</a>，以及最近写的<a href="https://github.com/kevinlynx/erlang-tcpserver">kl_tserver</a>和<a href="https://github.com/kevinlynx/icerl">icerl</a>。其中icerl是一个实现了<a href="http://www.zeroc.com/">Ice</a>的erlang库。</p>

<p>erlang的书较少，我主要读过&lt;Programming Erlang>和&lt;Erlang/OTP in Action>。其实erlang本身就语言来说的话比较简单，同ruby一样，类似这种本身目标是应用于实际软件项目的语言都比较简单，对应的语法书很快可以翻完。</p>

<p>这里我仅谈谈自己在编写erlang代码过程中的一些感受。</p>

<h2>语法</h2>

<p>erlang语法很简单，接触过函数式语言的程序员上手会很快。它没有类似common lisp里宏这种较复杂的语言特性。其语法元素很紧凑，不存在一些用处不大的特性。在这之前，我学习过ruby和common lisp。ruby代码写的比common lisp多。但是在学习erlang的过程中我的脑海里却不断出现common lisp里的语法特性。这大概是因为common lisp的语法相对ruby来说，更接近erlang。</p>

<h3>编程模式</h3>

<p>erlang不是一个面向对象的语言，它也不同common lisp提供多种编程模式。它的代码就是靠一个个函数组织出来的。面向对象语言在语法上有一点让我很爽的是，其函数调用更自然。erlang的接口调用就像C语言里接口的调用一样：</p>

<pre><code>func(Obj, args)
Obj-&gt;func(args)
</code></pre>

<p>即需要在函数第一个参数传递操作对象。但是面向对象语言也会带来一些语法的复杂性。如果一门语言可以用很少的语法元素表达很多信息，那么我觉得这门语言就是门优秀的语言。</p>

<h3>表达式/语句</h3>

<p>erlang里没有语句，全部是表达式，意思是所有语法元素都是有返回值的。这实在太好了，全世界都有返回值可以让代码写起来简单多了：</p>

<p><div class="highlight"><pre><code class="erlang"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nv">Flag</span> <span class="o">=</span> <span class="k">case</span> <span class="n">func</span><span class="p">()</span> <span class="k">of</span> <span class="mi">1</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">true</span><span class="p">;</span> <span class="mi">0</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">false</span> <span class="k">end</span><span class="p">,</span> 
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div></p>

<!-- more -->


<h3>命名</h3>

<p>我之所以不想写一行python代码的很大一部分原因在于这门语言居然要求我必须使用代码缩进来编程，真是不敢相信。erlang里虽然没有此规定，却也有不同的语法元素有大小写的限定。变量首字母必须大写，atom必须以小写字母开头，更霸气的是模块命名必须和文件名相同。</p>

<h3>变量</h3>

<p>erlang里的变量是不可更改的。实际上给一个变量赋值，严格来说应该叫<code>bound</code>，即绑定。这个特性完全就是函数式语言里的特性。其带来的好处就像函数式语言宣扬的一样，这会使得代码没有副作用(side effect)。因为程序里的所有函数不论怎样调用，其程序状态都不会改变，因为变量无法被改变。</p>

<p>变量不可更改，直接意味着全局变量没有存在的意义，也就意味着不论你的系统是多么复杂地被构建出来，当系统崩溃时，其崩溃所在位置的上下文就足够找到问题。</p>

<p>但是变量不可改变也会带来一些代码编写上的不便。我想这大概是编程思维的转变问题。erlang的语法特性会强迫人编写非常短小的函数，你大概不愿意看到你的函数实现里出现Var1/Var2/Var3这样的变量，而实际上这样的命名在命令式语言里其实指的是同一个变量，只不过其值不同而已。</p>

<p>但是我们的程序总是应该有状态的。在erlang里我们通过不断创建新的变量来存储这个状态。我们需要通过将这个状态随着我们的程序流程不断地通过函数参数和返回值传递下去。</p>

<h3>atom</h3>

<p>atom这个语法特性本身没问题，它就同lisp里的atom一样，没什么意义，就是一个名字。它主要用在增加代码的可读性上。但是这个atom带来的好处，直接导致erlang不去内置诸如true/false这种关键字。erlang使用true/false这两个atom来作为boolean operator的返回值。但erlang里严格来说是没有布尔类型的。这其实没什么，糟糕的是，对于一些较常见的函数返回值，例如true/false，erlang程序员之间就得做约定。要表示一个函数执行失败了，我可以返回false、null、failed、error、nil，甚至what_the_fuck，这一度让我迷惘。</p>

<h3>list/tuple</h3>

<p>erlang里的list当然没有lisp里的list牛逼，别人整个世界就是由list构成的。在一段时间里，我一直以为list里只能保存相同类型的元素，而tuple才是用于保存不同类型元素的容器。直到有一天我发现tuple的操作不能满足我的需求了，我才发现list居然是可以保存不同类型的。</p>

<p>list相对于tuple而言，更厉害的地方就在于头匹配，意思是可以通过匹配来拆分list的头和剩余部分。</p>

<h3>匹配(match)</h3>

<p>erlang的匹配机制是个好东西。这个东西贯穿了整个语言。在我理解看来，匹配机制减少了很多判断代码。它试图用一个期望的类型去匹配另一个东西，如果这个东西出了错，它就无法完成这个匹配。无法完成匹配就导致程序断掉。</p>

<p>匹配还有个方便的地方在于可以很方便地取出record里的成员，或者tuple和list的某个部分，这其实增强了其他语法元素的能力。</p>

<h3>循环</h3>

<p>erlang里没有循环语法元素，这真是太好了。函数式语言里为什么要有循环语法呢？common lisp干毛要加上那些复杂的循环（宏），每次我遇到需要写循环的场景时，我都诚惶诚恐，最后还是用递归来解决。</p>

<p>同样，在erlang里我们也是用函数递归来解决循环问题。甚至，我们还有list comprehension。当我写C++代码时，我很不情愿用循环去写那些容器遍历代码，幸运的是在C++11里通过lambda和STL里那些算法我终于不用再写这样的循环代码了。</p>

<h3>if/case/guard</h3>

<p>erlang里有条件判定语法if，甚至还有类似C语言里的switch...case。这个我一时半会还不敢评价，好像haskell里也保留了if。erlang里同haskell一样有guard的概念，这其实是一种变相的条件判断，只不过其使用场景不一样。</p>

<h3>进程</h3>

<p>并发性支持属于erlang的最大亮点。erlang里的进程概念非常简单，基于消息机制，程序员从来不需要担心同步问题。每个进程都有一个mailbox，用于缓存发送到此进程的消息。erlang提供内置的语法元素来发送和接收消息。</p>

<p>erlang甚至提供分布式支持，更酷的是你往网络上的其他进程发送消息，其语法和往本地进程发送是一样的。</p>

<h3>模块加载</h3>

<p>如果我写了一个erlang库，该如何在另一个erlang程序里加载这个库？这个问题一度让我迷惘。erlang里貌似有对库打包的功能(.ez?)，按理说应该提供一种整个库加载的方式，然后可以通过手动调用函数或者指定代码依赖项来加载。结果不是这样。</p>

<p>erlang不是按整个库来加载的，因为也没有方式去描述一个库（应该有第三方的）。当我们调用某个模块里的函数时，erlang会自动从某个目录列表里去搜索对应的beam文件。所以，可以通过在启动erlang添加这个模块文件所在目录来实现加载，这还是自动的。当然，也可以在erlang shell里通过函数添加这个目录。</p>

<h2>OTP</h2>

<p>使用erlang来编写程序，最大的优势可能就是其OTP了。OTP基本上就是一些随erlang一起发布的库。这些库中最重要的一个概念是behaviour。behaviour其实就是提供了一种编程框架，应用层提供各种回调函数给这个框架，从而获得一个健壮的并发程序。</p>

<h3>application behaviour</h3>

<p>application behaviour用于组织一个erlang程序，通过一个配置文件，和提供若干回调，就可以让我们编写的erlang程序以一种统一的方式启动。我之前写的都是erlang库，并不需要启动，而是提供给应用层使用，所以也没使用该behaviour。</p>

<h3>gen_server behaviour</h3>

<p>这个behaviour应该是使用频率很高的。它封装了进程使用的细节，本质上也就是将主动收取消息改成了自动收取，收取后再回调给你的模块。</p>

<h3>supervisor behaviour</h3>

<p>这个behaviour看起来很厉害，通过对它进行一些配置，你可以把你的并发程序里的所有进程建立成树状结构。这个结构的牛逼之处在于，当某个进程挂掉之后，通过supervisor可以自动重新启动这个挂掉的进程，当然重启没这么简单，它提供多种重启规则，以让整个系统确实通过重启变成正常状态。这实在太牛逼了，这意味着你的服务器可以7x24小时地运行了，就算有问题你也可以立刻获得一个重写工作的系统。</p>

<h3>热更新</h3>

<p>代码热更新对于一个动态语言而言其实根本算不上什么优点，基本上动态语言都能做到这一点。但是把热更新这个功能加到一个用于开发并发程序的语言里，那就很牛逼了。你再一次可以确保你的服务器7x24小时不停机维护。</p>

<h3>gen_tcp</h3>

<p>最开始我以为erlang将网络部分封装得已经认不出有socket这个概念了。至少，你也得有一个牛逼的网络库吧。结果发现依然还是socket那一套。然后我很失望。直到后来，发现使用一些behaviour，加上调整gen_tcp的一些option，居然可以以很少的代码写出一个维护大量连接的TCP服务器。是啊，erlang天生就是并发的，在传统的网络模型中，我们会觉得使用one-thread-per-connection虽然简单却不是可行的，因为thread是OS资源，太昂贵。但是在erlang里，one-process-per-connection却是再自然不过的事情。你要是写个erlang程序里面却只有一个process你都不好意思告诉别人你写的是erlang。process是高效的（对我们这种二流程序员而言），它就像C++里一个很普通的对象一样。</p>

<p>在使用gen_tcp的过程中我发现一个问题，不管我使用哪一种模型，我竟然找不到一种温柔的关闭方式。我查看了几个tutorial，这些混蛋竟然没有一个人提到如何去正常关闭一个erlang TCP服务器。后来，我没有办法，只好使用API强制关闭服务器进程。</p>

<h2>Story</h2>

<p>其实，我和erlang之间是有故事的。我并不是这个月开始才接触erlang。早在2009年夏天的时候我就学习过这门语言。那时候我还没接触过任何函数式语言，那时候lua里的闭包都让我觉得新奇。然后无意间，我莫名其妙地接触了haskell（&lt;Real World Haskell>），在我决定开始写点什么haskell练习时，我发现我无从下手，最后，Monads把我吓哭了。haskell实在太可怕了。</p>

<p>紧接着我怀揣着对函数式语言的浓烈好奇心看到了erlang。当我看到了concurrent programming的章节时，在一个燥热难耐的下午我的领导找到了我，同我探讨起erlang对我们的网游服务器有什么好处。然后，我结束我了的erlang之旅。</p>

<p>时隔四年，这种小众语言，居然进入了中国程序员的视野，并被用于开发网页游戏服务器。时代在进步，我们总是被甩在后面。</p>
]]></content>
  </entry>
  
</feed>
