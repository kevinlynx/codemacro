<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | loop in codes]]></title>
  <link href="http://codemacro.com/categories/java/atom.xml" rel="self"/>
  <link href="http://codemacro.com/"/>
  <updated>2017-02-25T15:48:08+08:00</updated>
  <id>http://codemacro.com/</id>
  <author>
    <name><![CDATA[Kevin Lynx]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[写一个玩具Java虚拟机]]></title>
    <link href="http://codemacro.com/2017/02/25/toy-jvm/"/>
    <updated>2017-02-25T00:00:00+08:00</updated>
    <id>http://codemacro.com/2017/02/25/toy-jvm</id>
    <content type="html"><![CDATA[<p>本文描述了一个用Java实现的玩具JVM，用Java实现的好处是可以不用处理JVM中的垃圾回收。</p>

<p>Java虚拟机是基于栈的虚拟机。栈虚拟机的特点是所有临时操作数都存放在栈中。编译器生成的指令都会围绕着这个栈展开，相对而言，解释执行这些指令会比较容易。基于栈的虚拟机可能会生成如下指令：</p>

<pre><code>push 3   # 把立即数3压栈
push 4   # 把立即数4压栈
add      # 从栈中弹出两个操作数进行相加，结果压回栈中
</code></pre>

<p>Java .class文件存储的主要就是编译后的指令，一个玩具JVM，简单来说就是解释执行这里面的指令。接下来就说说为了让这个JVM跑起来需要实现哪些功能。</p>

<h2>class 文件解析</h2>

<p>推荐一下 <a href="https://www.codeproject.com/articles/35915/java-class-viewer">Java class viewer</a>，里面有个工具可以可视化class文件内容。另外我直接复用了他解析class文件的代码。</p>

<p>class文件描述的信息是以class为单位的，一个类如果有嵌套类，这个嵌套类也会生成为单独的class文件。从c/c++程序员的视角来看，class文件的生成有点类似编译，编译器在编译期间只做依赖符号存在与否的检查。所有引用其他class的地方，不同于c/c++，java class的引用都是在运行期定位的。这里看看一个简单的类class文件结构是怎样的：</p>

<!-- more -->


<pre><code>package test;

public class Simple {
  private int data;

  public int add(int a, int b) {
    return a + b;
  }
}
</code></pre>

<p><img src="http://i.imgur.com/VCk3vGO.jpg" alt="" /></p>

<p>一个class文件比较重要的有：</p>

<ul>
<li>constant pool(常量池)：存储字符串字面量、函数原型描述、类成员描述、class引用描述。字节码中经常会引用常量池中的内容，例如要设置某个成员变量，字节码中的操作数就是常量池索引，从索引中获取出具体是哪个成员变量</li>
<li>fields：描述类成员变量</li>
<li>methods: 描述类成员函数</li>
<li>attributes: 分布在很多地方，可能嵌套，用于描述method字节码、调试符号信息等。</li>
</ul>


<p>常量池非常重要，这里看看class文件中是如何使用常量池的。例如，一个field描述：</p>

<p><img src="http://i.imgur.com/dUnFttG.jpg" alt="" /></p>

<p>其中<code>name_index</code>和<code>descriptor_index</code>的值，指向的就是常量池索引，通过前面推荐的class viewer去常量池中找就会找到对应的值：</p>

<p><img src="http://i.imgur.com/8uqslfH.jpg" alt="" /></p>

<p><code>descriptor_index</code>描述field类型，<code>I</code>指的是整数。Java里有一套描述类型的规则，这个规则在函数定义的地方也会看到。</p>

<p>methods只要有实现，就都会有一个Code attribute，也就是这个函数的具体实现字节码，例如前面的add函数字节码为：</p>

<pre><code>opcode [1B] - 0000: iload_1     # 将第1个局部变量值压栈
opcode [1C] - 0001: iload_2     # 将第2个局部变量值压栈
opcode [60] - 0002: iadd        # 弹出2个操作数相加，结果压栈
opcode [AC] - 0003: ireturn     # 弹出1个操作数作为函数返回值
</code></pre>

<p>解析出class文件中的信息后，玩具JVM就完成一半了。</p>

<h2>JVM指令</h2>

<p>JVM中已经有200多条指令了。但是这些指令很多都是相似的。具体实现这些指令时可以参考<a href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings">指令表</a>。JVM指令就像x86指令一样，由操作码以及可选的操作数组成。操作码表示具体是哪条指令，占1个字节；操作数表示该操作码需要的参数，变长。class文件中字节码连续存放，像上一节的例子就是4条指令，每条指令只有操作码没有操作数，他们存放在class文件中就是：1B 1C 60 AC。</p>

<p>JVM依次读取这些指令并解释执行。这个过程同真实计算机CPU执行过程类似。用代码描述为：</p>

<pre><code>while (true) {
  code = fetchOpCode()
  if (code == iload_1) {
    push(1)
  } elif (code == iadd) {
    i1 = pop()
    i2 = pop()
    push(i1 + i2)
  } elif (code == bipush) { // 需要操作数的指令
    b = fetchOpValue()
    push(b)
  }
  ...
}
</code></pre>

<p>程序执行过程中有一个虚拟指针PC，用于指示当前字节码处理到哪个位置了。有些跳转指令会强制改变PC。不同于c/c++程序，JVM中跳转指令跳转的都是相对位移。JVM启动时，不同于c/c++，也没有地址重定位的过程(修正相对地址为实际地址)。</p>

<h2>执行环境</h2>

<h3>线程执行环境</h3>

<p>JVM中每个线程都是独立的执行单元。但是对于类符号等信息则是全局共享，堆上创建的对象也是全局可访问的。单个线程中调用函数会产生帧(frame)，每一帧都有一个独立的栈用于存储该帧执行的临时数据。从main函数开始执行，每进入一个函数创建一个帧，函数退出(执行return系列指令)清除当前帧。这里的帧也可以被实现为一个栈，当这个栈里没有帧时就表示这个线程退出。这个过程可以描述为：</p>

<pre><code>while (thread.topFrame() != null) {
  thread.topFrame().run() // 内部实现就是从Code属性处不断地取指令执行
}

// 执行到return语句时，就弹出该帧
if (code == op_return) {
  frame.getThread().popFrame()
}

// 遇到函数调用时，就根据目标函数创建出一帧
if (code == op_invoke) {
  method = findMethod(ref) // 函数调用时操作数是常量池索引，需要加载目标类，获取目标方法
  newFrame = createFrame(method) // 每个方法都会描述该方法内有多少局部变量，所需栈多大，根据这些信息初始化帧
  frame.getThread().pushFrame(newFrame) 
}
</code></pre>

<p>注释中提到了，class文件中method包含了“有多少局部变”、“需要多大的栈”等信息。局部变量的实现是一个数组，数组的下标表示局部变量是第几个。字节码中要访问局部变量时，全部是以这个下标来查找的。例如指令<code>istore_1</code>，表示从栈中弹出一个整数，并写到局部变量1中。</p>

<p><img src="http://i.imgur.com/dUW6ukh.jpg" alt="" /></p>

<h3>全局环境</h3>

<p>由于使用Java实现，堆内存的管理完全不用操心。如果我们代码中创建了一个类对象，或者简单点调用了另一个类的静态方法，这个时候会发生什么以及如何处理？例如以下代码：</p>

<pre><code>int a = Simple2.inc(2);
</code></pre>

<p>生成以下字节码：</p>

<pre><code>opcode [05] - 0004: iconst_2  # 压入常量2到栈，作为函数调用的参数
opcode [B8] - 0005: invokestatic 2 [Methodref: test.Simple2.inc, parameter = (int), returns = int]
</code></pre>

<p>可以看出调用静态函数<code>invokestatic</code>的操作数是2，指向的是常量池中的2。工具直接显示了常量池2是一个method，及该method的原型。</p>

<p>遇到这样的指令时，我们就需要找到并加载目标类。所以，全局信息里需要维护类列表。考虑到Java中类与类之间是否相同，除了看类名（全限定名）外，还得看类的加载器(class loader)。所以，玩具JVM中也需要有class loader机制（至少是个简化版）。程序启动时设定一个默认的类加载器，加载主类，执行主类main方法，执行过程中遇到对其他类的引用时，就使用当前类加载器继续加载目标类，如果已经加载就直接返回。</p>

<h2>类加载及main方法</h2>

<p>前面已经提到了类加载。其实类加载本质上就是把目标class文件加载到内存，保存该class信息。在调用一个类的方法时，也是根据方法名(考虑到方法重载，还得考虑方法的原型，在class file中也就是descriptor)找到具体的方法，根据方法初始化调用帧，以及根据方法获得其要执行的字节码。</p>

<p>所以，我们的JVM要跑起来，也就是找到并加载主类，然后找到主类中的main函数并执行。</p>

<pre><code>  public void run(String mainClass) {
    Class clazz = mRootLoader.loadClass(mainClass);
    MethodInfo method = clazz.findMethod("main", "([Ljava/lang/String;)V");
    Thread thread = new Thread();
    thread.run(clazz, method);
  }
</code></pre>

<p>当然，这个过程严格来说还得判定类访问控制、方法访问控制等。</p>

<p><strong>至此，这个玩具JVM就可以跑起来了</strong>。可以设定它的class path，加载类，从main方法开始执行，调用其他类的静态方法，写写阶乘的实现是没有问题了。但是Java中还有很多其他特性：类对象、调用类实例方法、异常处理、调用native方法等待。接下来我再讲讲这些特性的实现，一窥Java核心语法的实现。</p>

<h2>扩展实现</h2>

<h3>类对象及实例方法调用</h3>

<p>类对象的创建通过<code>new</code>指令完成，本质上也就是分配个对象，并关联类信息到这个对象。我们的实现中自然会有一个类用来表示玩具JVM中所有的对象：</p>

<pre><code>// 为了与java.lang.Object区分开
public class VObject {
  // 简单起见，直接以field名作为key，来保存该对象所有的成员变量
  private Map&lt;String, Slot&gt; mFields; 
  // 与之关联的类信息
  private final Class mClazz;
    ...
}
</code></pre>

<p>注意这里的<code>Class</code>是我们自己定义的Class，而不是java.lang.Class。<code>Slot</code>类型用于存储整数或一个引用(其他对象)。<code>new</code>指令的大概实现：</p>

<pre><code>register(Opcode.op_new, (codes, frame) -&gt; {
  int b1 = codes.readByte();
  int b2 = codes.readByte();
  int idx = (b1 &lt;&lt; 8) + b2; // 常量池索引，指向一个类信息描述
  String clazzName = frame.getClazz().resolveClassName(idx); // 根据这个类信息描述解析到具体的类名
  Class clazz = frame.getClazz().getClassLoader().loadClass(clazzName); // 使用当前的类加载器加载该类
  initClass(frame.getThread(), clazz); 
  VObject object = new VObject(clazz); // 创建该类对应的对象，完成new指令的对象创建动作
  frame.pushRef(object); // 根据new指令的语义，我们需要将创建好的对象引用压回栈中
});
</code></pre>

<p>需要注意的是，当我们在Java中写下代码 <code>new SomeClass()</code> 时，实际会产生两个功能的指令：a) 创建对象；b) 调用类的构造函数(<init>)</p>

<pre><code>opcode [BB] - 0004: name_new 2 [Class: test.Simple2]  # new 指令，操作数是类信息常量池索引
opcode [59] - 0007: dup 
opcode [B7] - 0008: invokespecial 3 [Methodref: test.Simple2. , parameter = (), returns = void] # 调用目标类的构造函数，也就是&lt;init&gt;方法
</code></pre>

<p>调用类构造函数同普通类实例方法原理相同，都会先压入对象引用。<code>invokespecial</code>指令用于调用类对象实例方法，从栈顶依次出栈参数，最后出栈类对象实例引用。具体可以看看指令表里的描述。</p>

<h3>类静态区域初始化</h3>

<p>首次加载某个类时，会执行其static区域代码。这个写测试看下生成的代码就懂了，就是生成一个<cinit>的静态方法，在加载类时先执行这个方法。</p>

<h3>异常处理</h3>

<p>当一个方法中有try/catch时，该方法就会生成出一个异常处理表，存储在Code属性中。如下图：</p>

<p><img src="http://i.imgur.com/Ms1qPYr.jpg" alt="" /></p>

<p>异常处理表每一项都包含：<code>start_pc</code>、<code>end_pc</code>、<code>handler_pc</code> 及<code>catch_type</code>，表示在start_pc/end_pc间发现异常，且异常类型是catch_type时，则跳转到handler_pc处执行代码，也就是异常处理代码。其中catch_type也是常量池中的索引，当其为0时，则不是常量池索引，而是表示catch所有类型，其实就是finally块。从这里也可以看出，常量池索引是从1开始，而不是0。</p>

<p>当异常发生时，JVM首先从当前帧对应的方法中的异常处理表查找异常处理代码，没有的话则弹出当前帧，回到上一帧，也就是调用者继续查找，直到找完所有调用帧。这个实现相对较多，就不列举代码了。</p>

<h3>调用本地方法</h3>

<p>前面实现的JVM都没有输出字符串的能力，要提供一个类似<code>System.out.println</code>的方法，就需要注册本地方法到JVM中。这里可以简单地为整个JVM设置一个本地方法表，在JVM启动时完成注册。类似以下代码：</p>

<pre><code>public static void native println(String s);
</code></pre>

<p>也会在class文件中留下一个method，但这个method会被标记为native，自然也没有Code属性，没有字节码可执行。当执行<code>invoke</code>系列指令时，发现调用的是native方法，就需要从全局本地方法表中查找。注册本地方法类似：</p>

<pre><code>mMethods.put(makeKey("java/lang/System", "println", "(Ljava/lang/String;)V"), (frame) -&gt; {
  String s = (String) frame.popRef();
  System.out.println(s);
});
</code></pre>

<p>本地方法执行时，通过<code>frame</code>参数就可以取出调用该方法传入的参数。</p>

<p>在实现了本地方法后，就可以给这个玩具JVM添加一些系统库，类似OpenJDK中jre目录下的lib。这些系统库可以包含java.lang.System.println、java.lang.String、java.lang.StringBuilder。简单起见，我实现的这些类和Java标准库有些不同。</p>

<h2>最后</h2>

<p>完整代码<a href="https://github.com/kevinlynx/toy_jvm">这里</a>。实现的指令很有限，可以跑通<a href="https://github.com/kevinlynx/toy_jvm/blob/master/test/AllTest.java">test/AllTest.java</a>中的代码。对于long/double等类型没有支持，各种限定访问的判断也没有。总之就是简单到仅仅可以一窥原理。基于java8，测试例子class文件java7编译(应该没关系)。祝玩得开心。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中隔离容器的实现]]></title>
    <link href="http://codemacro.com/2015/09/05/java-lightweight-container/"/>
    <updated>2015-09-05T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/09/05/java-lightweight-container</id>
    <content type="html"><![CDATA[<p>Java中隔离容器用于隔离各个依赖库环境，解决Jar包冲突问题。</p>

<h2>问题</h2>

<p>应用App依赖库LibA和LibB，而LibA和LibB又同时依赖LibBase，而LibA和LibB都是其他团队开发的，其中LibA发布了一个重要的修复版本，但是依赖LibBase v2.0，而LibB还没有升级版本，LibBase还不是兼容的，那么此时升级就会面临困难。在生产环境中这种情况往往更恶劣，可能是好几层的间接依赖关系。</p>

<p>隔离容器用于解决这种问题。它把LibA和LibB的环境完全隔离开来，LibBase即使类名完全相同也不互相冲突，使得LibA和LibB的升级互不影响。众所周知，Java中判定两个类是否相同，看的是类名和其对应的class loader，两者同时相同才表示相等。隔离容器正是利用这种特性实现的。</p>

<h2>KContainer</h2>

<p>这里我实现了一个demo，称为KContainer，源码见<a href="https://github.com/kevinlynx/kcontainer">github kcontainer</a>。这个container模仿了一些OSGI的东西，这里把LibA和LibB看成是两个bundle，bundle之间是互相隔离的，每个bundle有自己所依赖的第三方库，bundle之间的第三方库完全对外隐藏。bundle可以导出一些类给其他bundle用，bundle可以开启自己的服务。由于是个demo，我只实现关键的部分。</p>

<p>KContainer的目录结构类似：</p>

<pre><code>.
|-- bundle
    |-- test1
        |-- test1.prop
        |-- classes
        |-- lib
            |-- a.jar
            |-- b.jar
    |-- test2
        |-- test2.prop
        |-- classes
|-- lib
    |-- kcontainer.jar
    |-- kcontainer.interface.jar
</code></pre>

<p>bundle目录存放了所有会被自动载入的bundle。每一个bundle都有一个配置文件<code>bundle-name.prop</code>，用于描述自己导出哪些类，例如：</p>

<pre><code>init=com.codemacro.test.B
export-class=com.codemacro.test.Export; com.codemacro.test.Export2
</code></pre>

<p><code>init</code>指定bundle启动时需要调用的类，用户可以在这个类里开启自己的服务；<code>export-class</code>描述需要导出的类列表。bundle之间的所有类都是隔离的，但<code>export-class</code>会被统一放置，作为所有bundle共享的类。后面会描述KContainer如何处理类加载问题，这也是隔离容器的主要内容。</p>

<!-- more -->


<p>bundle依赖的类可以直接以<code>*.class</code>文件存放到<code>classes</code>目录，也可以作为<code>*.jar</code>放到<code>lib</code>目录。作为extra pratice，我还会把<code>*.jar</code>中的jar解压同时作为类加载的路径。</p>

<p>KContainer本身可以作为一个framework被使用。为了示例，我写了一个入口类，加载启动完所有bundle后就退出了，这个仅作为例子，用不了生产。</p>

<h2>隔离的核心实现</h2>

<p>隔离的目的是分开各个bundle中的类。利用的语言特性包括：</p>

<ul>
<li>class的区分由class name和载入其的class loader共同决定</li>
<li>当在class A中使用了class B时，JVM默认会用class A的class loader去加载class B</li>
<li>class loader中的双亲委托机制</li>
<li><code>URLClassLoader</code>会从指定的目录及*.jar中加载类</li>
</ul>


<p>KContainer的主要任务，就是为bundle实现一个自定义的class loader。</p>

<p>当KContainer加载一个bundle时，在处理其<code>export-class</code>或<code>init</code>时，都是需要加载bundle中的类的。在这之前，我给每一个bundle关联一个独立的<code>BundleClassLoader</code>。然后用这个class loader去加载bundle中的类，利用class loader传递特性，使得一个bundle中的所有类都是由其关联的class loader加载的，从而实现bundle之间类隔离效果。</p>

<p>实现class loader时，是实现<code>loadClass</code>还是<code>findClass</code>？通过实现<code>loadClass</code>我们可以改变class loader的双亲委托模式，制定加载类的具体顺序。但我的目的仅仅是隔离bundle，想了下其实实现<code>findClass</code>就可以达成目的。关于<code>loadClass</code>和<code>findClass</code>的区别可以参考这里 (<a href="http://blog.csdn.net/fenglibing/article/details/17471659">实现自己的类加载时，重写方法loadClass与findClass的区别</a>)。简单来说，就是<code>findClass</code>只有在类确实找不到的情况下才会被调用，在此之前，<code>loadClass</code>默认都是走的双亲委托模式。</p>

<p><code>BundleClassLoader</code>派生于<code>URLClassLoader</code>，默认的parent class loader就是<code>system class loader</code> (<code>app class loader</code>)。这使得KContainer中的bundle类加载有三层选择：自己的class path；其他bundle共享的classes；jvm的class path。通过实现<code>findClass</code>，在默认路径都无法加载到类时，才尝试bundle共享的class，优先级最低。</p>

<p>其实现大概为：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BundleClassLoader</span> <span class="kd">extends</span> <span class="n">URLClassLoader</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nf">BundleClassLoader</span><span class="o">(</span><span class="n">File</span> <span class="n">home</span><span class="o">,</span> <span class="n">SharedClassList</span> <span class="n">sharedClasses</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// getClassPath将bundle目录下的classes和各个jar作为class path传给URLClassLoader</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">getClassPath</span><span class="o">(</span><span class="n">home</span><span class="o">));</span>
    <span class="k">this</span><span class="o">.</span><span class="na">sharedClasses</span> <span class="o">=</span> <span class="n">sharedClasses</span><span class="o">;</span>
  <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="n">Class</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?&gt;</span> <span class="n">findClass</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
    <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="k">try</span> <span class="n">find</span> <span class="kd">class</span> <span class="err">{}&amp;</span><span class="nc">rdquo</span><span class="o">;,</span> <span class="n">name</span><span class="o">);</span>
    <span class="n">Class</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?&gt;</span> <span class="n">claz</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">claz</span> <span class="o">=</span> <span class="kd">super</span><span class="o">.</span><span class="na">findClass</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">claz</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">claz</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">load</span> <span class="n">from</span> <span class="kd">class</span> <span class="nc">path</span> <span class="k">for</span> <span class="o">{}&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="n">name</span><span class="o">);</span>
      <span class="k">return</span> <span class="n">claz</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">claz</span> <span class="o">=</span> <span class="n">sharedClasses</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">claz</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">load</span> <span class="n">from</span> <span class="n">shared</span> <span class="kd">class</span> <span class="nc">for</span> <span class="o">{}&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="n">name</span><span class="o">);</span>
      <span class="k">return</span> <span class="n">claz</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">logger</span><span class="o">.</span><span class="na">warn</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">not</span> <span class="n">found</span> <span class="kd">class</span> <span class="err">{}&amp;</span><span class="nc">rdquo</span><span class="o">;,</span> <span class="n">name</span><span class="o">);</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">ClassNotFoundException</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>
完整代码参看<a href="https://github.com/kevinlynx/kcontainer/blob/master/kcontainer/src/main/java/com/codemacro/container/BundleClassLoader.java">BundleClassLoader.java</a></p>

<p>创建bundle时，会为其创建自己的class loader，并使用这个class loader来载入<code>export-class</code>和<code>init-class</code>：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="n">Bundle</span> <span class="nf">create</span><span class="o">(</span><span class="n">File</span> <span class="n">home</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">SharedClassList</span> <span class="n">sharedClasses</span><span class="o">,</span>
      <span class="n">BundleConf</span> <span class="n">conf</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">BundleClassLoader</span> <span class="n">loader</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">BundleClassLoader</span><span class="o">(</span><span class="n">home</span><span class="o">,</span> <span class="n">sharedClasses</span><span class="o">);</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">exports</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="na">getExportClassNames</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">exports</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">load</span> <span class="n">exported</span> <span class="n">classes</span> <span class="k">for</span> <span class="o">{}&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="n">name</span><span class="o">);</span>
      <span class="n">loadExports</span><span class="o">(</span><span class="n">loader</span><span class="o">,</span> <span class="n">sharedClasses</span><span class="o">,</span> <span class="n">exports</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">Bundle</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">conf</span><span class="o">.</span><span class="na">getInitClassName</span><span class="o">(),</span> <span class="n">loader</span><span class="o">);</span>
  <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">loadExports</span><span class="o">(</span><span class="n">ClassLoader</span> <span class="n">loader</span><span class="o">,</span> <span class="n">SharedClassList</span> <span class="n">sharedClasses</span><span class="o">,</span>
      <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">exports</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="nl">claz_name:</span> <span class="n">exports</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
          <span class="n">Class</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?&gt;</span> <span class="n">claz</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span><span class="n">claz_name</span><span class="o">);</span> <span class="c1">// 载入class</span>
          <span class="n">sharedClasses</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">claz_name</span><span class="o">,</span> <span class="n">claz</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">logger</span><span class="o">.</span><span class="na">warn</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">load</span> <span class="kd">class</span> <span class="err">{} </span><span class="nc">failed</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="n">claz_name</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="o">}</span>
  <span class="o">}</span></code></pre></div></p>

<p>以上。</p>

<h2>扩展</h2>

<p>扩展的地方有很多，例如支持导出package，导出一个完整的jar。当然可能需要实现<code>loadClass</code>，以改变类加载的优先级，让共享类的优先级高于jvm class path的优先级。</p>

<h2>其他</h2>

<h3>线程ContextClassLoader</h3>

<p>提到class loader，我们看下最常接触的几类：</p>

<ul>
<li><code>XX.class.getClassLoader</code>，获取加载类<code>XX</code>的class loader</li>
<li><code>Thread.currentThread().getContextClassLoader()</code>，获取当前线程的ContextClassLoader</li>
<li><code>ClassLoader.getSystemClassLoader()</code>，获取system class loader</li>
</ul>


<p>system class loader的parent就是ext class loader，再上面就是bootstrap class loader了 (不是java类，实际获取不到)。默认情况下以上三个class loader都是一个：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ClassLoader</span><span class="o">.</span><span class="na">getSystemClassLoader</span><span class="o">());</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Main</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">());</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getContextClassLoader</span><span class="o">());</span></code></pre></div></p>

<p>Output:</p>

<pre><code>sun.misc.Launcher$AppClassLoader@157c2bd
sun.misc.Launcher$AppClassLoader@157c2bd
sun.misc.Launcher$AppClassLoader@157c2bd
</code></pre>

<p>创建线程时，新的线程ContextClassLoader就是父线程的ContextClassLoader。在载入一个新的class时，推荐优先使用线程context class loader，例如框架<a href="http://jodd.org/">Jodd</a>中包装的。关于线程context class loader和<code>Class.getClassLoader</code>这里有个解释算是相对合理：<a href="http://www.xcoder.cn/html/web/j2ee/2013/0506/5557.html">ContextClassLoader浅析</a></p>

<p>即，当你把一个对象A传递到另一个线程中，这个线程由对象B创建，A/B两个对象对应的类关联的class loader不同，在B的线程中调用A.some_method，some_method加载资源或类时，如果使用了<code>Class.getClassLoader</code>或<code>Class.forName</code>时，实际使用的是A的class loader，而这个行为可能不是预期的。这个时候就需要将代码改为<code>Thread.currentThread().getContextClassLoader()</code>。</p>

<p>完。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java GC总结]]></title>
    <link href="http://codemacro.com/2015/08/10/java-gc-summary/"/>
    <updated>2015-08-10T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/08/10/java-gc-summary</id>
    <content type="html"><![CDATA[<p>Java GC相关的文章有很多，本文只做概要性总结，主要内容来源于&lt;深入理解Java虚拟机>。</p>

<h2>对象存活性判定</h2>

<p>对象存活性判定用于确定一个对象是死是活，死掉的对象则需要被垃圾回收。主要包括的方法：</p>

<ul>
<li>引用计数</li>
<li>可达性分析</li>
</ul>


<p>可达性分析的基本思想是：</p>

<blockquote><p>通过一系列的称为&#8221;GC Roots&#8221;的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链项链时，则证明此对象是不可用的。</p></blockquote>

<p>在Java中有很多种类的对象可以作为GC Roots，例如类静态属性引用的对象。</p>

<h2>垃圾收集算法</h2>

<p>确定了哪些对象是需要回收之后，就可以运用各种垃圾收集算法收集这些对象，例如直接回收内存，或者回收并移动整理内存。</p>

<p>主要包括：</p>

<ul>
<li>标记清除(Mark-Sweep)算法：首先标记出需要回收的对象，然后统一回收被标记的对象</li>
<li>复制(Copying)算法：将可用内存分块，当一块内存用完后将存活对象复制到其他块，并统一回收不使用的块。Java中新生代对象一般使用该方法</li>
<li>标记整理(Mark-Compact)算法：基本同标记清除，不同的是回收时是把可用对象进行移动，以避免内存碎片问题</li>
<li>分代收集，将内存分区域，不同区域采用不同的算法，例如Java中的新生代及老年代</li>
</ul>


<!-- more -->


<p><img src="/assets/res/heap-structure.png" alt="" /></p>

<p>如上，Java Hotspot虚拟机实现中将堆内存分为3大区域，即新生代、老年代、永久代。新生代中又分了eden、survivor0及survivor1，采用复制算法；老年代则采用标记清除及标记整理；永久代存放加载的类，类似于代码段，但同样会发生GC。</p>

<h2>垃圾收集器</h2>

<p>垃圾收集算法在实现时会略有不同，不同的实现称为垃圾收集器。不同的垃圾收集器适用的范围还不一样，有些收集器仅能用于新生代，有些用于老年代，有些新生代老年代都可以被使用。垃圾收集器可通过JVM启动参数指定。</p>

<p><img src="/assets/res/hotspot-gc-collectors.png" alt="" /></p>

<p>上图中展示了新生代（年轻代）和老年代可用的各种垃圾收集器，图中的连线表示两种收集器可以配合使用。</p>

<ul>
<li>Serial收集器，单线程收集，复制算法</li>
<li>ParNew收集器，Serial收集器的多线程版本</li>
<li>Parallel Scavenge收集器，复制算法，吞吐量优先的收集器，更高效率地利用CPU时间，适合用于服务器程序</li>
<li>Serial Old收集器，单线程收集，标记整理算法</li>
<li>Parallel Old收集器，标记整理算法，Parallel Scavenge收集器的老年代版本</li>
<li>CMS(Concurrent Mark Sweep)收集器，标记清除算法，以获取最短停顿时间为目标的收集器</li>
<li>G1收集器，较新的收集器实现</li>
</ul>


<p>JVM有些参数组合了各种收集器，例如：</p>

<ul>
<li><code>UseConcMarkSweepGC</code>：使用ParNew + CMS + Serial Old收集器</li>
<li><code>UseParallelGC</code>，运行在server模式下的默认值，使用Parallel Scavenge + Serial Old 收集器</li>
</ul>


<h2>GC日志</h2>

<p>生产服务器一般会配置GC日志，以在故障时能够分析问题所在，一般的应用可配置以下JVM参数：</p>

<pre><code>-XX:+UseParallelGC -XX:+DisableExplicitGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:./logs/gc.log 
</code></pre>

<p>输出日志类似：</p>

<pre><code>1456772.057: [GC [PSYoungGen: 33824K-&gt;96K(33920K)] 53841K-&gt;20113K(102208K), 0.0025050 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
1456863.534: [GC [PSYoungGen: 33824K-&gt;96K(33920K)] 53841K-&gt;20113K(102208K), 0.0020050 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
1456962.061: [GC [PSYoungGen: 33824K-&gt;128K(33920K)] 53841K-&gt;20145K(102208K), 0.0014150 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]
</code></pre>

<ul>
<li><code>1456772.057</code>，自JVM启动后的时间值</li>
<li><code>GC</code> 表示本次进行的是一次minor GC，即年轻代中的GC</li>
<li><code>PSYoungGen</code> 垃圾收集器类型，这里是Parallel Scavenge</li>
<li><code>33824K-&gt;96K(33920K)</code>，收集前后新生代大小，<code>33920K</code>为新生代总大小(eden+ 1 survivor)</li>
<li><code>53841K-&gt;20113K(102208K)</code>，堆总大小及GC前后大小</li>
<li><code>0.0025050 secs</code>，GC时停顿时间</li>
</ul>


<h2>常见策略</h2>

<p>JVM GC相关的有一些策略值得注意：</p>

<ul>
<li>对象优先在eden分配，当回收时（Eden区可用内存不够），将Eden和当前Survivor还存活着的对象一次性复制到另外一块Survivor，最后清理Eden和刚才用过的Survivor。这个过程称为一次MinorGC，每次MinorGC就会增加活着对象的年龄，当年龄超过某值(-XX:MaxTenuringThreashold)时，就会被转移到老年代(Tenured)。老年代发生GC时被称为FullGC</li>
<li>每一次发生MinorGC而存活下来的对象其年龄都会加1，较老的对象会进入老年代</li>
<li>当分配大对象(> PretenureSizeThreshold)时，其就会直接进入老年代</li>
<li>当年轻代(Eden+Survivor)不足以容纳存活对象时，这些对象会被全部放入老年代(分配担保机制)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[写了一个分布式名字服务JCM]]></title>
    <link href="http://codemacro.com/2015/07/04/jcm/"/>
    <updated>2015-07-04T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/07/04/jcm</id>
    <content type="html"><![CDATA[<p>之前在公司里维护了一个名字服务，这个名字服务日常管理了近4000台机器，有4000个左右的客户端连接上来获取机器信息，由于其基本是一个单点服务，所以某些模块接近瓶颈。后来倒是有重构计划，详细设计做了，代码都写了一部分，结果由于某些原因重构就被终止了。</p>

<p><a href="https://github.com/kevinlynx/jcm">JCM</a>是我业余时间用Java重写的一个版本，功能上目前只实现了基础功能。由于它是个完全分布式的架构，所以理论上可以横向扩展，大大增强系统的服务能力。</p>

<h2>名字服务</h2>

<p>在分布式系统中，某个服务为了提升整体服务能力，通常部署了很多实例。这里我把这些提供相同服务的实例统称为集群(<code>cluster</code>)，每个实例称为一个节点(<code>Node</code>)。一个应用可能会使用很多cluster，每次访问一个cluster时，就通过名字服务获取该cluster下一个可用的node。那么，名字服务至少需要包含的功能：</p>

<ul>
<li>根据cluster名字获取可用的node</li>
<li>对管理的所有cluster下的所有node进行健康度的检测，以保证始终返回可用的node</li>
</ul>


<p>有些名字服务仅对node管理，不参与应用与node间的通信，而有些则可能作为应用与node间的通信转发器。虽然名字服务功能简单，但是要做一个分布式的名字服务还是比较复杂的，因为数据一旦分布式了，就会存在同步、一致性问题的考虑等。</p>

<h2>What&rsquo;s JCM</h2>

<p>JCM围绕前面说的名字服务基础功能实现。包含的功能：</p>

<ul>
<li>管理cluster到node的映射</li>
<li>分布式架构，可水平扩展以实现管理10,000个node的能力，足以管理一般公司的后台服务集群</li>
<li>对每个node进行健康检查，健康检查可基于HTTP协议层的检测或TCP连接检测</li>
<li>持久化cluster/node数据，通过zookeeper保证数据一致性</li>
<li>提供JSON HTTP API管理cluster/node数据，后续可提供Web管理系统</li>
<li>以库的形式提供与server的交互，库本身提供各种负载均衡策略，保证对一个cluster下node的访问达到负载均衡</li>
</ul>


<p>项目地址<a href="https://github.com/kevinlynx/jcm">git jcm</a></p>

<p>JCM主要包含两部分：</p>

<ul>
<li>jcm.server，JCM名字服务，需要连接zookeeper以持久化数据</li>
<li>jcm.subscriber，客户端库，负责与jcm.server交互，提供包装了负载均衡的API给应用使用</li>
</ul>


<!-- more -->


<h3>架构</h3>

<p>基于JCM的系统整体架构如下：</p>

<p><img src="https://raw.githubusercontent.com/kevinlynx/jcm/master/doc/asset/simple-arch.jpg" alt="simple-arch.jpg" /></p>

<p>cluster本身是不需要依赖JCM的，要通过JCM使用这些cluster，只需要通过JCM HTTP API注册这些cluster到jcm.server上。要通过jcm.server使用这些cluster，则是通过jcm.subscriber来完成。</p>

<h3>使用</h3>

<p>可参考<a href="https://github.com/kevinlynx/jcm/blob/master/README.md">git READMe.md</a></p>

<p>需要jre1.7+</p>

<ol>
<li>启动zookeeper</li>
<li>下载jcm.server <a href="https://github.com/kevinlynx/jcm/tree/master/dist">git jcm.server-0.1.0.jar</a></li>
<li>在<code>jcm.server-0.1.0.jar</code>目录下建立<code>config/application.properties</code>文件进行配置，参考<a href="https://github.com/kevinlynx/jcm/blob/master/jcm.server/config/application.properties">config/application.properties</a></li>
<li><p>启动jcm.server</p>

<pre><code> java -jar jcm.server-0.1.0.jar
</code></pre></li>
<li><p>注册需要管理的集群，参考cluster描述：<a href="https://github.com/kevinlynx/jcm/blob/master/doc/cluster_sample.json">doc/cluster_sample.json</a>，通过HTTP API注册：</p>

<pre><code> curl -i -X POST http://10.181.97.106:8080/c -H "Content-Type:application/json" --data-binary @./doc/cluster_sample.json
</code></pre></li>
</ol>


<p>部署好了jcm.server，并注册了cluster后，就可以通过jcm.subscriber使用：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 传入需要使用的集群名hello9/hello，以及传入jcm.server地址，可以多个：127.0.0.1:8080</span>
<span class="n">Subscriber</span> <span class="n">subscriber</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Subscriber</span><span class="o">(</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="mf">127.0</span><span class="o">.</span><span class="mf">0.1</span><span class="o">:</span><span class="mi">8080</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;),</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">hello9</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">hello</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;));</span>
<span class="c1">// 使用轮询负载均衡策略</span>
<span class="n">RRAllocator</span> <span class="n">rr</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">RRAllocator</span><span class="o">();</span>
<span class="n">subscriber</span><span class="o">.</span><span class="na">addListener</span><span class="o">(</span><span class="n">rr</span><span class="o">);</span>
<span class="n">subscriber</span><span class="o">.</span><span class="na">startup</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// rr.alloc 根据cluster名字获取可用的node</span>
  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">rr</span><span class="o">.</span><span class="na">alloc</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">hello9</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="n">ProtoType</span><span class="o">.</span><span class="na">HTTP</span><span class="o">));</span>
<span class="o">}</span>
<span class="n">subscriber</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span></code></pre></div></p>

<h2>JCM实现</h2>

<p>JCM目前的实现比较简单，参考模块图：</p>

<p><img src="https://raw.githubusercontent.com/kevinlynx/jcm/master/doc/asset/impl-module.jpg" alt="impl-module" /></p>

<ul>
<li>model，即cluster/node这些数据结构的描述，同时被jcm.server和jcm.subscriber依赖</li>
<li>storage，持久化数据到zookeeper，同时包含jcm.server实例之间的数据同步</li>
<li>health check，健康检查模块，对各个node进行健康检查</li>
</ul>


<p>以上模块都不依赖Spring，基于以上模块又有：</p>

<ul>
<li>http api，使用spring-mvc，包装了一些JSON HTTP API</li>
<li>Application，基于spring-boot，将各个基础模块组装起来，提供standalone的模式启动，不用部署到tomcat之类的servlet容器中</li>
</ul>


<p>jcm.subscriber的实现更简单，主要是负责与jcm.server进行通信，以更新自己当前的model层数据，同时提供各种负载均衡策略接口：</p>

<ul>
<li>subscriber，与jcm.server通信，定期增量拉取数据</li>
<li>node allocator，通过listener方式从subscriber中获取数据，同时实现各种负载均衡策略，对外统一提供<code>alloc node</code>的接口</li>
</ul>


<p>接下来看看关键功能的实现</p>

<h3>数据同步</h3>

<p>既然jcm.server是分布式的，每一个jcm.server instance(实例)都是支持数据读和写的，那么当jcm.server管理着一堆cluster上万个node时，每一个instance是如何进行数据同步的？jcm.server中的数据主要有两类：</p>

<ul>
<li>cluster本身的数据，包括cluster/node的描述，例如cluster name、node IP、及其他附属数据</li>
<li>node健康检查的数据</li>
</ul>


<p>对于cluster数据，因为cluster对node的管理是一个两层的树状结构，而对cluster有增删node的操作，所以并不能在每一个instance上都提供真正的数据写入，这样会导致数据丢失。假设同一时刻在instance A和instance B上同时对cluster c1添加节点N1和N2，那么instance A写入c1(N1)，而instance B还没等到数据同步就写入c1(N2)，那么c1(N1)就被覆盖为c1(N2)，从而导致添加的节点N1丢失。</p>

<p>所以，jcm.server instance是分为<code>leader</code>和<code>follower</code>的，真正的写入操作只有leader进行，follower收到写操作请求时转发给leader。leader写数据优先更新内存中的数据再写入zookeeper，内存中的数据更新当然是需要加锁互斥的，从而保证数据的正确性。</p>

<p><img src="https://raw.githubusercontent.com/kevinlynx/jcm/master/doc/asset/write-watch.jpg" alt="write-watch.jpg" /></p>

<p>leader和follower是如何确定角色的？这个很简单，标准的利用zookeeper来进行主从<a href="https://github.com/kevinlynx/jcm/blob/master/jcm.server/src/main/java/com/codemacro/jcm/util/ZookeeperLeaderElector.java">选举的实现</a>。</p>

<p>jcm.server instance数据间的同步是基于zookeeper watch机制的。这个可以算做是一个JCM的一个瓶颈，每一个instance都会作为一个watch，使得实际上jcm.server并不能无限水平扩展，扩展到一定程度后，watch的效率就可能不足以满足性能了，参考<a href="http://codemacro.com/2014/09/21/zk-watch-benchmark/">zookeeper节点数与watch的性能测试</a> (那个时候我就在考虑对我们系统的重构了) 。</p>

<p>jcm.server中对node健康检查的数据采用同样的同步机制，但node健康检查数据是每一个instance都会写入的，下面看看jcm.server是如何通过分布式架构来分担压力的。</p>

<h3>健康检查</h3>

<p>jcm.server的另一个主要功能的是对node的健康检查，jcm.server集群可以管理几万的node，既然已经是分布式了，那么显然是要把node均分到多个instance的。这里我是以cluster来分配的，方法就是简单的使用一致性哈希。通过一致性哈希，决定一个cluster是否属于某个instance负责。每个instance都有一个server spec，也就是该instance对外提供服务的地址(IP+port)，这样在任何一个instance上，它看到的所有instance server spec都是相同的，从而保证在每一个instance上计算cluster的分配得到的结果都是一致的。</p>

<p>健康检查按cluster划分，可以简化数据的写冲突问题，在正常情况下，每个instance写入的健康检查结果都是不同的。</p>

<p><img src="https://raw.githubusercontent.com/kevinlynx/jcm/master/doc/asset/health-check.jpg" alt="health-check.jpg" /></p>

<p>健康检查一般以1秒的频率进行，jcm.server做了优化，当检查结果和上一次一样时，并不写入zookeeper。写入的数据包含了node的完整key (IP+Port+Spec)，这样可以简化很多地方的数据同步问题，但会增加写入数据的大小，写入数据的大小是会影响zookeeper的性能的，所以这里简单地对数据进行了压缩。</p>

<p>健康检查是可以支持多种检查实现的，目前只实现了HTTP协议层的检查。健康检查自身是单个线程，在该线程中基于异步HTTP库，发起异步请求，实际的请求在其他线程中发出。</p>

<h3>jcm.subscriber通信</h3>

<p>jcm.subscriber与jcm.server通信，主要是为了获取最新的cluster数据。subscriber初始化时会拿到一个jcm.server instance的地址列表，访问时使用轮询策略以平衡jcm.server在处理请求时的负载。subscriber每秒都会请求一次数据，请求中描述了本次请求想获取哪些cluster数据，同时携带一个cluster的version。每次cluster在server变更时，version就变更（时间戳）。server回复请求时，如果version已最新，只需要回复node的状态。</p>

<p>subscriber可以拿到所有状态的node，后面可以考虑只拿正常状态的node，进一步减少数据大小。</p>

<h2>压力测试</h2>

<p>目前只对健康检查部分做了压测，详细参考<a href="https://github.com/kevinlynx/jcm/blob/master/test/beanchmark/benchmark.md">test/benchmark.md</a>。在A7服务器上测试，发现写zookeeper及zookeeper的watch足以满足要求，jcm.server发起的HTTP请求是主要的性能热点，单jcm.server instance大概可以承载20000个node的健康监测。</p>

<p>网络带宽：</p>

<pre><code>Time              ---------------------traffic--------------------
Time               bytin  bytout   pktin  pktout  pkterr  pktdrp
01/07/15-21:30:48   3.2M    4.1M   33.5K   34.4K    0.00    0.00
01/07/15-21:30:50   3.3M    4.2M   33.7K   35.9K    0.00    0.00
01/07/15-21:30:52   2.8M    4.1M   32.6K   41.6K    0.00    0.00
</code></pre>

<p>CPU，通过jstack查看主要的CPU消耗在HTTP库实现层，以及健康检查线程：</p>

<pre><code>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
13301 admin     20   0 13.1g 1.1g  12m R 76.6  2.3   2:40.74 java         httpchecker
13300 admin     20   0 13.1g 1.1g  12m S 72.9  2.3   0:48.31 java
13275 admin     20   0 13.1g 1.1g  12m S 20.1  2.3   0:18.49 java
</code></pre>

<p>代码中增加了些状态监控：</p>

<pre><code>checker HttpChecker stat count 20 avg check cost(ms) 542.05, avg flush cost(ms) 41.35
</code></pre>

<p>表示平均每次检查耗时542毫秒，写数据因为开启了cache没有参考价值。</p>

<p>虽然还可以从我自己的代码中做不少优化，但既然单机可以承载20000个节点的检测，一般的应用远远足够了。</p>

<h2>总结</h2>

<p>名字服务在分布式系统中虽然是基础服务，但往往承担了非常重要的角色，数据同步出现错误、节点状态出现瞬时的错误，都可能对整套系统造成较大影响，业务上出现较大故障。所以名字服务的健壮性、可用性非常重要。实现中需要考虑很多异常情况，包括网络不稳定、应用层的错误等。为了提高足够的可用性，一般还会加多层的数据cache，例如subscriber端的本地cache，server端的本地cache，以保证在任何情况下都不会影响应用层的服务。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于servlet实现一个web框架]]></title>
    <link href="http://codemacro.com/2015/06/07/servlet-web-framework/"/>
    <updated>2015-06-07T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/06/07/servlet-web-framework</id>
    <content type="html"><![CDATA[<p>servlet作为一个web规范，其本身就算做一个web开发框架，但是其web action (响应某个URI的实现)的实现都是基于类的，不是很方便，并且3.0之前的版本还必须通过web.xml配置来增加新的action。servlet中有一个filter的功能，可以配置所有URI的功能都经过filter。我们可以基于filter的功能来实现一个简单的web框架。在这个框架中，主要改进URI action的映射，就像<a href="https://www.playframework.com/">play framework</a>中route的配置：</p>

<pre><code>GET     /hello      com.codemacro.webdemo.test.TestController.hello
GET     /route      com.codemacro.webdemo.test.TestController.route
POST    /hello      com.codemacro.webdemo.test.TestController.sayHello
</code></pre>

<p>即把某个URI映射到类接口级别。基于servlet实现web框架的好处不仅实现简单，还能运行在所有支持servlet容器规范的web server上，例如Tomcat、Jetty。</p>

<p>本文提到的web framework demo可以从我的github 上取得：<a href="https://github.com/kevinlynx/servlet-web-framework-demo">servlet-web-framework-demo</a></p>

<h2>功能</h2>

<p>这个web framework URI action部分（或者说URI routing）如同前面描述，action的编写如：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestController</span> <span class="kd">extends</span> <span class="n">BaseController</span> <span class="o">{</span>
  <span class="c1">// 返回字符串</span>
  <span class="kd">public</span> <span class="n">Result</span> <span class="nf">index</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">ok</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">hello</span> <span class="n">world</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;);</span>
  <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="c1">// HTTP 404</span>
  <span class="kd">public</span> <span class="n">Result</span> <span class="nf">code404</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">status</span><span class="o">(</span><span class="mi">404</span><span class="o">,</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">not</span> <span class="n">found</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;);</span>
  <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="c1">// 使用JSP模板渲染</span>
  <span class="kd">public</span> <span class="n">Result</span> <span class="nf">template</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">String</span><span class="o">[]</span> <span class="n">langs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[]</span> <span class="o">{&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">c</span><span class="o">++&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">java</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">python</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;};</span>
    <span class="k">return</span> <span class="nf">ok</span><span class="o">(</span><span class="n">jsp</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">index</span><span class="o">.</span><span class="na">jsp</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;)</span>
        <span class="o">.</span><span class="na">put</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">name</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">kevin</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;)</span>
        <span class="o">.</span><span class="na">put</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">langs</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span>  <span class="n">langs</span><span class="o">)</span>
        <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div></p>

<!-- more -->


<p>有了action之后，配置<code>route</code>文件映射URI即可：</p>

<pre><code>GET /index  com.codemacro.webdemo.test.TestController.index
GET /404    com.codemacro.webdemo.test.TestController.code404
GET /index.jsp com.codemacro.webdemo.test.TestController.template
</code></pre>

<p>然后配置<code>web.xml</code>，增加一个filter：</p>

<pre><code>&lt;filter&gt;
  &lt;filter-name&gt;MyWebFilter&lt;/filter-name&gt;
  &lt;filter-class&gt;com.codemacro.webdemo.MyServletFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
  &lt;filter-name&gt;MyWebFilter&lt;/filter-name&gt;
  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>

<p>最后以war的形式部署到Jetty <code>webapps</code>下即可运行。想想下次要再找个什么lightweight Java web framework，直接用这个demo就够了。接下来讲讲一些关键部分的实现。</p>

<h2>servlet basic</h2>

<p>基于servlet开发的话，引入servlet api是必须的：</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
    &lt;version&gt;2.5&lt;/version&gt;
    &lt;type&gt;jar&lt;/type&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<p>servlet filter的接口包含：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyServletFilter</span> <span class="kd">implements</span> <span class="n">Filter</span> <span class="o">{</span>
  <span class="c1">// web app启动时调用一次，可用于web框架初始化</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">(</span><span class="n">FilterConfig</span> <span class="n">conf</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ServletException</span> <span class="o">{</span> <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="c1">// 满足filter url-pattern时就会调用；req/res分别对应HTTP请求和回应</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doFilter</span><span class="o">(</span><span class="n">ServletRequest</span> <span class="n">req</span><span class="o">,</span> <span class="n">ServletResponse</span> <span class="n">res</span><span class="o">,</span>
    <span class="n">FilterChain</span> <span class="n">chain</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">ServletException</span> <span class="o">{</span> <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>
<span class="o">}</span></code></pre></div></p>

<p><code>init</code>接口可用于启动时载入<code>routes</code>配置文件，并建立URI到action的映射。</p>

<h2>action manager</h2>

<p><code>ActionManager</code>负责启动时载入<code>routes</code>配置，建立URI到action的映射。一个URI包含了HTTP method和URI String，例如<code>GET /index</code>。action既然映射到了类接口上，那么可以在启动时就同过Java反射找到对应的类及接口。简单起见，每次收到URI的请求时，就创建这个类对应的对象，然后调用映射的接口即可。</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 例如：registerAction(&amp;ldquo;com.codemacro.webdemo.test.TestController&amp;rdquo;, &amp;ldquo;index&amp;rdquo;, &amp;ldquo;/index&amp;rdquo;, &amp;ldquo;GET&amp;rdquo;);</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">registerAction</span><span class="o">(</span><span class="n">String</span> <span class="n">clazName</span><span class="o">,</span> <span class="n">String</span> <span class="n">methodName</span><span class="o">,</span> <span class="n">String</span> <span class="n">uri</span><span class="o">,</span> <span class="n">String</span> <span class="n">method</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="n">uri</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;/&amp;</span><span class="n">rdquo</span><span class="o">;</span> <span class="o">+</span> <span class="n">appName</span> <span class="o">+</span> <span class="n">uri</span><span class="o">;</span>
    <span class="c1">// 载入对应的class</span>
    <span class="n">Class</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?</span> <span class="kd">extends</span> <span class="n">BaseController</span><span class="o">&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="o">(</span><span class="n">Class</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?</span> <span class="kd">extends</span> <span class="n">BaseController</span><span class="o">&gt;)</span> <span class="n">loadClass</span><span class="o">(</span><span class="n">clazName</span><span class="o">);</span>
    <span class="c1">// 取得对应的接口</span>
    <span class="n">Method</span> <span class="n">m</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="n">methodName</span><span class="o">,</span> <span class="o">(</span><span class="n">Class</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?&gt;[])</span><span class="kc">null</span><span class="o">);</span>
    <span class="c1">// 接口要求必须返回Result</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">getReturnType</span><span class="o">()</span> <span class="o">!=</span> <span class="n">Result</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">action</span> <span class="n">method</span> <span class="k">return</span> <span class="n">type</span> <span class="nl">mismatch:</span> <span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;</span> <span class="o">+</span> <span class="n">uri</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">ActionKey</span> <span class="n">k</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ActionKey</span><span class="o">(</span><span class="n">uri</span><span class="o">,</span> <span class="n">getMethod</span><span class="o">(</span><span class="n">method</span><span class="o">));</span>
    <span class="n">ActionValue</span> <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ActionValue</span><span class="o">(</span><span class="n">clazz</span><span class="o">,</span> <span class="n">m</span><span class="o">);</span>
    <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">register</span> <span class="n">action</span> <span class="o">{}</span> <span class="o">{}</span> <span class="o">{}</span> <span class="o">{}&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="n">clazName</span><span class="o">,</span> <span class="n">methodName</span><span class="o">,</span> <span class="n">uri</span><span class="o">,</span> <span class="n">method</span><span class="o">);</span>
    <span class="c1">// 建立映射</span>
    <span class="n">actions</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">registerAction</span> <span class="nl">failed:</span> <span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;</span> <span class="o">+</span> <span class="n">uri</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div></p>

<p>controller都要求派生于<code>BaseController</code>，这样才可以利用<code>BaseController</code>更方便地获取请求数据之类，例如query string/cookie 等。</p>

<p>收到请求时，就需要根据请求的HTTP Method和URI string取得之前建立的映射，并调用之：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">req</span><span class="o">,</span> <span class="n">HttpServletResponse</span> <span class="n">resp</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
  <span class="n">String</span> <span class="n">uri</span> <span class="o">=</span> <span class="n">req</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">();</span>
  <span class="n">String</span> <span class="n">method</span> <span class="o">=</span> <span class="n">req</span><span class="o">.</span><span class="na">getMethod</span><span class="o">().</span><span class="na">toUpperCase</span><span class="o">();</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="c1">// 取得之前建立的映射，Map查找</span>
    <span class="n">ActionValue</span> <span class="n">v</span> <span class="o">=</span> <span class="n">getAction</span><span class="o">(</span><span class="n">uri</span><span class="o">,</span> <span class="n">method</span><span class="o">);</span>
    <span class="c1">// 创建新的controller对象</span>
    <span class="n">BaseController</span> <span class="n">ctl</span> <span class="o">=</span> <span class="o">(</span><span class="n">BaseController</span><span class="o">)</span> <span class="n">v</span><span class="o">.</span><span class="na">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
    <span class="n">ctl</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">resp</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
    <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">invoke</span> <span class="n">action</span> <span class="o">{}&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="n">uri</span><span class="o">);</span>
    <span class="c1">// 调用绑定的接口</span>
    <span class="n">Result</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="n">Result</span><span class="o">)</span> <span class="n">v</span><span class="o">.</span><span class="na">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">ctl</span><span class="o">,</span> <span class="o">(</span><span class="n">Object</span><span class="o">[])</span> <span class="kc">null</span><span class="o">);</span>
    <span class="c1">// 渲染结果</span>
    <span class="n">result</span><span class="o">.</span><span class="na">render</span><span class="o">();</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">&amp;</span><span class="n">hellip</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div></p>

<h2>结果渲染</h2>

<p>结果渲染无非就是把框架用户返回的结果渲染为字符串，写进<code>HttpServletResponse</code>。这个渲染过程可以是直接的<code>Object.toString</code>，或者经过模板引擎渲染，或者格式化为JSON。</p>

<p>通过实现具体的<code>Result</code>类，可以扩展不同的渲染方式，例如最基础的<code>Result</code>就是调用返回对象的<code>toString</code>：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Result</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">render</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">ServletException</span> <span class="o">{</span>
    <span class="n">PrintWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">getWriter</span><span class="o">();</span>
    <span class="c1">// result是controller action里返回的</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div></p>

<p>为了简单，不引入第三方库，可以直接通过JSP来完成。JSP本身在servlet容器中就会被编译成一个servlet对象。</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JSPResult</span> <span class="kd">extends</span> <span class="n">Result</span> <span class="o">{</span>
  <span class="o">&amp;</span><span class="n">hellip</span><span class="o">;</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">render</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">ServletException</span> <span class="o">{</span>
    <span class="c1">// 传入一些对象到模板中</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">content</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">request</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="c1">// 委托给JSP来完成渲染</span>
    <span class="n">request</span><span class="o">.</span><span class="na">getRequestDispatcher</span><span class="o">(</span><span class="n">file</span><span class="o">).</span><span class="na">forward</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div></p>

<p>JSP中可以使用传统的scriptlets表达式，也可以使用新的EL方式，例如：</p>

<pre><code>&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%&gt;
&lt;h4&gt;By EL&lt;/h4&gt;
&lt;c:forEach var="lang" items="${langs}"&gt;
  &lt;span&gt;${lang}&lt;/span&gt;|
&lt;/c:forEach&gt;

&lt;% String[] langs = (String[]) request.getAttribute("langs"); %&gt;
&lt;% if (langs != null) { %&gt;
&lt;% for (String lang : langs) { %&gt;
  &lt;span&gt;&lt;%= lang %&gt;&lt;/span&gt;|
&lt;% } } %&gt;
</code></pre>

<p>使用EL的话需要引入<code>&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%&gt;</code></p>

<h2>BaseController</h2>

<p><code>BaseController</code>是一种template pattern实现，其包装了一些方便的接口给具体的controller使用，例如：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BaseController</span> <span class="o">{</span>
  <span class="c1">// 取得/index?name=kevin中的name参数值</span>
  <span class="kd">protected</span> <span class="n">String</span> <span class="nf">getQueryString</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">request</span><span class="o">.</span><span class="na">getParameter</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
  <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="kd">protected</span> <span class="n">Result</span> <span class="nf">status</span><span class="o">(</span><span class="kt">int</span> <span class="n">code</span><span class="o">,</span> <span class="n">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">response</span><span class="o">.</span><span class="na">setStatus</span><span class="o">(</span><span class="n">code</span><span class="o">);</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">Result</span><span class="o">(</span><span class="n">response</span><span class="o">,</span> <span class="n">text</span><span class="o">);</span>
  <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="c1">// 默认是HTTP 200</span>
  <span class="kd">protected</span> <span class="n">Result</span> <span class="nf">ok</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">Result</span><span class="o">(</span><span class="n">response</span><span class="o">,</span> <span class="n">obj</span><span class="o">);</span>
  <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="kd">protected</span> <span class="n">Result</span> <span class="nf">ok</span><span class="o">(</span><span class="n">Result</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
  <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="kd">protected</span> <span class="n">JSPResult</span> <span class="nf">jsp</span><span class="o">(</span><span class="n">String</span> <span class="n">file</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">JSPResult</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">,</span> <span class="n">file</span><span class="o">,</span> <span class="n">actionMgr</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div></p>

<h2>Reverse routing</h2>

<p>Reverse routing指的是在开发web过程中，要引入某个URL时，我们不是直接写这个URL字符串，而是写其映射的接口，以使代码更易维护（因为URL可能会随着项目进展而改变）。并且，servlet app部署后URL会带上这个app的名字前缀，例如<code>/web-demo/index</code>中的<code>/web-demo</code>。在模板文件中，例如要链接到其他URI，更好的方式当然是直接写<code>/index</code>。</p>

<p>这里的实现比较丑陋，还是基于字符串的形式，例如：</p>

<pre><code>&lt;a href='&lt;route:reverse action="com.codemacro.webdemo.test.TestController.hello" name="kevin"/&gt;'&gt;index&lt;/a&gt;
</code></pre>

<p>通过自定义一个EL function <code>reverse</code>来实现。这里需要引入一个JSP的库：</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
    &lt;version&gt;2.0&lt;/version&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>

<p>首先实现一个<code>SimpleTagSupport</code>，为了支持<code>?name=kevin</code>这种动态参数，还需要<code>implements DynamicAttributes</code>：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JSPRouteTag</span> <span class="kd">extends</span> <span class="n">SimpleTagSupport</span> <span class="kd">implements</span> <span class="n">DynamicAttributes</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="c1">// 输出最终的URL</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doTag</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="n">JspContext</span> <span class="n">context</span> <span class="o">=</span> <span class="n">getJspContext</span><span class="o">();</span>
    <span class="n">ActionManager</span> <span class="n">actionMgr</span> <span class="o">=</span> <span class="o">(</span><span class="n">ActionManager</span><span class="o">)</span> <span class="n">context</span><span class="o">.</span><span class="na">findAttribute</span><span class="o">(</span><span class="n">ACTION_MGR</span><span class="o">);</span>
    <span class="n">JspWriter</span> <span class="n">out</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getOut</span><span class="o">();</span>
    <span class="n">String</span> <span class="n">uri</span> <span class="o">=</span> <span class="n">actionMgr</span><span class="o">.</span><span class="na">getReverseAction</span><span class="o">(</span><span class="n">action</span><span class="o">,</span> <span class="n">attrMap</span><span class="o">);</span>
    <span class="n">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">uri</span><span class="o">);</span>
  <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="nd">@Override</span>
  <span class="c1">// name=&amp;ldquo;kevin&amp;rdquo; 时调用</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDynamicAttribute</span><span class="o">(</span><span class="n">String</span> <span class="n">uri</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Object</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">JspException</span> <span class="o">{</span>
    <span class="n">attrMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
  <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="c1">// &lt;code&gt;action=&quot;xxx&quot;&lt;/code&gt; 时会调用&lt;code&gt;setAction&lt;/code&gt;</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAction</span><span class="o">(</span><span class="n">String</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">action</span> <span class="o">=</span> <span class="n">action</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div></p>

<p>为了访问到<code>ActionManager</code>，这里是通过写到<code>Request context</code>中实现的，相当hack。</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">JSPResult</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">req</span><span class="o">,</span> <span class="n">HttpServletResponse</span> <span class="n">resp</span><span class="o">,</span> <span class="n">String</span> <span class="n">file</span><span class="o">,</span>
    <span class="n">ActionManager</span> <span class="n">actionMgr</span><span class="o">)</span> <span class="o">{</span>
  <span class="kd">super</span><span class="o">(</span><span class="n">resp</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
  <span class="o">..</span>
  <span class="n">put</span><span class="o">(</span><span class="n">JSPRouteTag</span><span class="o">.</span><span class="na">ACTION_MGR</span><span class="o">,</span> <span class="n">actionMgr</span><span class="o">);</span>
<span class="o">}</span></code></pre></div></p>

<p>第二步增加一个描述这个新tag的文件 <code>WEB-INF/route_tag.tld</code>：</p>

<pre><code>&lt;taglib&gt;
    &lt;tlibversion&gt;1.0&lt;/tlibversion&gt;
    &lt;jspversion&gt;1.1&lt;/jspversion&gt;
    &lt;shortname&gt;URLRouteTags&lt;/shortname&gt;
    &lt;uri&gt;/myweb-router&lt;/uri&gt;
    &lt;info&gt;&lt;/info&gt;

    &lt;tag&gt;
        &lt;name&gt;reverse&lt;/name&gt;
        &lt;tagclass&gt;com.codemacro.webdemo.result.JSPRouteTag&lt;/tagclass&gt;
        &lt;bodycontent&gt;&lt;/bodycontent&gt;
        &lt;info&gt;&lt;/info&gt;
        &lt;attribute&gt;
            &lt;name&gt;action&lt;/name&gt;
            &lt;required&gt;true&lt;/required&gt;
        &lt;/attribute&gt;
        &lt;dynamic-attributes&gt;true&lt;/dynamic-attributes&gt;
    &lt;/tag&gt;
&lt;/taglib&gt;
</code></pre>

<p>最后在需要使用的JSP中引入这个自定义tag：</p>

<pre><code>&lt;%@ taglib prefix="route" uri="/myweb-router" %&gt;
</code></pre>

<h2>参考资料</h2>

<ul>
<li><a href="http://www.cnblogs.com/cuiliang/archive/2011/10/21/2220671.html">Servlet生命周期与工作原理</a></li>
<li><a href="http://www.blogjava.net/fancydeepin/archive/2013/09/30/fan_servlet.html">JSP/Servlet工作原理</a></li>
<li><a href="http://www.cnblogs.com/xushuai123/archive/2013/03/24/2979711.html">EL表达式</a></li>
<li><a href="http://www.codedata.com.tw/java/java-tutorial-the-3rd-class-3-servlet-jsp/">使用Servlet、JSP开发Web程序</a></li>
<li><a href="http://www.itzhai.com/java-web-notes-servlet-filters-in-the-filter-writing-the-introduction-and-use-of-filters.html#read-more">Java Web笔记 – Servlet中的Filter过滤器的介绍和使用 编写过滤器</a></li>
<li><a href="http://blog.csdn.net/bingduanlbd/article/details/38349737">实现一个简单的Servlet容器</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
