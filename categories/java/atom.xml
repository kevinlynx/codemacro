<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | loop in codes]]></title>
  <link href="http://codemacro.com/categories/java/atom.xml" rel="self"/>
  <link href="http://codemacro.com/"/>
  <updated>2015-09-05T10:51:24+08:00</updated>
  <id>http://codemacro.com/</id>
  <author>
    <name><![CDATA[Kevin Lynx]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java中隔离容器的实现]]></title>
    <link href="http://codemacro.com/2015/09/05/java-lightweight-container/"/>
    <updated>2015-09-05T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/09/05/java-lightweight-container</id>
    <content type="html"><![CDATA[<p>Java中隔离容器用于隔离各个依赖库环境，解决Jar包冲突问题。</p>

<h2>问题</h2>

<p>应用App依赖库LibA和LibB，而LibA和LibB又同时依赖LibBase，而LibA和LibB都是其他团队开发的，其中LibA发布了一个重要的修复版本，但是依赖LibBase v2.0，而LibB还没有升级版本，LibBase还不是兼容的，那么此时升级就会面临困难。在生产环境中这种情况往往更恶劣，可能是好几层的间接依赖关系。</p>

<p>隔离容器用于解决这种问题。它把LibA和LibB的环境完全隔离开来，LibBase即使类名完全相同也不互相冲突，使得LibA和LibB的升级互不影响。众所周知，Java中判定两个类是否相同，看的是类名和其对应的class loader，两者同时相同才表示相等。隔离容器正是利用这种特性实现的。</p>

<h2>KContainer</h2>

<p>这里我实现了一个demo，称为KContainer，源码见<a href="https://github.com/kevinlynx/kcontainer">github kcontainer</a>。这个container模仿了一些OSGI的东西，这里把LibA和LibB看成是两个bundle，bundle之间是互相隔离的，每个bundle有自己所依赖的第三方库，bundle之间的第三方库完全对外隐藏。bundle可以导出一些类给其他bundle用，bundle可以开启自己的服务。由于是个demo，我只实现关键的部分。</p>

<p>KContainer的目录结构类似：</p>

<pre><code>.
|-- bundle
    |-- test1
        |-- test1.prop
        |-- classes
        |-- lib
            |-- a.jar
            |-- b.jar
    |-- test2
        |-- test2.prop
        |-- classes
|-- lib
    |-- kcontainer.jar
    |-- kcontainer.interface.jar
</code></pre>

<p>bundle目录存放了所有会被自动载入的bundle。每一个bundle都有一个配置文件<code>bundle-name.prop</code>，用于描述自己导出哪些类，例如：</p>

<pre><code>init=com.codemacro.test.B
export-class=com.codemacro.test.Export; com.codemacro.test.Export2
</code></pre>

<p><code>init</code>指定bundle启动时需要调用的类，用户可以在这个类里开启自己的服务；<code>export-class</code>描述需要导出的类列表。bundle之间的所有类都是隔离的，但<code>export-class</code>会被统一放置，作为所有bundle共享的类。后面会描述KContainer如何处理类加载问题，这也是隔离容器的主要内容。</p>

<!-- more -->


<p>bundle依赖的类可以直接以<code>*.class</code>文件存放到<code>classes</code>目录，也可以作为<code>*.jar</code>放到<code>lib</code>目录。作为extra pratice，我还会把<code>*.jar</code>中的jar解压同时作为类加载的路径。</p>

<p>KContainer本身可以作为一个framework被使用。为了示例，我写了一个入口类，加载启动完所有bundle后就退出了，这个仅作为例子，用不了生产。</p>

<h2>隔离的核心实现</h2>

<p>隔离的目的是分开各个bundle中的类。利用的语言特性包括：</p>

<ul>
<li>class的区分由class name和载入其的class loader共同决定</li>
<li>当在class A中使用了class B时，JVM默认会用class A的class loader去加载class B</li>
<li>class loader中的双亲委托机制</li>
<li><code>URLClassLoader</code>会从指定的目录及*.jar中加载类</li>
</ul>


<p>KContainer的主要任务，就是为bundle实现一个自定义的class loader。</p>

<p>当KContainer加载一个bundle时，在处理其<code>export-class</code>或<code>init</code>时，都是需要加载bundle中的类的。在这之前，我给每一个bundle关联一个独立的<code>BundleClassLoader</code>。然后用这个class loader去加载bundle中的类，利用class loader传递特性，使得一个bundle中的所有类都是由其关联的class loader加载的，从而实现bundle之间类隔离效果。</p>

<p>实现class loader时，是实现<code>loadClass</code>还是<code>findClass</code>？通过实现<code>loadClass</code>我们可以改变class loader的双亲委托模式，制定加载类的具体顺序。但我的目的仅仅是隔离bundle，想了下其实实现<code>findClass</code>就可以达成目的。关于<code>loadClass</code>和<code>findClass</code>的区别可以参考这里 (<a href="http://blog.csdn.net/fenglibing/article/details/17471659">实现自己的类加载时，重写方法loadClass与findClass的区别</a>)。简单来说，就是<code>findClass</code>只有在类确实找不到的情况下才会被调用，在此之前，<code>loadClass</code>默认都是走的双亲委托模式。</p>

<p><code>BundleClassLoader</code>派生于<code>URLClassLoader</code>，默认的parent class loader就是<code>system class loader</code> (<code>app class loader</code>)。这使得KContainer中的bundle类加载有三层选择：自己的class path；其他bundle共享的classes；jvm的class path。通过实现<code>findClass</code>，在默认路径都无法加载到类时，才尝试bundle共享的class，优先级最低。</p>

<p>其实现大概为：</p>

<p>{% highlight java %}
public class BundleClassLoader extends URLClassLoader {
  public BundleClassLoader(File home, SharedClassList sharedClasses) {
    // getClassPath将bundle目录下的classes和各个jar作为class path传给URLClassLoader
    super(getClassPath(home));
    this.sharedClasses = sharedClasses;
  }</p>

<p>  @Override
  protected Class&lt;?> findClass(String name) throws ClassNotFoundException {
    logger.debug(&ldquo;try find class {}&rdquo;, name);
    Class&lt;?> claz = null;
    try {
      claz = super.findClass(name);
    } catch (ClassNotFoundException e) {
      claz = null;
    }
    if (claz != null) {
      logger.debug(&ldquo;load from class path for {}&rdquo;, name);
      return claz;
    }
    claz = sharedClasses.get(name);
    if (claz != null) {
      logger.debug(&ldquo;load from shared class for {}&rdquo;, name);
      return claz;
    }
    logger.warn(&ldquo;not found class {}&rdquo;, name);
    throw new ClassNotFoundException(name);
  }
}
{% endhighlight %}
完整代码参看<a href="https://github.com/kevinlynx/kcontainer/blob/master/kcontainer/src/main/java/com/codemacro/container/BundleClassLoader.java">BundleClassLoader.java</a></p>

<p>创建bundle时，会为其创建自己的class loader，并使用这个class loader来载入<code>export-class</code>和<code>init-class</code>：</p>

<p>{% highlight java %}
  public static Bundle create(File home, String name, SharedClassList sharedClasses,
      BundleConf conf) {
    BundleClassLoader loader = new BundleClassLoader(home, sharedClasses);
    List<String> exports = conf.getExportClassNames();
    if (exports != null) {
      logger.info(&ldquo;load exported classes for {}&rdquo;, name);
      loadExports(loader, sharedClasses, exports);
    }
    return new Bundle(name, conf.getInitClassName(), loader);
  }</p>

<p>  private static void loadExports(ClassLoader loader, SharedClassList sharedClasses,
      List<String> exports) {
      for (String claz_name: exports) {
        try {
          Class&lt;?> claz = loader.loadClass(claz_name); // 载入class
          sharedClasses.put(claz_name, claz);
        } catch (ClassNotFoundException e) {
          logger.warn(&ldquo;load class {} failed&rdquo;, claz_name);
        }
      }
  }
{% endhighlight %}</p>

<p>以上。</p>

<h2>扩展</h2>

<p>扩展的地方有很多，例如支持导出package，导出一个完整的jar。当然可能需要实现<code>loadClass</code>，以改变类加载的优先级，让共享类的优先级高于jvm class path的优先级。</p>

<h2>其他</h2>

<h3>线程ContextClassLoader</h3>

<p>提到class loader，我们看下最常接触的几类：</p>

<ul>
<li><code>XX.class.getClassLoader</code>，获取加载类<code>XX</code>的class loader</li>
<li><code>Thread.currentThread().getContextClassLoader()</code>，获取当前线程的ContextClassLoader</li>
<li><code>ClassLoader.getSystemClassLoader()</code>，获取system class loader</li>
</ul>


<p>system class loader的parent就是ext class loader，再上面就是bootstrap class loader了 (不是java类，实际获取不到)。默认情况下以上三个class loader都是一个：</p>

<p>{% highlight java %}
System.out.println(ClassLoader.getSystemClassLoader());
System.out.println(Main.class.getClassLoader());
System.out.println(Thread.currentThread().getContextClassLoader());
{% endhighlight %}</p>

<p>Output:</p>

<pre><code>sun.misc.Launcher$AppClassLoader@157c2bd
sun.misc.Launcher$AppClassLoader@157c2bd
sun.misc.Launcher$AppClassLoader@157c2bd
</code></pre>

<p>创建线程时，新的线程ContextClassLoader就是父线程的ContextClassLoader。在载入一个新的class时，推荐优先使用线程context class loader，例如框架<a href="http://jodd.org/">Jodd</a>中包装的。关于线程context class loader和<code>Class.getClassLoader</code>这里有个解释算是相对合理：<a href="http://www.xcoder.cn/html/web/j2ee/2013/0506/5557.html">ContextClassLoader浅析</a></p>

<p>即，当你把一个对象A传递到另一个线程中，这个线程由对象B创建，A/B两个对象对应的类关联的class loader不同，在B的线程中调用A.some_method，some_method加载资源或类时，如果使用了<code>Class.getClassLoader</code>或<code>Class.forName</code>时，实际使用的是A的class loader，而这个行为可能不是预期的。这个时候就需要将代码改为<code>Thread.currentThread().getContextClassLoader()</code>。</p>

<p>完。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java GC总结]]></title>
    <link href="http://codemacro.com/2015/08/10/java-gc-summary/"/>
    <updated>2015-08-10T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/08/10/java-gc-summary</id>
    <content type="html"><![CDATA[<p>Java GC相关的文章有很多，本文只做概要性总结，主要内容来源于&lt;深入理解Java虚拟机>。</p>

<h2>对象存活性判定</h2>

<p>对象存活性判定用于确定一个对象是死是活，死掉的对象则需要被垃圾回收。主要包括的方法：</p>

<ul>
<li>引用计数</li>
<li>可达性分析</li>
</ul>


<p>可达性分析的基本思想是：</p>

<blockquote><p>通过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链项链时，则证明此对象是不可用的。</p></blockquote>

<p>在Java中有很多种类的对象可以作为GC Roots，例如类静态属性引用的对象。</p>

<h2>垃圾收集算法</h2>

<p>确定了哪些对象是需要回收之后，就可以运用各种垃圾收集算法收集这些对象，例如直接回收内存，或者回收并移动整理内存。</p>

<p>主要包括：</p>

<ul>
<li>标记清除(Mark-Sweep)算法：首先标记出需要回收的对象，然后统一回收被标记的对象</li>
<li>复制(Copying)算法：将可用内存分块，当一块内存用完后将存活对象复制到其他块，并统一回收不使用的块。Java中新生代对象一般使用该方法</li>
<li>标记整理(Mark-Compact)算法：基本同标记清除，不同的是回收时是把可用对象进行移动，以避免内存碎片问题</li>
<li>分代收集，将内存分区域，不同区域采用不同的算法，例如Java中的新生代及老年代</li>
</ul>


<!-- more -->


<p><img src="/assets/res/heap-structure.png" alt="" /></p>

<p>如上，Java Hotspot虚拟机实现中将堆内存分为3大区域，即新生代、老年代、永久代。新生代中又分了eden、survivor0及survivor1，采用复制算法；老年代则采用标记清除及标记整理；永久代存放加载的类，类似于代码段，但同样会发生GC。</p>

<h2>垃圾收集器</h2>

<p>垃圾收集算法在实现时会略有不同，不同的实现称为垃圾收集器。不同的垃圾收集器适用的范围还不一样，有些收集器仅能用于新生代，有些用于老年代，有些新生代老年代都可以被使用。垃圾收集器可通过JVM启动参数指定。</p>

<p><img src="/assets/res/hotspot-gc-collectors.png" alt="" /></p>

<p>上图中展示了新生代（年轻代）和老年代可用的各种垃圾收集器，图中的连线表示两种收集器可以配合使用。</p>

<ul>
<li>Serial收集器，单线程收集，复制算法</li>
<li>ParNew收集器，Serial收集器的多线程版本</li>
<li>Parallel Scavenge收集器，复制算法，吞吐量优先的收集器，更高效率地利用CPU时间，适合用于服务器程序</li>
<li>Serial Old收集器，单线程收集，标记整理算法</li>
<li>Parallel Old收集器，标记整理算法，Parallel Scavenge收集器的老年代版本</li>
<li>CMS(Concurrent Mark Sweep)收集器，标记清除算法，以获取最短停顿时间为目标的收集器</li>
<li>G1收集器，较新的收集器实现</li>
</ul>


<p>JVM有些参数组合了各种收集器，例如：</p>

<ul>
<li><code>UseConcMarkSweepGC</code>：使用ParNew + CMS + Serial Old收集器</li>
<li><code>UseParallelGC</code>，运行在server模式下的默认值，使用Parallel Scavenge + Serial Old 收集器</li>
</ul>


<h2>GC日志</h2>

<p>生产服务器一般会配置GC日志，以在故障时能够分析问题所在，一般的应用可配置以下JVM参数：</p>

<pre><code>-XX:+UseParallelGC -XX:+DisableExplicitGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:./logs/gc.log 
</code></pre>

<p>输出日志类似：</p>

<pre><code>1456772.057: [GC [PSYoungGen: 33824K-&gt;96K(33920K)] 53841K-&gt;20113K(102208K), 0.0025050 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
1456863.534: [GC [PSYoungGen: 33824K-&gt;96K(33920K)] 53841K-&gt;20113K(102208K), 0.0020050 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
1456962.061: [GC [PSYoungGen: 33824K-&gt;128K(33920K)] 53841K-&gt;20145K(102208K), 0.0014150 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]
</code></pre>

<ul>
<li><code>1456772.057</code>，自JVM启动后的时间值</li>
<li><code>GC</code> 表示本次进行的是一次minor GC，即年轻代中的GC</li>
<li><code>PSYoungGen</code> 垃圾收集器类型，这里是Parallel Scavenge</li>
<li><code>33824K-&gt;96K(33920K)</code>，收集前后新生代大小，<code>33920K</code>为新生代总大小(eden+ 1 survivor)</li>
<li><code>53841K-&gt;20113K(102208K)</code>，堆总大小及GC前后大小</li>
<li><code>0.0025050 secs</code>，GC时停顿时间</li>
</ul>


<h2>常见策略</h2>

<p>JVM GC相关的有一些策略值得注意：</p>

<ul>
<li>对象优先在eden分配，当回收时（Eden区可用内存不够），将Eden和当前Survivor还存活着的对象一次性复制到另外一块Survivor，最后清理Eden和刚才用过的Survivor。这个过程称为一次MinorGC，每次MinorGC就会增加活着对象的年龄，当年龄超过某值(-XX:MaxTenuringThreashold)时，就会被转移到老年代(Tenured)。老年代发生GC时被称为FullGC</li>
<li>每一次发生MinorGC而存活下来的对象其年龄都会加1，较老的对象会进入老年代</li>
<li>当分配大对象(> PretenureSizeThreshold)时，其就会直接进入老年代</li>
<li>当年轻代(Eden+Survivor)不足以容纳存活对象时，这些对象会被全部放入老年代(分配担保机制)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[写了一个分布式名字服务JCM]]></title>
    <link href="http://codemacro.com/2015/07/04/jcm/"/>
    <updated>2015-07-04T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/07/04/jcm</id>
    <content type="html"><![CDATA[<p>之前在公司里维护了一个名字服务，这个名字服务日常管理了近4000台机器，有4000个左右的客户端连接上来获取机器信息，由于其基本是一个单点服务，所以某些模块接近瓶颈。后来倒是有重构计划，详细设计做了，代码都写了一部分，结果由于某些原因重构就被终止了。</p>

<p><a href="https://github.com/kevinlynx/jcm">JCM</a>是我业余时间用Java重写的一个版本，功能上目前只实现了基础功能。由于它是个完全分布式的架构，所以理论上可以横向扩展，大大增强系统的服务能力。</p>

<h2>名字服务</h2>

<p>在分布式系统中，某个服务为了提升整体服务能力，通常部署了很多实例。这里我把这些提供相同服务的实例统称为集群(<code>cluster</code>)，每个实例称为一个节点(<code>Node</code>)。一个应用可能会使用很多cluster，每次访问一个cluster时，就通过名字服务获取该cluster下一个可用的node。那么，名字服务至少需要包含的功能：</p>

<ul>
<li>根据cluster名字获取可用的node</li>
<li>对管理的所有cluster下的所有node进行健康度的检测，以保证始终返回可用的node</li>
</ul>


<p>有些名字服务仅对node管理，不参与应用与node间的通信，而有些则可能作为应用与node间的通信转发器。虽然名字服务功能简单，但是要做一个分布式的名字服务还是比较复杂的，因为数据一旦分布式了，就会存在同步、一致性问题的考虑等。</p>

<h2>What&rsquo;s JCM</h2>

<p>JCM围绕前面说的名字服务基础功能实现。包含的功能：</p>

<ul>
<li>管理cluster到node的映射</li>
<li>分布式架构，可水平扩展以实现管理10,000个node的能力，足以管理一般公司的后台服务集群</li>
<li>对每个node进行健康检查，健康检查可基于HTTP协议层的检测或TCP连接检测</li>
<li>持久化cluster/node数据，通过zookeeper保证数据一致性</li>
<li>提供JSON HTTP API管理cluster/node数据，后续可提供Web管理系统</li>
<li>以库的形式提供与server的交互，库本身提供各种负载均衡策略，保证对一个cluster下node的访问达到负载均衡</li>
</ul>


<p>项目地址<a href="https://github.com/kevinlynx/jcm">git jcm</a></p>

<p>JCM主要包含两部分：</p>

<ul>
<li>jcm.server，JCM名字服务，需要连接zookeeper以持久化数据</li>
<li>jcm.subscriber，客户端库，负责与jcm.server交互，提供包装了负载均衡的API给应用使用</li>
</ul>


<!-- more -->


<h3>架构</h3>

<p>基于JCM的系统整体架构如下：</p>

<p><img src="https://raw.githubusercontent.com/kevinlynx/jcm/master/doc/asset/simple-arch.jpg" alt="simple-arch.jpg" /></p>

<p>cluster本身是不需要依赖JCM的，要通过JCM使用这些cluster，只需要通过JCM HTTP API注册这些cluster到jcm.server上。要通过jcm.server使用这些cluster，则是通过jcm.subscriber来完成。</p>

<h3>使用</h3>

<p>可参考<a href="https://github.com/kevinlynx/jcm/blob/master/README.md">git READMe.md</a></p>

<p>需要jre1.7+</p>

<ol>
<li>启动zookeeper</li>
<li>下载jcm.server <a href="https://github.com/kevinlynx/jcm/tree/master/dist">git jcm.server-0.1.0.jar</a></li>
<li>在<code>jcm.server-0.1.0.jar</code>目录下建立<code>config/application.properties</code>文件进行配置，参考<a href="https://github.com/kevinlynx/jcm/blob/master/jcm.server/config/application.properties">config/application.properties</a></li>
<li><p>启动jcm.server</p>

<pre><code> java -jar jcm.server-0.1.0.jar
</code></pre></li>
<li><p>注册需要管理的集群，参考cluster描述：<a href="https://github.com/kevinlynx/jcm/blob/master/doc/cluster_sample.json">doc/cluster_sample.json</a>，通过HTTP API注册：</p>

<pre><code> curl -i -X POST http://10.181.97.106:8080/c -H "Content-Type:application/json" --data-binary @./doc/cluster_sample.json
</code></pre></li>
</ol>


<p>部署好了jcm.server，并注册了cluster后，就可以通过jcm.subscriber使用：</p>

<p>{% highlight java %}
// 传入需要使用的集群名hello9/hello，以及传入jcm.server地址，可以多个：127.0.0.1:8080
Subscriber subscriber = new Subscriber( Arrays.asList(&ldquo;127.0.0.1:8080&rdquo;), Arrays.asList(&ldquo;hello9&rdquo;, &ldquo;hello&rdquo;));
// 使用轮询负载均衡策略
RRAllocator rr = new RRAllocator();
subscriber.addListener(rr);
subscriber.startup();
for (int i = 0; i &lt; 2; ++i) {
  // rr.alloc 根据cluster名字获取可用的node
  System.out.println(rr.alloc(&ldquo;hello9&rdquo;, ProtoType.HTTP));
}
subscriber.shutdown();
{% endhighlight %}</p>

<h2>JCM实现</h2>

<p>JCM目前的实现比较简单，参考模块图：</p>

<p><img src="https://raw.githubusercontent.com/kevinlynx/jcm/master/doc/asset/impl-module.jpg" alt="impl-module" /></p>

<ul>
<li>model，即cluster/node这些数据结构的描述，同时被jcm.server和jcm.subscriber依赖</li>
<li>storage，持久化数据到zookeeper，同时包含jcm.server实例之间的数据同步</li>
<li>health check，健康检查模块，对各个node进行健康检查</li>
</ul>


<p>以上模块都不依赖Spring，基于以上模块又有：</p>

<ul>
<li>http api，使用spring-mvc，包装了一些JSON HTTP API</li>
<li>Application，基于spring-boot，将各个基础模块组装起来，提供standalone的模式启动，不用部署到tomcat之类的servlet容器中</li>
</ul>


<p>jcm.subscriber的实现更简单，主要是负责与jcm.server进行通信，以更新自己当前的model层数据，同时提供各种负载均衡策略接口：</p>

<ul>
<li>subscriber，与jcm.server通信，定期增量拉取数据</li>
<li>node allocator，通过listener方式从subscriber中获取数据，同时实现各种负载均衡策略，对外统一提供<code>alloc node</code>的接口</li>
</ul>


<p>接下来看看关键功能的实现</p>

<h3>数据同步</h3>

<p>既然jcm.server是分布式的，每一个jcm.server instance(实例)都是支持数据读和写的，那么当jcm.server管理着一堆cluster上万个node时，每一个instance是如何进行数据同步的？jcm.server中的数据主要有两类：</p>

<ul>
<li>cluster本身的数据，包括cluster/node的描述，例如cluster name、node IP、及其他附属数据</li>
<li>node健康检查的数据</li>
</ul>


<p>对于cluster数据，因为cluster对node的管理是一个两层的树状结构，而对cluster有增删node的操作，所以并不能在每一个instance上都提供真正的数据写入，这样会导致数据丢失。假设同一时刻在instance A和instance B上同时对cluster c1添加节点N1和N2，那么instance A写入c1(N1)，而instance B还没等到数据同步就写入c1(N2)，那么c1(N1)就被覆盖为c1(N2)，从而导致添加的节点N1丢失。</p>

<p>所以，jcm.server instance是分为<code>leader</code>和<code>follower</code>的，真正的写入操作只有leader进行，follower收到写操作请求时转发给leader。leader写数据优先更新内存中的数据再写入zookeeper，内存中的数据更新当然是需要加锁互斥的，从而保证数据的正确性。</p>

<p><img src="https://raw.githubusercontent.com/kevinlynx/jcm/master/doc/asset/write-watch.jpg" alt="write-watch.jpg" /></p>

<p>leader和follower是如何确定角色的？这个很简单，标准的利用zookeeper来进行主从<a href="https://github.com/kevinlynx/jcm/blob/master/jcm.server/src/main/java/com/codemacro/jcm/util/ZookeeperLeaderElector.java">选举的实现</a>。</p>

<p>jcm.server instance数据间的同步是基于zookeeper watch机制的。这个可以算做是一个JCM的一个瓶颈，每一个instance都会作为一个watch，使得实际上jcm.server并不能无限水平扩展，扩展到一定程度后，watch的效率就可能不足以满足性能了，参考<a href="http://codemacro.com/2014/09/21/zk-watch-benchmark/">zookeeper节点数与watch的性能测试</a> (那个时候我就在考虑对我们系统的重构了) 。</p>

<p>jcm.server中对node健康检查的数据采用同样的同步机制，但node健康检查数据是每一个instance都会写入的，下面看看jcm.server是如何通过分布式架构来分担压力的。</p>

<h3>健康检查</h3>

<p>jcm.server的另一个主要功能的是对node的健康检查，jcm.server集群可以管理几万的node，既然已经是分布式了，那么显然是要把node均分到多个instance的。这里我是以cluster来分配的，方法就是简单的使用一致性哈希。通过一致性哈希，决定一个cluster是否属于某个instance负责。每个instance都有一个server spec，也就是该instance对外提供服务的地址(IP+port)，这样在任何一个instance上，它看到的所有instance server spec都是相同的，从而保证在每一个instance上计算cluster的分配得到的结果都是一致的。</p>

<p>健康检查按cluster划分，可以简化数据的写冲突问题，在正常情况下，每个instance写入的健康检查结果都是不同的。</p>

<p><img src="https://raw.githubusercontent.com/kevinlynx/jcm/master/doc/asset/health-check.jpg" alt="health-check.jpg" /></p>

<p>健康检查一般以1秒的频率进行，jcm.server做了优化，当检查结果和上一次一样时，并不写入zookeeper。写入的数据包含了node的完整key (IP+Port+Spec)，这样可以简化很多地方的数据同步问题，但会增加写入数据的大小，写入数据的大小是会影响zookeeper的性能的，所以这里简单地对数据进行了压缩。</p>

<p>健康检查是可以支持多种检查实现的，目前只实现了HTTP协议层的检查。健康检查自身是单个线程，在该线程中基于异步HTTP库，发起异步请求，实际的请求在其他线程中发出。</p>

<h3>jcm.subscriber通信</h3>

<p>jcm.subscriber与jcm.server通信，主要是为了获取最新的cluster数据。subscriber初始化时会拿到一个jcm.server instance的地址列表，访问时使用轮询策略以平衡jcm.server在处理请求时的负载。subscriber每秒都会请求一次数据，请求中描述了本次请求想获取哪些cluster数据，同时携带一个cluster的version。每次cluster在server变更时，version就变更（时间戳）。server回复请求时，如果version已最新，只需要回复node的状态。</p>

<p>subscriber可以拿到所有状态的node，后面可以考虑只拿正常状态的node，进一步减少数据大小。</p>

<h2>压力测试</h2>

<p>目前只对健康检查部分做了压测，详细参考<a href="https://github.com/kevinlynx/jcm/blob/master/test/beanchmark/benchmark.md">test/benchmark.md</a>。在A7服务器上测试，发现写zookeeper及zookeeper的watch足以满足要求，jcm.server发起的HTTP请求是主要的性能热点，单jcm.server instance大概可以承载20000个node的健康监测。</p>

<p>网络带宽：</p>

<pre><code>Time              ---------------------traffic--------------------
Time               bytin  bytout   pktin  pktout  pkterr  pktdrp
01/07/15-21:30:48   3.2M    4.1M   33.5K   34.4K    0.00    0.00
01/07/15-21:30:50   3.3M    4.2M   33.7K   35.9K    0.00    0.00
01/07/15-21:30:52   2.8M    4.1M   32.6K   41.6K    0.00    0.00
</code></pre>

<p>CPU，通过jstack查看主要的CPU消耗在HTTP库实现层，以及健康检查线程：</p>

<pre><code>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
13301 admin     20   0 13.1g 1.1g  12m R 76.6  2.3   2:40.74 java         httpchecker
13300 admin     20   0 13.1g 1.1g  12m S 72.9  2.3   0:48.31 java
13275 admin     20   0 13.1g 1.1g  12m S 20.1  2.3   0:18.49 java
</code></pre>

<p>代码中增加了些状态监控：</p>

<pre><code>checker HttpChecker stat count 20 avg check cost(ms) 542.05, avg flush cost(ms) 41.35
</code></pre>

<p>表示平均每次检查耗时542毫秒，写数据因为开启了cache没有参考价值。</p>

<p>虽然还可以从我自己的代码中做不少优化，但既然单机可以承载20000个节点的检测，一般的应用远远足够了。</p>

<h2>总结</h2>

<p>名字服务在分布式系统中虽然是基础服务，但往往承担了非常重要的角色，数据同步出现错误、节点状态出现瞬时的错误，都可能对整套系统造成较大影响，业务上出现较大故障。所以名字服务的健壮性、可用性非常重要。实现中需要考虑很多异常情况，包括网络不稳定、应用层的错误等。为了提高足够的可用性，一般还会加多层的数据cache，例如subscriber端的本地cache，server端的本地cache，以保证在任何情况下都不会影响应用层的服务。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于servlet实现一个web框架]]></title>
    <link href="http://codemacro.com/2015/06/07/servlet-web-framework/"/>
    <updated>2015-06-07T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/06/07/servlet-web-framework</id>
    <content type="html"><![CDATA[<p>servlet作为一个web规范，其本身就算做一个web开发框架，但是其web action (响应某个URI的实现)的实现都是基于类的，不是很方便，并且3.0之前的版本还必须通过web.xml配置来增加新的action。servlet中有一个filter的功能，可以配置所有URI的功能都经过filter。我们可以基于filter的功能来实现一个简单的web框架。在这个框架中，主要改进URI action的映射，就像<a href="https://www.playframework.com/">play framework</a>中route的配置：</p>

<pre><code>GET     /hello      com.codemacro.webdemo.test.TestController.hello
GET     /route      com.codemacro.webdemo.test.TestController.route
POST    /hello      com.codemacro.webdemo.test.TestController.sayHello
</code></pre>

<p>即把某个URI映射到类接口级别。基于servlet实现web框架的好处不仅实现简单，还能运行在所有支持servlet容器规范的web server上，例如Tomcat、Jetty。</p>

<p>本文提到的web framework demo可以从我的github 上取得：<a href="https://github.com/kevinlynx/servlet-web-framework-demo">servlet-web-framework-demo</a></p>

<h2>功能</h2>

<p>这个web framework URI action部分（或者说URI routing）如同前面描述，action的编写如：</p>

<p>{% highlight java %}
public class TestController extends BaseController {
  // 返回字符串
  public Result index() {
    return ok(&ldquo;hello world&rdquo;);
  }</p>

<p>  // HTTP 404
  public Result code404() {
    return status(404, &ldquo;not found&rdquo;);
  }</p>

<p>  // 使用JSP模板渲染
  public Result template() {
    String[] langs = new String[] {&ldquo;c++&rdquo;, &ldquo;java&rdquo;, &ldquo;python&rdquo;};
    return ok(jsp(&ldquo;index.jsp&rdquo;)
        .put(&ldquo;name&rdquo;, &ldquo;kevin&rdquo;)
        .put(&ldquo;langs&rdquo;,  langs)
        );
  }
}
{% endhighlight %}</p>

<!-- more -->


<p>有了action之后，配置<code>route</code>文件映射URI即可：</p>

<pre><code>GET /index  com.codemacro.webdemo.test.TestController.index
GET /404    com.codemacro.webdemo.test.TestController.code404
GET /index.jsp com.codemacro.webdemo.test.TestController.template
</code></pre>

<p>然后配置<code>web.xml</code>，增加一个filter：</p>

<pre><code>&lt;filter&gt;
  &lt;filter-name&gt;MyWebFilter&lt;/filter-name&gt;
  &lt;filter-class&gt;com.codemacro.webdemo.MyServletFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
  &lt;filter-name&gt;MyWebFilter&lt;/filter-name&gt;
  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>

<p>最后以war的形式部署到Jetty <code>webapps</code>下即可运行。想想下次要再找个什么lightweight Java web framework，直接用这个demo就够了。接下来讲讲一些关键部分的实现。</p>

<h2>servlet basic</h2>

<p>基于servlet开发的话，引入servlet api是必须的：</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
    &lt;version&gt;2.5&lt;/version&gt;
    &lt;type&gt;jar&lt;/type&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<p>servlet filter的接口包含：</p>

<p>{% highlight java %}
public class MyServletFilter implements Filter {
  // web app启动时调用一次，可用于web框架初始化
  public void init(FilterConfig conf) throws ServletException { }</p>

<p>  // 满足filter url-pattern时就会调用；req/res分别对应HTTP请求和回应
  public void doFilter(ServletRequest req, ServletResponse res,
    FilterChain chain) throws IOException, ServletException { }</p>

<p>  public void destroy() { }
}
{% endhighlight %}</p>

<p><code>init</code>接口可用于启动时载入<code>routes</code>配置文件，并建立URI到action的映射。</p>

<h2>action manager</h2>

<p><code>ActionManager</code>负责启动时载入<code>routes</code>配置，建立URI到action的映射。一个URI包含了HTTP method和URI String，例如<code>GET /index</code>。action既然映射到了类接口上，那么可以在启动时就同过Java反射找到对应的类及接口。简单起见，每次收到URI的请求时，就创建这个类对应的对象，然后调用映射的接口即可。</p>

<p>{% highlight java %}
// 例如：registerAction(&ldquo;com.codemacro.webdemo.test.TestController&rdquo;, &ldquo;index&rdquo;, &ldquo;/index&rdquo;, &ldquo;GET&rdquo;);
public void registerAction(String clazName, String methodName, String uri, String method) {
  try {
    uri = &ldquo;/&rdquo; + appName + uri;
    // 载入对应的class
    Class&lt;? extends BaseController> clazz = (Class&lt;? extends BaseController>) loadClass(clazName);
    // 取得对应的接口
    Method m = clazz.getMethod(methodName, (Class&lt;?>[])null);
    // 接口要求必须返回Result
    if (m.getReturnType() != Result.class) {
      throw new RuntimeException(&ldquo;action method return type mismatch: &rdquo; + uri);
    }
    ActionKey k = new ActionKey(uri, getMethod(method));
    ActionValue v = new ActionValue(clazz, m);
    logger.debug(&ldquo;register action {} {} {} {}&rdquo;, clazName, methodName, uri, method);
    // 建立映射
    actions.put(k, v);
  } catch (Exception e) {
    throw new RuntimeException(&ldquo;registerAction failed: &rdquo; + uri, e);
  }
}
{% endhighlight %}</p>

<p>controller都要求派生于<code>BaseController</code>，这样才可以利用<code>BaseController</code>更方便地获取请求数据之类，例如query string/cookie 等。</p>

<p>收到请求时，就需要根据请求的HTTP Method和URI string取得之前建立的映射，并调用之：</p>

<p>{% highlight java %}
public boolean invoke(HttpServletRequest req, HttpServletResponse resp) throws IOException {
  String uri = req.getRequestURI();
  String method = req.getMethod().toUpperCase();
  try {
    // 取得之前建立的映射，Map查找
    ActionValue v = getAction(uri, method);
    // 创建新的controller对象
    BaseController ctl = (BaseController) v.clazz.newInstance();
    ctl.init(req, resp, this);
    logger.debug(&ldquo;invoke action {}&rdquo;, uri);
    // 调用绑定的接口
    Result result = (Result) v.method.invoke(ctl, (Object[]) null);
    // 渲染结果
    result.render();
  } catch (Exception e) {
    &hellip;
  }
}
{% endhighlight %}</p>

<h2>结果渲染</h2>

<p>结果渲染无非就是把框架用户返回的结果渲染为字符串，写进<code>HttpServletResponse</code>。这个渲染过程可以是直接的<code>Object.toString</code>，或者经过模板引擎渲染，或者格式化为JSON。</p>

<p>通过实现具体的<code>Result</code>类，可以扩展不同的渲染方式，例如最基础的<code>Result</code>就是调用返回对象的<code>toString</code>：</p>

<p>{% highlight java %}
public class Result {
  public void render() throws IOException, ServletException {
    PrintWriter writer = response.getWriter();
    // result是controller action里返回的
    writer.append(result.toString());
    writer.close();
  }
}
{% endhighlight %}</p>

<p>为了简单，不引入第三方库，可以直接通过JSP来完成。JSP本身在servlet容器中就会被编译成一个servlet对象。</p>

<p>{% highlight java %}
public class JSPResult extends Result {
  &hellip;
  @Override
  public void render() throws IOException, ServletException {
    // 传入一些对象到模板中
    for (Map.Entry&lt;String, Object> entry : content.entrySet()) {
      request.setAttribute(entry.getKey(), entry.getValue());
    }
    // 委托给JSP来完成渲染
    request.getRequestDispatcher(file).forward(request, response);
  }
}
{% endhighlight %}</p>

<p>JSP中可以使用传统的scriptlets表达式，也可以使用新的EL方式，例如：</p>

<pre><code>&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%&gt;
&lt;h4&gt;By EL&lt;/h4&gt;
&lt;c:forEach var="lang" items="${langs}"&gt;
  &lt;span&gt;${lang}&lt;/span&gt;|
&lt;/c:forEach&gt;

&lt;% String[] langs = (String[]) request.getAttribute("langs"); %&gt;
&lt;% if (langs != null) { %&gt;
&lt;% for (String lang : langs) { %&gt;
  &lt;span&gt;&lt;%= lang %&gt;&lt;/span&gt;|
&lt;% } } %&gt;
</code></pre>

<p>使用EL的话需要引入<code>&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%&gt;</code></p>

<h2>BaseController</h2>

<p><code>BaseController</code>是一种template pattern实现，其包装了一些方便的接口给具体的controller使用，例如：</p>

<p>{% highlight java %}
public class BaseController {
  // 取得/index?name=kevin中的name参数值
  protected String getQueryString(String key) {
    return request.getParameter(key);
  }</p>

<p>  protected Result status(int code, String text) {
    response.setStatus(code);
    return new Result(response, text);
  }</p>

<p>  // 默认是HTTP 200
  protected Result ok(Object obj) {
    return new Result(response, obj);
  }</p>

<p>  protected Result ok(Result result) {
    return result;
  }</p>

<p>  protected JSPResult jsp(String file) {
    return new JSPResult(request, response, file, actionMgr);
  }
}
{% endhighlight %}</p>

<h2>Reverse routing</h2>

<p>Reverse routing指的是在开发web过程中，要引入某个URL时，我们不是直接写这个URL字符串，而是写其映射的接口，以使代码更易维护（因为URL可能会随着项目进展而改变）。并且，servlet app部署后URL会带上这个app的名字前缀，例如<code>/web-demo/index</code>中的<code>/web-demo</code>。在模板文件中，例如要链接到其他URI，更好的方式当然是直接写<code>/index</code>。</p>

<p>这里的实现比较丑陋，还是基于字符串的形式，例如：</p>

<pre><code>&lt;a href='&lt;route:reverse action="com.codemacro.webdemo.test.TestController.hello" name="kevin"/&gt;'&gt;index&lt;/a&gt;
</code></pre>

<p>通过自定义一个EL function <code>reverse</code>来实现。这里需要引入一个JSP的库：</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
    &lt;version&gt;2.0&lt;/version&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>

<p>首先实现一个<code>SimpleTagSupport</code>，为了支持<code>?name=kevin</code>这种动态参数，还需要<code>implements DynamicAttributes</code>：</p>

<p>{% highlight java %}
public class JSPRouteTag extends SimpleTagSupport implements DynamicAttributes {
  @Override
  // 输出最终的URL
  public void doTag() throws IOException {
    JspContext context = getJspContext();
    ActionManager actionMgr = (ActionManager) context.findAttribute(ACTION_MGR);
    JspWriter out = context.getOut();
    String uri = actionMgr.getReverseAction(action, attrMap);
    out.println(uri);
  }</p>

<p>  @Override
  // name=&ldquo;kevin&rdquo; 时调用
  public void setDynamicAttribute(String uri, String name, Object value) throws JspException {
    attrMap.put(name, value);
  }</p>

<p>  // <code>action="xxx"</code> 时会调用<code>setAction</code>
  public void setAction(String action) {
    this.action = action;
  }
}
{% endhighlight %}</p>

<p>为了访问到<code>ActionManager</code>，这里是通过写到<code>Request context</code>中实现的，相当hack。</p>

<p>{% highlight java %}
public JSPResult(HttpServletRequest req, HttpServletResponse resp, String file,
    ActionManager actionMgr) {
  super(resp, null);
  ..
  put(JSPRouteTag.ACTION_MGR, actionMgr);
}
{% endhighlight %}</p>

<p>第二步增加一个描述这个新tag的文件 <code>WEB-INF/route_tag.tld</code>：</p>

<pre><code>&lt;taglib&gt;
    &lt;tlibversion&gt;1.0&lt;/tlibversion&gt;
    &lt;jspversion&gt;1.1&lt;/jspversion&gt;
    &lt;shortname&gt;URLRouteTags&lt;/shortname&gt;
    &lt;uri&gt;/myweb-router&lt;/uri&gt;
    &lt;info&gt;&lt;/info&gt;

    &lt;tag&gt;
        &lt;name&gt;reverse&lt;/name&gt;
        &lt;tagclass&gt;com.codemacro.webdemo.result.JSPRouteTag&lt;/tagclass&gt;
        &lt;bodycontent&gt;&lt;/bodycontent&gt;
        &lt;info&gt;&lt;/info&gt;
        &lt;attribute&gt;
            &lt;name&gt;action&lt;/name&gt;
            &lt;required&gt;true&lt;/required&gt;
        &lt;/attribute&gt;
        &lt;dynamic-attributes&gt;true&lt;/dynamic-attributes&gt;
    &lt;/tag&gt;
&lt;/taglib&gt;
</code></pre>

<p>最后在需要使用的JSP中引入这个自定义tag：</p>

<pre><code>&lt;%@ taglib prefix="route" uri="/myweb-router" %&gt;
</code></pre>

<h2>参考资料</h2>

<ul>
<li><a href="http://www.cnblogs.com/cuiliang/archive/2011/10/21/2220671.html">Servlet生命周期与工作原理</a></li>
<li><a href="http://www.blogjava.net/fancydeepin/archive/2013/09/30/fan_servlet.html">JSP/Servlet工作原理</a></li>
<li><a href="http://www.cnblogs.com/xushuai123/archive/2013/03/24/2979711.html">EL表达式</a></li>
<li><a href="http://www.codedata.com.tw/java/java-tutorial-the-3rd-class-3-servlet-jsp/">使用Servlet、JSP开发Web程序</a></li>
<li><a href="http://www.itzhai.com/java-web-notes-servlet-filters-in-the-filter-writing-the-introduction-and-use-of-filters.html#read-more">Java Web笔记 – Servlet中的Filter过滤器的介绍和使用 编写过滤器</a></li>
<li><a href="http://blog.csdn.net/bingduanlbd/article/details/38349737">实现一个简单的Servlet容器</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中的反射及Bean容器的实现]]></title>
    <link href="http://codemacro.com/2015/05/31/java-refect-ioc/"/>
    <updated>2015-05-31T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/05/31/java-refect-ioc</id>
    <content type="html"><![CDATA[<p>编程语言中的反射(Refection)指的是可以在程序运行期动态加载一个类。与之相关的是自省(Introspection)，这个指的是程序自己可以获取一个类型的描述信息，例如获取一个类的所有接口定义、一个接口的所有形参。当编程语言有了这些语言特性之后，可以在很大程度上解决代码耦合问题，所以在Java的世界里，可以看到很多库/框架使用了反射技术。</p>

<p>类似Spring的Bean容器实现就是大量运用了反射机制。Bean容器维护了一些Bean对象，简单来说就是一些普通对象。Bean容器可以根据配置创建这些对象，创建时如果这些对象依赖了其他对象，Bean容器还会负责将依赖的对象注入到目标对象中，也就是所谓的依赖注入(dependence injection)。放在模块设计中，又衍生出控制反转(IoC, Inverse of Control)概念，用于描述应用程序在使用一个框架时，不是框架来控制/限制应用程序的架构模式，而是由应用程序来控制框架。</p>

<p>本文就简单描述下Bean容器是如何使用反射来实现的，最终代码参考<a href="https://github.com/kevinlynx/ioc-sample">github ioc-sample</a></p>

<h2>类的动态加载</h2>

<p>可以简单地使用<code>Class.forName</code>，传入某个class的完整名：</p>

<p>{% highlight java %}
public Class&lt;?> loadClass(String fullName) throws ClassNotFoundException {
  return Class.forName(fullName);
}
{% endhighlight %}</p>

<p>类的加载涉及到class loader，这块内容是可以进一步深化的。加载了类之后就可以创建出类的实例，但还没有完成依赖注入的功能：</p>

<p>{% highlight java %}
Class&lt;?> c = loadClass(&ldquo;com.codemacro.bean.test.Test1&rdquo;);
Object o = c.newInstance();
{% endhighlight %}</p>

<!-- more -->


<h2>通过set接口注入</h2>

<p>我们的类可以包含<code>set</code>接口，用于设置某个成员：</p>

<p>{% highlight java %}
public class Test2 {
  public Test1 test1;</p>

<p>  public void setTest1(Test1 t) {
    test1 = t;
  }
}
{% endhighlight %}</p>

<p>那么可以通过<code>setXXX</code>接口将<code>Test1</code>注入到<code>Test2</code>中：</p>

<p>{% highlight java %}
// props指定哪些成员需要注入，例如{&ldquo;Test1&rdquo;, &ldquo;test1&rdquo;}，Test1指的是setTest1，test1指的是bean名字
public Object buildWithSetters(String name, Class&lt;?> c, Map&lt;String, String> props) {
  try {
    // ClassSetMethods 类获取Class&lt;?>中所有setXX这种接口
    ClassSetMethods setMethods = new ClassSetMethods&copy;;
    Object obj = c.newInstance();
    for (Map.Entry&lt;String, String> entrys : props.entrySet()) {
      String pname = entrys.getKey();
      String beanName = entrys.getValue();
      // 取得setXXX这个Method
      Method m = setMethods.get(pname);
      Object val = getBean(beanName);
      // 调用
      m.invoke(obj, val);
    }
    beans.put(name, obj);
    return obj;
  } catch (Exception e) {
    throw new RuntimeException(&ldquo;build bean failed&rdquo;, e);
  }
}  <br/>
{% endhighlight %}</p>

<p><code>ClassSetMethod</code>自省出一个Class中所有的<code>setXXX(xx)</code>接口：</p>

<p>{% highlight java %}
public ClassSetMethods(Class&lt;?> c) {
  Method[] methods = c.getMethods();
  for (Method m : methods) {
    String mname = m.getName();
    Class&lt;?>[] ptypes = m.getParameterTypes();
    if (mname.startsWith(&ldquo;set&rdquo;) &amp;&amp; ptypes.length == 1 &amp;&amp; m.getReturnType() == Void.TYPE) {
      String name = mname.substring(&ldquo;set&rdquo;.length());
      this.methods.put(name, m);
    }
  }
}
{% endhighlight %}</p>

<p>以上就可以看出Java中的自省能力，例如<code>Class&lt;?&gt;.getMethods</code>、<code>Method.getReturnType</code>、<code>Method.getParameterTypes</code>。</p>

<h2>通过构造函数注入</h2>

<p>类似于Spring中的：</p>

<pre><code>&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
  &lt;constructor-arg type="int" value="2001"/&gt;
  &lt;constructor-arg type="java.lang.String" value="Zara"/&gt;
</code></pre>

<p>   </bean></p>

<p>可以将依赖的Bean通过构造函数参数注入到目标对象中：</p>

<p>{% highlight java %}
List<String> params = new ArrayList<String>();
params.add(&ldquo;test1&rdquo;);
bf.buildWithConstructor(&ldquo;test2&rdquo;, Test2.class, params);
{% endhighlight %}</p>

<p>其实现：</p>

<p>{% highlight java %}
public Object buildWithConstructor(String name, Class&lt;?> c, List<String> beanNames) {
  try {
    Constructor&lt;?>[] ctors = c.getConstructors(); // 取得Class构造函数列表
    assert ctors.length == 1;
    Constructor&lt;?> cc = ctors[0];
    Class&lt;?>[] ptypes = cc.getParameterTypes(); // 取得构造函数参数类型列表
    assert ptypes.length == beans.size();
    Object[] args = new Object[ptypes.length];
    for (int i = 0; i &lt; beanNames.size(); ++i) {
      args[i] = getBean(beanNames.get(i)); // 构造调用构造函数的实参列表
    }
    Object obj = cc.newInstance(args); // 通过构造函数创建对象
    beans.put(name, obj);
    return obj;
  } catch (Exception e) {
    throw new RuntimeException(&ldquo;build bean failed&rdquo;, e);
  }
}
{% endhighlight %}</p>

<p>这个接口的使用约定<code>beanNames</code>保存的是bean名称，并与构造函数参数一一对应。</p>

<h2>通过注解注入</h2>

<p>我们可以通过注解标注某个数据成员是需要被自动注入的。我这里简单地获取注解标注的成员类型，找到该类型对应的Bean作为注入对象。当然复杂点还可以指定要注入Bean的名字，或自动查找类型的派生类实现。</p>

<p>一个空的注解即可：</p>

<p>{% highlight java %}
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Inject {
}
{% endhighlight %}</p>

<p>实现：</p>

<p>{% highlight java %}</p>

<p>public Object buildWithInject(String name, Class&lt;?> c) {
  try {
    Object obj = c.newInstance();
    Field[] fields = c.getDeclaredFields(); // 获取该类所有定义的成员
    for (Field f :fields) {
      Inject inject = f.getAnnotation(Inject.class); // 获取数据成员的注解
      if (inject != null) { // 如果被Inject注解标注
        Object bean = getBeanByType(f.getType()); // 根据成员的类型找到对应的Bean
        f.set(obj, bean); // 注入
      } else {
        throw new RuntimeException(&ldquo;not found bean &rdquo; + f.getName());
      }
    }
    beans.put(name, obj);
    return obj;
  } catch (Exception e) {
    throw new RuntimeException(&ldquo;build bean failed&rdquo;, e);
  }
}
{% endhighlight %}</p>

<p><code>getBeanByType</code>就是根据<code>Class</code>匹配所有的Bean。使用时：</p>

<p>{% highlight java %}
public class Test2 {
  @Inject
  public Test1 test1;
  &hellip;
}
{% endhighlight %}</p>

<p>完。</p>
]]></content>
  </entry>
  
</feed>
