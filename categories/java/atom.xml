<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | loop in codes]]></title>
  <link href="http://codemacro.com/categories/java/atom.xml" rel="self"/>
  <link href="http://codemacro.com/"/>
  <updated>2015-05-31T15:54:52+08:00</updated>
  <id>http://codemacro.com/</id>
  <author>
    <name><![CDATA[Kevin Lynx]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java中的反射及Bean容器的实现]]></title>
    <link href="http://codemacro.com/2015/05/31/java-refect-ioc/"/>
    <updated>2015-05-31T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/05/31/java-refect-ioc</id>
    <content type="html"><![CDATA[<p>编程语言中的反射(Refection)指的是可以在程序运行期动态加载一个类。与之相关的是自省(Introspection)，这个指的是程序自己可以获取一个类型的描述信息，例如获取一个类的所有接口定义、一个接口的所有形参。当编程语言有了这些语言特性之后，可以在很大程度上解决代码耦合问题，所以在Java的世界里，可以看到很多库/框架使用了反射技术。</p>

<p>类似Spring的Bean容器实现就是大量运用了反射机制。Bean容器维护了一些Bean对象，简单来说就是一些普通对象。Bean容器可以根据配置创建这些对象，创建时如果这些对象依赖了其他对象，Bean容器还会负责将依赖的对象注入到目标对象中，也就是所谓的依赖注入(dependence injection)。放在模块设计中，又衍生出控制反转(IoC, Inverse of Control)概念，用于描述应用程序在使用一个框架时，不是框架来控制/限制应用程序的架构模式，而是由应用程序来控制框架。</p>

<p>本文就简单描述下Bean容器是如何使用反射来实现的，最终代码参考<a href="https://github.com/kevinlynx/ioc-sample">github ioc-sample</a></p>

<h2>类的动态加载</h2>

<p>可以简单地使用<code>Class.forName</code>，传入某个class的完整名：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">Class</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?&gt;</span> <span class="n">loadClass</span><span class="o">(</span><span class="n">String</span> <span class="n">fullName</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">fullName</span><span class="o">);</span>
    <span class="o">}</span></code></pre></div></p>

<p>类的加载涉及到class loader，这块内容是可以进一步深化的。加载了类之后就可以创建出类的实例，但还没有完成依赖注入的功能：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Class</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">loadClass</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">com</span><span class="o">.</span><span class="na">codemacro</span><span class="o">.</span><span class="na">bean</span><span class="o">.</span><span class="na">test</span><span class="o">.</span><span class="na">Test1</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;);</span>
    <span class="n">Object</span> <span class="n">o</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span></code></pre></div></p>

<!-- more -->


<h2>通过set接口注入</h2>

<p>我们的类可以包含<code>set</code>接口，用于设置某个成员：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test2</span> <span class="o">{</span>
      <span class="kd">public</span> <span class="n">Test1</span> <span class="n">test1</span><span class="o">;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setTest1</span><span class="o">(</span><span class="n">Test1</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">test1</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span></code></pre></div></p>

<p>那么可以通过<code>setXXX</code>接口将<code>Test1</code>注入到<code>Test2</code>中：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// props指定哪些成员需要注入，例如{&amp;ldquo;Test1&amp;rdquo;, &amp;ldquo;test1&amp;rdquo;}，Test1指的是setTest1，test1指的是bean名字</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">buildWithSetters</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Class</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?&gt;</span> <span class="n">c</span><span class="o">,</span> <span class="n">Map</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">props</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// ClassSetMethods 类获取Class&amp;lt;?&gt;中所有setXX这种接口</span>
        <span class="n">ClassSetMethods</span> <span class="n">setMethods</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassSetMethods</span><span class="o">&amp;</span><span class="n">copy</span><span class="o">;;</span>
        <span class="n">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">entrys</span> <span class="o">:</span> <span class="n">props</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
          <span class="n">String</span> <span class="n">pname</span> <span class="o">=</span> <span class="n">entrys</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
          <span class="n">String</span> <span class="n">beanName</span> <span class="o">=</span> <span class="n">entrys</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
          <span class="c1">// 取得setXXX这个Method</span>
          <span class="n">Method</span> <span class="n">m</span> <span class="o">=</span> <span class="n">setMethods</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pname</span><span class="o">);</span>
          <span class="n">Object</span> <span class="n">val</span> <span class="o">=</span> <span class="n">getBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
          <span class="c1">// 调用</span>
          <span class="n">m</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">obj</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">beans</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">obj</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">build</span> <span class="n">bean</span> <span class="n">failed</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="n">e</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span></code></pre></div></p>

<p><code>ClassSetMethod</code>自省出一个Class中所有的<code>setXXX(xx)</code>接口：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">ClassSetMethods</span><span class="o">(</span><span class="n">Class</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">Method</span><span class="o">[]</span> <span class="n">methods</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">getMethods</span><span class="o">();</span>
      <span class="k">for</span> <span class="o">(</span><span class="n">Method</span> <span class="n">m</span> <span class="o">:</span> <span class="n">methods</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">mname</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
        <span class="n">Class</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?&gt;[]</span> <span class="n">ptypes</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">getParameterTypes</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mname</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">set</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">ptypes</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">m</span><span class="o">.</span><span class="na">getReturnType</span><span class="o">()</span> <span class="o">==</span> <span class="n">Void</span><span class="o">.</span><span class="na">TYPE</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">mname</span><span class="o">.</span><span class="na">substring</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">set</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;.</span><span class="na">length</span><span class="o">());</span>
          <span class="k">this</span><span class="o">.</span><span class="na">methods</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">m</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span></code></pre></div></p>

<p>以上就可以看出Java中的自省能力，例如<code>Class&lt;?&gt;.getMethods</code>、<code>Method.getReturnType</code>、<code>Method.getParameterTypes</code>。</p>

<h2>通过构造函数注入</h2>

<p>类似于Spring中的：</p>

<pre><code>&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
  &lt;constructor-arg type="int" value="2001"/&gt;
  &lt;constructor-arg type="java.lang.String" value="Zara"/&gt;
</code></pre>

<p>   </bean></p>

<p>可以将依赖的Bean通过构造函数参数注入到目标对象中：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">params</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
    <span class="n">params</span><span class="o">.</span><span class="na">add</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">test1</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;);</span>
    <span class="n">bf</span><span class="o">.</span><span class="na">buildWithConstructor</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">test2</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="n">Test2</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">params</span><span class="o">);</span></code></pre></div></p>

<p>其实现：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">Object</span> <span class="nf">buildWithConstructor</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Class</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?&gt;</span> <span class="n">c</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">beanNames</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">try</span> <span class="o">{</span>
        <span class="n">Constructor</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?&gt;[]</span> <span class="n">ctors</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">getConstructors</span><span class="o">();</span> <span class="c1">// 取得Class构造函数列表</span>
        <span class="k">assert</span> <span class="n">ctors</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">Constructor</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?&gt;</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">ctors</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="n">Class</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?&gt;[]</span> <span class="n">ptypes</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="na">getParameterTypes</span><span class="o">();</span> <span class="c1">// 取得构造函数参数类型列表</span>
        <span class="k">assert</span> <span class="n">ptypes</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">beans</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="n">ptypes</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">beanNames</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">args</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">getBean</span><span class="o">(</span><span class="n">beanNames</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span> <span class="c1">// 构造调用构造函数的实参列表</span>
        <span class="o">}</span>
        <span class="n">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">args</span><span class="o">);</span> <span class="c1">// 通过构造函数创建对象</span>
        <span class="n">beans</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">obj</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">build</span> <span class="n">bean</span> <span class="n">failed</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="n">e</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span></code></pre></div></p>

<p>这个接口的使用约定<code>beanNames</code>保存的是bean名称，并与构造函数参数一一对应。</p>

<h2>通过注解注入</h2>

<p>我们可以通过注解标注某个数据成员是需要被自动注入的。我这里简单地获取注解标注的成员类型，找到该类型对应的Bean作为注入对象。当然复杂点还可以指定要注入Bean的名字，或自动查找类型的派生类实现。</p>

<p>一个空的注解即可：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Retention</span><span class="o">(</span><span class="n">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
    <span class="nd">@Target</span><span class="o">(</span><span class="n">ElementType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nd">@interface</span> <span class="n">Inject</span> <span class="o">{</span>
    <span class="o">}</span></code></pre></div></p>

<p>实现：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kd">public</span> <span class="n">Object</span> <span class="nf">buildWithInject</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Class</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;?&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="n">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
    <span class="n">Field</span><span class="o">[]</span> <span class="n">fields</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">getDeclaredFields</span><span class="o">();</span> <span class="c1">// 获取该类所有定义的成员</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Field</span> <span class="n">f</span> <span class="o">:</span><span class="n">fields</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">Inject</span> <span class="n">inject</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">Inject</span><span class="o">.</span><span class="na">class</span><span class="o">);</span> <span class="c1">// 获取数据成员的注解</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">inject</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 如果被Inject注解标注</span>
        <span class="n">Object</span> <span class="n">bean</span> <span class="o">=</span> <span class="n">getBeanByType</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">getType</span><span class="o">());</span> <span class="c1">// 根据成员的类型找到对应的Bean</span>
        <span class="n">f</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">obj</span><span class="o">,</span> <span class="n">bean</span><span class="o">);</span> <span class="c1">// 注入</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">&quot;not found bean &quot;</span> <span class="o">+</span> <span class="n">f</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">beans</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">obj</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">&quot;build bean failed&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span></code></pre></div></p>

<p><code>getBeanByType</code>就是根据<code>Class</code>匹配所有的Bean。使用时：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test2</span> <span class="o">{</span>
      <span class="nd">@Inject</span>
      <span class="kd">public</span> <span class="n">Test1</span> <span class="n">test1</span><span class="o">;</span>
      <span class="o">&amp;</span><span class="n">hellip</span><span class="o">;</span>
    <span class="o">}</span></code></pre></div></p>

<p>完。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Drill中实现HTTP storage plugin]]></title>
    <link href="http://codemacro.com/2015/05/30/drill-http-plugin/"/>
    <updated>2015-05-30T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/05/30/drill-http-plugin</id>
    <content type="html"><![CDATA[<p>Apache Drill可用于大数据的实时分析，引用一段介绍：</p>

<blockquote><p>受到Google Dremel启发，Apache的Drill项目是对大数据集进行交互式分析的分布式系统。Drill并不会试图取代已有的大数据批处理框架（Big Data batch processing framework），如Hadoop MapReduce或流处理框架（stream processing framework），如S4和Storm。相反，它是要填充现有空白的——对大数据集的实时交互式处理</p></blockquote>

<p>简单来说，Drill可接收SQL查询语句，然后后端从多个数据源例如HDFS、MongoDB等获取数据并分析产出分析结果。在一次分析中，它可以汇集多个数据源的数据。而且基于分布式的架构，可以支持秒级查询。</p>

<p>Drill在架构上是比较灵活的，它的前端可以不一定是SQL查询语言，后端数据源也可以接入Storage plugin来支持其他数据来源。这里我就实现了一个从HTTP服务获取数据的Storage plugin demo。这个demo可以接入基于GET请求，返回JSON格式的HTTP服务。源码可从我的Github获取：<a href="https://github.com/kevinlynx/drill-storage-http">drill-storage-http</a></p>

<p>例子包括：</p>

<pre><code>select name, length from http.`/e/api:search` where $p=2 and $q='avi'
select name, length from http.`/e/api:search?q=avi&amp;p=2` where length &gt; 0 
</code></pre>

<h2>实现</h2>

<p>要实现一个自己的storage plugin，目前Drill这方面文档几乎没有，只能从已有的其他storage plugin源码入手，例如mongodb的，参考Drill子项目<code>drill-mongo-storage</code>。实现的storage plugin打包为jar放到<code>jars</code>目录，Drill启动时会自动载入，然后web上配置指定类型即可。</p>

<p>主要需要实现的类包括：</p>

<pre><code>AbstractStoragePlugin
StoragePluginConfig
SchemaFactory
BatchCreator
AbstractRecordReader
AbstractGroupScan
</code></pre>

<!-- more -->


<h3>AbstraceStoragePlugin</h3>

<p><code>StoragePluginConfig</code>用于配置plugin，例如：</p>

<pre><code>{
  "type" : "http",
  "connection" : "http://xxx.com:8000",
  "resultKey" : "results",
  "enabled" : true
}
</code></pre>

<p>它必须是可JSON序列化/反序列化的，Drill会把storage配置存储到<code>/tmp/drill/sys.storage_plugins</code>中，例如windows下<code>D:\tmp\drill\sys.storage_plugins</code>。</p>

<p><code>AbstractStoragePlugin</code> 是plugin的主类，它必须配合<code>StoragePluginConfig</code>，实现这个类时，构造函数必须遵循参数约定，例如：</p>

<pre><code>public HttpStoragePlugin(HttpStoragePluginConfig httpConfig, DrillbitContext context, String name)
</code></pre>

<p>Drill启动时会自动扫描<code>AbstractStoragePlugin</code>实现类(<code>StoragePluginRegistry</code>)，并建立<code>StoragePluginConfig.class</code>到<code>AbstractStoragePlugin constructor</code>的映射。<code>AbstractStoragePlugin</code>需要实现的接口包括：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 相应地需要实现AbstraceGroupScan</span>
    <span class="c1">// selection包含了database name和table name，可用可不用</span>
    <span class="kd">public</span> <span class="n">AbstractGroupScan</span> <span class="nf">getPhysicalScan</span><span class="o">(</span><span class="n">String</span> <span class="n">userName</span><span class="o">,</span> <span class="n">JSONOptions</span> <span class="n">selection</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// 注册schema</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">registerSchemas</span><span class="o">(</span><span class="n">SchemaConfig</span> <span class="n">schemaConfig</span><span class="o">,</span> <span class="n">SchemaPlus</span> <span class="n">parent</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span>

<span class="c1">// StoragePluginOptimizerRule 用于优化Drill生成的plan，可实现也可不实现</span>
<span class="kd">public</span> <span class="n">Set</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">StoragePluginOptimizerRule</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">getOptimizerRules</span><span class="o">()</span> 
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span></code></pre></div></p>

<p>Drill中的schema用于描述一个database，以及处理table之类的事务，必须要实现，否则任意一个SQL查询都会被认为是找不到对应的table。<code>AbstraceGroupScan</code>用于一次查询中提供信息，例如查询哪些columns。</p>

<p>Drill在查询时，有一种中间数据结构(基于JSON)叫Plan，其中又分为Logic Plan和Physical Plan。Logic Plan是第一层中间结构，用于完整表达一次查询，是SQL或其他前端查询语言转换后的中间结构。完了后还要被转换为Physical Plan，又称为Exectuion Plan，这个Plan是被优化后的Plan，可用于与数据源交互进行真正的查询。<code>StoragePluginOptimizerRule</code>就是用于优化Physical Plan的。这些Plan最终对应的结构有点类似于语法树，毕竟SQL也可以被认为是一种程序语言。<code>StoragePluginOptimizerRule</code>可以被理解为改写这些语法树的。例如Mongo storage plugin就实现了这个类，它会把<code>where</code>中的filter转换为mongodb自己的filter(如{&lsquo;$gt&rsquo;: 2})，从而优化查询。</p>

<p>这里又牵扯出Apache的另一个项目：<a href="https://github.com/apache/incubator-calcite">calcite</a>，前身就是OptiQ。Drill中整个关于SQL的执行，主要是依靠这个项目。要玩转Plan的优化是比较难的，也是因为文档欠缺，相关代码较多。</p>

<h3>SchemaFactory</h3>

<p><code>registerSchemas</code>主要还是调用<code>SchemaFactory.registerSchemas</code>接口。Drill中的Schema是一种树状结构，所以可以看到<code>registerSchemas</code>实际就是往parent中添加child：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">registerSchemas</span><span class="o">(</span><span class="n">SchemaConfig</span> <span class="n">schemaConfig</span><span class="o">,</span> <span class="n">SchemaPlus</span> <span class="n">parent</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">HttpSchema</span> <span class="n">schema</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">HttpSchema</span><span class="o">(</span><span class="n">schemaName</span><span class="o">);</span>
        <span class="n">parent</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">schema</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">schema</span><span class="o">);</span>
    <span class="o">}</span></code></pre></div></p>

<p><code>HttpSchema</code>派生于<code>AbstractSchema</code>，主要需要实现接口<code>getTable</code>，因为我这个http storage plugin中的table实际就是传给HTTP service的query，所以table是动态的，所以<code>getTable</code>的实现比较简单：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">Table</span> <span class="nf">getTable</span><span class="o">(</span><span class="n">String</span> <span class="n">tableName</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// table name can be any of string</span>
        <span class="n">HttpScanSpec</span> <span class="n">spec</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">HttpScanSpec</span><span class="o">(</span><span class="n">tableName</span><span class="o">);</span> <span class="c1">// will be pass to getPhysicalScan</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">DynamicDrillTable</span><span class="o">(</span><span class="n">plugin</span><span class="o">,</span> <span class="n">schemaName</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">spec</span><span class="o">);</span>
    <span class="o">}</span></code></pre></div></p>

<p>这里的<code>HttpScanSpec</code>用于保存查询中的一些参数，例如这里保存了table name，也就是HTTP service的query，例如<code>/e/api:search?q=avi&amp;p=2</code>。它会被传到<code>AbstraceStoragePlugin.getPhysicalScan</code>中的<code>JSONOptions</code>：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">AbstractGroupScan</span> <span class="nf">getPhysicalScan</span><span class="o">(</span><span class="n">String</span> <span class="n">userName</span><span class="o">,</span> <span class="n">JSONOptions</span> <span class="n">selection</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">HttpScanSpec</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">selection</span><span class="o">.</span><span class="na">getListWith</span><span class="o">(</span><span class="k">new</span> <span class="nf">ObjectMapper</span><span class="o">(),</span> <span class="k">new</span> <span class="n">TypeReference</span><span class="o">&lt;</span><span class="n">HttpScanSpec</span><span class="o">&gt;()</span> <span class="o">{});</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">HttpGroupScan</span><span class="o">(</span><span class="n">userName</span><span class="o">,</span> <span class="n">httpConfig</span><span class="o">,</span> <span class="n">spec</span><span class="o">);</span>
    <span class="o">}</span></code></pre></div></p>

<p><code>HttpGroupScan</code>后面会看到用处。</p>

<h3>AbstractRecordReader</h3>

<p><code>AbstractRecordReader</code>负责真正地读取数据并返回给Drill。<code>BatchCreator</code>则是用于创建<code>AbstractRecordReader</code>。</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HttpScanBatchCreator</span> <span class="kd">implements</span> <span class="n">BatchCreator</span><span class="o">&lt;</span><span class="n">HttpSubScan</span><span class="o">&gt;</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">CloseableRecordBatch</span> <span class="nf">getBatch</span><span class="o">(</span><span class="n">FragmentContext</span> <span class="n">context</span><span class="o">,</span>
      <span class="n">HttpSubScan</span> <span class="n">config</span><span class="o">,</span> <span class="n">List</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">RecordBatch</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">children</span><span class="o">)</span>
      <span class="kd">throws</span> <span class="n">ExecutionSetupException</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">RecordReader</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">readers</span> <span class="o">=</span> <span class="n">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">();</span>
    <span class="n">readers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nf">HttpRecordReader</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">config</span><span class="o">));</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">ScanBatch</span><span class="o">(</span><span class="n">config</span><span class="o">,</span> <span class="n">context</span><span class="o">,</span> <span class="n">readers</span><span class="o">.</span><span class="na">iterator</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span></code></pre></div></p>

<p>既然<code>AbstractRecordReader</code>负责真正读取数据，那么它肯定是需要知道传给HTTP service的query的，但这个query最早是在<code>HttpScanSpec</code>中，然后传给了<code>HttpGroupScan</code>，所以马上会看到<code>HttpGroupScan</code>又把参数信息传给了<code>HttpSubScan</code>。</p>

<p>Drill也会自动扫描<code>BatchCreator</code>的实现类，所以这里就不用关心<code>HttpScanBatchCreator</code>的来历了。</p>

<p><code>HttpSubScan</code>的实现比较简单，主要是用来存储<code>HttpScanSpec</code>的：</p>

<pre><code>public class HttpSubScan extends AbstractBase implements SubScan // 需要实现SubScan
</code></pre>

<p>回到<code>HttpGroupScan</code>，必须实现的接口：</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">SubScan</span> <span class="nf">getSpecificScan</span><span class="o">(</span><span class="kt">int</span> <span class="n">minorFragmentId</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// pass to HttpScanBatchCreator</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">HttpSubScan</span><span class="o">(</span><span class="n">config</span><span class="o">,</span> <span class="n">scanSpec</span><span class="o">);</span> <span class="c1">// 最终会被传递到HttpScanBatchCreator.getBatch接口</span>
      <span class="o">}</span></code></pre></div></p>

<p>最终query被传递到<code>HttpRecordReader</code>，该类需要实现的接口包括：<code>setup</code>和<code>next</code>，有点类似于迭代器。<code>setup</code>中查询出数据，然后<code>next</code>中转换数据给Drill。转换给Drill时可以使用到<code>VectorContainerWriter</code>和<code>JsonReader</code>。这里也就是Drill中传说的vector数据格式，也就是列存储数据。</p>

<h3>总结</h3>

<p>以上，就包含了plugin本身的创建，及查询中query的传递。查询中类似<code>select titile, name</code> 中的columns会被传递到<code>HttpGroupScan.clone</code>接口，只不过我这里并不关注。实现了这些，就可以通过Drill查询HTTP service中的数据了。</p>

<p>而<code>select * from xx where xx</code>中的<code>where</code> filter，Drill自己会对查询出来的数据做过滤。如果要像mongo plugin中构造mongodb的filter，则需要实现<code>StoragePluginOptimizerRule</code>。</p>

<p>我这里实现的HTTP storage plugin，本意是觉得传给HTTP service的query可能会动态构建，例如：</p>

<pre><code>select name, length from http.`/e/api:search` where $p=2 and $q='avi' # p=2&amp;q=avi 就是动态构建，其值可以来源于其他查询结果
select name, length from http.`/e/api:search?q=avi&amp;p=2` where length &gt; 0  # 这里就是静态的
</code></pre>

<p>第一条查询就需要借助<code>StoragePluginOptimizerRule</code>，它会收集所有where中的filter，最终作为HTTP serivce的query。但这里的实现还不完善。</p>

<p>总体而言，由于Drill项目相对较新，要进行扩展还是比较困难的。尤其是Plan优化部分。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识JVM byte code]]></title>
    <link href="http://codemacro.com/2015/03/31/intro-java-bytecode/"/>
    <updated>2015-03-31T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/03/31/intro-java-bytecode</id>
    <content type="html"><![CDATA[<p>关于JVM和其上的byte code，网上其实有足够多的资料了，我这里就简单做个提纲和介绍，权当记录吧。</p>

<h2>stack-based VM</h2>

<p>Java byte code运行在JVM上，就像机器指令运行在物理机上，是需要遵循这个机器的指令规范的。所以认识JVM byte code，是需要稍微了解下JVM的。JVM是一个基于栈(stack-based)的虚拟机。很久以前我还写过类似<a href="http://www.cppblog.com/kevinlynx/archive/2010/04/15/112704.html">简单的虚拟机</a>。</p>

<p>基于栈的虚拟机其操作数和指令运算的中间结果全部都在一个虚拟栈中，与之对应的是基于寄存器(register-based)的虚拟机，其操作数和指令运算结果会存放在若干个寄存器（也就是存储单元）里。x86机器就可以理解为基于寄存器的机器。</p>

<p>byte code其实和x86汇编代码本质一样，无非是对应机器制定的一堆指令，这里可以举例说明下两类虚拟机的不同：</p>

<pre><code># stack-based 
push 1       # 压立即数1到栈顶
push 2       # 压立即数2到栈顶
add          # 弹出栈顶2个数相加，将结果3压到栈顶

# register-based
mov ax, 1    # 写立即数到寄存器ax
add ax, 2    # 取ax中的值1与立即数2进行相加，存放结果到ax
</code></pre>

<p>关于两类实现的比较，网上也有不少资料，例如<a href="http://www.zhihu.com/question/20207106">Dalvik 虚拟机和 Sun JVM 在架构和执行方面有什么本质区别？</a>。</p>

<!-- more -->


<p><em>至于有人说基于栈的虚拟机更利于移植，我不是很理解，因为即使是基于寄存器的实现，也不一定真的必须把这些寄存器映射到物理机CPU上的寄存器，使用内存来模拟性能上跟基于栈的方式不是八九不离十吗？</em></p>

<p>了解了JVM的这个特点，JVM上的各种指令就可以更好地理解，如果要理解JVM如何运行byte code的，那还需要了解JVM内部的各种结构，例如符号解析、class loader、内存分配甚至垃圾回收等。这个以后再谈。</p>

<h2>byte-code</h2>

<p><code>*.class</code>文件就已经是编译好的byte code文件，就像C/C++编译出来的目标文件一样，已经是各种二进制指令了。这个时候可以通过JDK中带的<code>javap</code>工具来反汇编，以查看对应的byte code。</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// Test.java</span>
    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0xae</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mh">0x10</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">String</span> <span class="n">s</span><span class="o">;</span>
            <span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">hello</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;;</span>
        <span class="o">}</span>
    <span class="o">}</span></code></pre></div></p>

<p>编译该文件：<code>javac Test.java</code>得到<code>Test.class</code>，然后<code>javap -c Test</code>即得到：</p>

<pre><code>Compiled from "Test.java"
public class Test {
  public Test();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: sipush        174           # push a short onto the stack 0xae=174
       3: istore_1                    # store int value into variable 1: a = 0xae
       4: bipush        16            # push a byte onto the stack 0x10=16
       6: istore_2                    # store int value into variable 2: b = 0x10
       7: iload_1                     # load value from variable 1 and push onto the stack
       8: iload_2                   
       9: iadd                        # add two ints: a + b
      10: istore_3                    # c = a + b
      11: iload_3                     
      12: iconst_1                    # 1
      13: iadd                        # c + 1
      14: istore        4             # d = c + 1
      16: ldc           #2                  // String hello
      18: astore        5
      20: return
}
</code></pre>

<p>这个时候对照着JVM指令表看上面的代码，比起x86汇编浅显易懂多了，秒懂，参考<a href="http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings">Java bytecode instruction listings</a>。JVM中每个指令只占一个字节，操作数是变长的，所以其一条完整的指令（操作码+操作数）也是变长的。上面每条指令前都有一个偏移，实际是按字节来偏移的。<em>想起Lua VM的指令竟然是以bit来干的</em></p>

<p>从上面的byte code中，以x86汇编的角度来看会发现一些不同的东西：</p>

<ul>
<li>局部变量竟是以索引来区分：<code>istore_1</code> 写第一个局部变量，<code>istore_2</code>写第二个局部变量，第4个局部变量则需要用操作数来指定了：<code>istore 4</code></li>
<li>函数调用<code>invokespecial #1</code>竟然也是类似的索引，这里调用的是<code>Object</code>基类构造函数</li>
<li>常量字符串也是类似的索引：<code>ldc #2</code></li>
<li><code>*.class</code>中是不是也分了常量数据段和代码段呢</li>
</ul>


<p>以上需要我们进一步了解<code>*.class</code>文件的格式。</p>

<h2>class file format</h2>

<p>class 文件格式网上也有讲得很详细的了，例如这篇<a href="http://www.importnew.com/15161.html">Java Class文件详解</a>。整个class文件完全可以用以下结构来描述：</p>

<pre><code>ClassFile {
    u4 magic;                                        //魔数
    u2 minor_version;                                //次版本号
    u2 major_version;                                //主版本号
    u2 constant_pool_count;                          //常量池大小
    cp_info constant_pool[constant_pool_count-1];    //常量池
    u2 access_flags;                                 //类和接口层次的访问标志（通过|运算得到）
    u2 this_class;                                   //类索引（指向常量池中的类常量）
    u2 super_class;                                  //父类索引（指向常量池中的类常量）
    u2 interfaces_count;                             //接口索引计数器
    u2 interfaces[interfaces_count];                 //接口索引集合
    u2 fields_count;                                 //字段数量计数器
    field_info fields[fields_count];                 //字段表集合
    u2 methods_count;                                //方法数量计数器
    method_info methods[methods_count];              //方法表集合
    u2 attributes_count;                             //属性个数
    attribute_info attributes[attributes_count];     //属性表
}
</code></pre>

<p>这明显已经不是以区段来分的格式了，上面提到的函数索引、常量字符串索引，都是保存在<code>constant_pool</code>常量池中。常量池中存储了很多信息，包括：</p>

<ul>
<li>各种字面常量，例如字符串</li>
<li>类、数据成员、接口引用</li>
</ul>


<p>常量池的索引从1开始。对于上面例子<code>Test.java</code>，可以使用<code>javap -v Test</code>来查看其中的常量池，例如：</p>

<pre><code>Constant pool:
   #1 = Methodref          #4.#13         //  java/lang/Object."&lt;init&gt;":()V
   #2 = String             #14            //  hello
   #3 = Class              #15            //  Test
   #4 = Class              #16            //  java/lang/Object
   #5 = Utf8               &lt;init&gt;
   #6 = Utf8               ()V
   #7 = Utf8               Code
   #8 = Utf8               LineNumberTable
   #9 = Utf8               main
  #10 = Utf8               ([Ljava/lang/String;)V
  #11 = Utf8               SourceFile
  #12 = Utf8               Test.java
  #13 = NameAndType        #5:#6          //  "&lt;init&gt;":()V
  #14 = Utf8               hello
  #15 = Utf8               Test
  #16 = Utf8               java/lang/Object
</code></pre>

<p>每一个类都会有一个常量池。</p>

<h2>summary</h2>

<p>要想了解JVM运行byte code，还需要了解更多JVM本身的东西，例如符号解析，内存管理等，可参考：</p>

<ul>
<li><a href="http://blog.jamesdbloom.com/JVMInternals.html">JVM Internals</a></li>
<li><a href="http://www.cubrid.org/blog/dev-platform/understanding-jvm-internals/">Understanding JVM Internals</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
