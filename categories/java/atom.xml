<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | loop in codes]]></title>
  <link href="http://codemacro.com/categories/java/atom.xml" rel="self"/>
  <link href="http://codemacro.com/"/>
  <updated>2015-06-07T17:59:18+08:00</updated>
  <id>http://codemacro.com/</id>
  <author>
    <name><![CDATA[Kevin Lynx]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[基于servlet实现一个web框架]]></title>
    <link href="http://codemacro.com/2015/06/07/servlet-web-framework/"/>
    <updated>2015-06-07T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/06/07/servlet-web-framework</id>
    <content type="html"><![CDATA[<p>servlet作为一个web规范，其本身就算做一个web开发框架，但是其web action (响应某个URI的实现)的实现都是基于类的，不是很方便，并且3.0之前的版本还必须通过web.xml配置来增加新的action。servlet中有一个filter的功能，可以配置所有URI的功能都经过filter。我们可以基于filter的功能来实现一个简单的web框架。在这个框架中，主要改进URI action的映射，就像<a href="https://www.playframework.com/">play framework</a>中route的配置：</p>

<pre><code>GET     /hello      com.codemacro.webdemo.test.TestController.hello
GET     /route      com.codemacro.webdemo.test.TestController.route
POST    /hello      com.codemacro.webdemo.test.TestController.sayHello
</code></pre>

<p>即把某个URI映射到类接口级别。基于servlet实现web框架的好处不仅实现简单，还能运行在所有支持servlet容器规范的web server上，例如Tomcat、Jetty。</p>

<p>本文提到的web framework demo可以从我的github 上取得：<a href="https://github.com/kevinlynx/servlet-web-framework-demo">servlet-web-framework-demo</a></p>

<h2>功能</h2>

<p>这个web framework URI action部分（或者说URI routing）如同前面描述，action的编写如：</p>

<p>{% highlight java %}
public class TestController extends BaseController {
  // 返回字符串
  public Result index() {
    return ok(&ldquo;hello world&rdquo;);
  }</p>

<p>  // HTTP 404
  public Result code404() {
    return status(404, &ldquo;not found&rdquo;);
  }</p>

<p>  // 使用JSP模板渲染
  public Result template() {
    String[] langs = new String[] {&ldquo;c++&rdquo;, &ldquo;java&rdquo;, &ldquo;python&rdquo;};
    return ok(jsp(&ldquo;index.jsp&rdquo;)
        .put(&ldquo;name&rdquo;, &ldquo;kevin&rdquo;)
        .put(&ldquo;langs&rdquo;,  langs)
        );
  }
}
{% endhighlight %}</p>

<!-- more -->


<p>有了action之后，配置<code>route</code>文件映射URI即可：</p>

<pre><code>GET /index  com.codemacro.webdemo.test.TestController.index
GET /404    com.codemacro.webdemo.test.TestController.code404
GET /index.jsp com.codemacro.webdemo.test.TestController.template
</code></pre>

<p>然后配置<code>web.xml</code>，增加一个filter：</p>

<pre><code>&lt;filter&gt;
  &lt;filter-name&gt;MyWebFilter&lt;/filter-name&gt;
  &lt;filter-class&gt;com.codemacro.webdemo.MyServletFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
  &lt;filter-name&gt;MyWebFilter&lt;/filter-name&gt;
  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>

<p>最后以war的形式部署到Jetty <code>webapps</code>下即可运行。想想下次要再找个什么lightweight Java web framework，直接用这个demo就够了。接下来讲讲一些关键部分的实现。</p>

<h2>servlet basic</h2>

<p>基于servlet开发的话，引入servlet api是必须的：</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
    &lt;version&gt;2.5&lt;/version&gt;
    &lt;type&gt;jar&lt;/type&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<p>servlet filter的接口包含：</p>

<p>{% highlight java %}
public class MyServletFilter implements Filter {
  // web app启动时调用一次，可用于web框架初始化
  public void init(FilterConfig conf) throws ServletException { }</p>

<p>  // 满足filter url-pattern时就会调用；req/res分别对应HTTP请求和回应
  public void doFilter(ServletRequest req, ServletResponse res,
    FilterChain chain) throws IOException, ServletException { }</p>

<p>  public void destroy() { }
}
{% endhighlight %}</p>

<p><code>init</code>接口可用于启动时载入<code>routes</code>配置文件，并建立URI到action的映射。</p>

<h2>action manager</h2>

<p><code>ActionManager</code>负责启动时载入<code>routes</code>配置，建立URI到action的映射。一个URI包含了HTTP method和URI String，例如<code>GET /index</code>。action既然映射到了类接口上，那么可以在启动时就同过Java反射找到对应的类及接口。简单起见，每次收到URI的请求时，就创建这个类对应的对象，然后调用映射的接口即可。</p>

<p>{% highlight java %}
// 例如：registerAction(&ldquo;com.codemacro.webdemo.test.TestController&rdquo;, &ldquo;index&rdquo;, &ldquo;/index&rdquo;, &ldquo;GET&rdquo;);
public void registerAction(String clazName, String methodName, String uri, String method) {
  try {
    uri = &ldquo;/&rdquo; + appName + uri;
    // 载入对应的class
    Class&lt;? extends BaseController> clazz = (Class&lt;? extends BaseController>) loadClass(clazName);
    // 取得对应的接口
    Method m = clazz.getMethod(methodName, (Class&lt;?>[])null);
    // 接口要求必须返回Result
    if (m.getReturnType() != Result.class) {
      throw new RuntimeException(&ldquo;action method return type mismatch: &rdquo; + uri);
    }
    ActionKey k = new ActionKey(uri, getMethod(method));
    ActionValue v = new ActionValue(clazz, m);
    logger.debug(&ldquo;register action {} {} {} {}&rdquo;, clazName, methodName, uri, method);
    // 建立映射
    actions.put(k, v);
  } catch (Exception e) {
    throw new RuntimeException(&ldquo;registerAction failed: &rdquo; + uri, e);
  }
}
{% endhighlight %}</p>

<p>controller都要求派生于<code>BaseController</code>，这样才可以利用<code>BaseController</code>更方便地获取请求数据之类，例如query string/cookie 等。</p>

<p>收到请求时，就需要根据请求的HTTP Method和URI string取得之前建立的映射，并调用之：</p>

<p>{% highlight java %}
public boolean invoke(HttpServletRequest req, HttpServletResponse resp) throws IOException {
  String uri = req.getRequestURI();
  String method = req.getMethod().toUpperCase();
  try {
    // 取得之前建立的映射，Map查找
    ActionValue v = getAction(uri, method);
    // 创建新的controller对象
    BaseController ctl = (BaseController) v.clazz.newInstance();
    ctl.init(req, resp, this);
    logger.debug(&ldquo;invoke action {}&rdquo;, uri);
    // 调用绑定的接口
    Result result = (Result) v.method.invoke(ctl, (Object[]) null);
    // 渲染结果
    result.render();
  } catch (Exception e) {
    &hellip;
  }
}
{% endhighlight %}</p>

<h2>结果渲染</h2>

<p>结果渲染无非就是把框架用户返回的结果渲染为字符串，写进<code>HttpServletResponse</code>。这个渲染过程可以是直接的<code>Object.toString</code>，或者经过模板引擎渲染，或者格式化为JSON。</p>

<p>通过实现具体的<code>Result</code>类，可以扩展不同的渲染方式，例如最基础的<code>Result</code>就是调用返回对象的<code>toString</code>：</p>

<p>{% highlight java %}
public class Result {
  public void render() throws IOException, ServletException {
    PrintWriter writer = response.getWriter();
    // result是controller action里返回的
    writer.append(result.toString());
    writer.close();
  }
}
{% endhighlight %}</p>

<p>为了简单，不引入第三方库，可以直接通过JSP来完成。JSP本身在servlet容器中就会被编译成一个servlet对象。</p>

<p>{% highlight java %}
public class JSPResult extends Result {
  &hellip;
  @Override
  public void render() throws IOException, ServletException {
    // 传入一些对象到模板中
    for (Map.Entry&lt;String, Object> entry : content.entrySet()) {
      request.setAttribute(entry.getKey(), entry.getValue());
    }
    // 委托给JSP来完成渲染
    request.getRequestDispatcher(file).forward(request, response);
  }
}
{% endhighlight %}</p>

<p>JSP中可以使用传统的scriptlets表达式，也可以使用新的EL方式，例如：</p>

<pre><code>&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%&gt;
&lt;h4&gt;By EL&lt;/h4&gt;
&lt;c:forEach var="lang" items="${langs}"&gt;
  &lt;span&gt;${lang}&lt;/span&gt;|
&lt;/c:forEach&gt;

&lt;% String[] langs = (String[]) request.getAttribute("langs"); %&gt;
&lt;% if (langs != null) { %&gt;
&lt;% for (String lang : langs) { %&gt;
  &lt;span&gt;&lt;%= lang %&gt;&lt;/span&gt;|
&lt;% } } %&gt;
</code></pre>

<p>使用EL的话需要引入<code>&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%&gt;</code></p>

<h2>BaseController</h2>

<p><code>BaseController</code>是一种template pattern实现，其包装了一些方便的接口给具体的controller使用，例如：</p>

<p>{% highlight java %}
public class BaseController {
  // 取得/index?name=kevin中的name参数值
  protected String getQueryString(String key) {
    return request.getParameter(key);
  }</p>

<p>  protected Result status(int code, String text) {
    response.setStatus(code);
    return new Result(response, text);
  }</p>

<p>  // 默认是HTTP 200
  protected Result ok(Object obj) {
    return new Result(response, obj);
  }</p>

<p>  protected Result ok(Result result) {
    return result;
  }</p>

<p>  protected JSPResult jsp(String file) {
    return new JSPResult(request, response, file, actionMgr);
  }
}
{% endhighlight %}</p>

<h2>Reverse routing</h2>

<p>Reverse routing指的是在开发web过程中，要引入某个URL时，我们不是直接写这个URL字符串，而是写其映射的接口，以使代码更易维护（因为URL可能会随着项目进展而改变）。并且，servlet app部署后URL会带上这个app的名字前缀，例如<code>/web-demo/index</code>中的<code>/web-demo</code>。在模板文件中，例如要链接到其他URI，更好的方式当然是直接写<code>/index</code>。</p>

<p>这里的实现比较丑陋，还是基于字符串的形式，例如：</p>

<pre><code>&lt;a href='&lt;route:reverse action="com.codemacro.webdemo.test.TestController.hello" name="kevin"/&gt;'&gt;index&lt;/a&gt;
</code></pre>

<p>通过自定义一个EL function <code>reverse</code>来实现。这里需要引入一个JSP的库：</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
    &lt;version&gt;2.0&lt;/version&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>

<p>首先实现一个<code>SimpleTagSupport</code>，为了支持<code>?name=kevin</code>这种动态参数，还需要<code>implements DynamicAttributes</code>：</p>

<p>{% highlight java %}
public class JSPRouteTag extends SimpleTagSupport implements DynamicAttributes {
  @Override
  // 输出最终的URL
  public void doTag() throws IOException {
    JspContext context = getJspContext();
    ActionManager actionMgr = (ActionManager) context.findAttribute(ACTION_MGR);
    JspWriter out = context.getOut();
    String uri = actionMgr.getReverseAction(action, attrMap);
    out.println(uri);
  }</p>

<p>  @Override
  // name=&ldquo;kevin&rdquo; 时调用
  public void setDynamicAttribute(String uri, String name, Object value) throws JspException {
    attrMap.put(name, value);
  }</p>

<p>  // <code>action="xxx"</code> 时会调用<code>setAction</code>
  public void setAction(String action) {
    this.action = action;
  }
}
{% endhighlight %}</p>

<p>为了访问到<code>ActionManager</code>，这里是通过写到<code>Request context</code>中实现的，相当hack。</p>

<p>{% highlight java %}
public JSPResult(HttpServletRequest req, HttpServletResponse resp, String file,
    ActionManager actionMgr) {
  super(resp, null);
  ..
  put(JSPRouteTag.ACTION_MGR, actionMgr);
}
{% endhighlight %}</p>

<p>第二步增加一个描述这个新tag的文件 <code>WEB-INF/route_tag.tld</code>：</p>

<pre><code>&lt;taglib&gt;
    &lt;tlibversion&gt;1.0&lt;/tlibversion&gt;
    &lt;jspversion&gt;1.1&lt;/jspversion&gt;
    &lt;shortname&gt;URLRouteTags&lt;/shortname&gt;
    &lt;uri&gt;/myweb-router&lt;/uri&gt;
    &lt;info&gt;&lt;/info&gt;

    &lt;tag&gt;
        &lt;name&gt;reverse&lt;/name&gt;
        &lt;tagclass&gt;com.codemacro.webdemo.result.JSPRouteTag&lt;/tagclass&gt;
        &lt;bodycontent&gt;&lt;/bodycontent&gt;
        &lt;info&gt;&lt;/info&gt;
        &lt;attribute&gt;
            &lt;name&gt;action&lt;/name&gt;
            &lt;required&gt;true&lt;/required&gt;
        &lt;/attribute&gt;
        &lt;dynamic-attributes&gt;true&lt;/dynamic-attributes&gt;
    &lt;/tag&gt;
&lt;/taglib&gt;
</code></pre>

<p>最后在需要使用的JSP中引入这个自定义tag：</p>

<pre><code>&lt;%@ taglib prefix="route" uri="/myweb-router" %&gt;
</code></pre>

<h2>参考资料</h2>

<ul>
<li><a href="http://www.cnblogs.com/cuiliang/archive/2011/10/21/2220671.html">Servlet生命周期与工作原理</a></li>
<li><a href="http://www.blogjava.net/fancydeepin/archive/2013/09/30/fan_servlet.html">JSP/Servlet工作原理</a></li>
<li><a href="http://www.cnblogs.com/xushuai123/archive/2013/03/24/2979711.html">EL表达式</a></li>
<li><a href="http://www.codedata.com.tw/java/java-tutorial-the-3rd-class-3-servlet-jsp/">使用Servlet、JSP开发Web程序</a></li>
<li><a href="http://www.itzhai.com/java-web-notes-servlet-filters-in-the-filter-writing-the-introduction-and-use-of-filters.html#read-more">Java Web笔记 – Servlet中的Filter过滤器的介绍和使用 编写过滤器</a></li>
<li><a href="http://blog.csdn.net/bingduanlbd/article/details/38349737">实现一个简单的Servlet容器</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中的反射及Bean容器的实现]]></title>
    <link href="http://codemacro.com/2015/05/31/java-refect-ioc/"/>
    <updated>2015-05-31T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/05/31/java-refect-ioc</id>
    <content type="html"><![CDATA[<p>编程语言中的反射(Refection)指的是可以在程序运行期动态加载一个类。与之相关的是自省(Introspection)，这个指的是程序自己可以获取一个类型的描述信息，例如获取一个类的所有接口定义、一个接口的所有形参。当编程语言有了这些语言特性之后，可以在很大程度上解决代码耦合问题，所以在Java的世界里，可以看到很多库/框架使用了反射技术。</p>

<p>类似Spring的Bean容器实现就是大量运用了反射机制。Bean容器维护了一些Bean对象，简单来说就是一些普通对象。Bean容器可以根据配置创建这些对象，创建时如果这些对象依赖了其他对象，Bean容器还会负责将依赖的对象注入到目标对象中，也就是所谓的依赖注入(dependence injection)。放在模块设计中，又衍生出控制反转(IoC, Inverse of Control)概念，用于描述应用程序在使用一个框架时，不是框架来控制/限制应用程序的架构模式，而是由应用程序来控制框架。</p>

<p>本文就简单描述下Bean容器是如何使用反射来实现的，最终代码参考<a href="https://github.com/kevinlynx/ioc-sample">github ioc-sample</a></p>

<h2>类的动态加载</h2>

<p>可以简单地使用<code>Class.forName</code>，传入某个class的完整名：</p>

<p>{% highlight java %}
public Class&lt;?> loadClass(String fullName) throws ClassNotFoundException {
  return Class.forName(fullName);
}
{% endhighlight %}</p>

<p>类的加载涉及到class loader，这块内容是可以进一步深化的。加载了类之后就可以创建出类的实例，但还没有完成依赖注入的功能：</p>

<p>{% highlight java %}
Class&lt;?> c = loadClass(&ldquo;com.codemacro.bean.test.Test1&rdquo;);
Object o = c.newInstance();
{% endhighlight %}</p>

<!-- more -->


<h2>通过set接口注入</h2>

<p>我们的类可以包含<code>set</code>接口，用于设置某个成员：</p>

<p>{% highlight java %}
public class Test2 {
  public Test1 test1;</p>

<p>  public void setTest1(Test1 t) {
    test1 = t;
  }
}
{% endhighlight %}</p>

<p>那么可以通过<code>setXXX</code>接口将<code>Test1</code>注入到<code>Test2</code>中：</p>

<p>{% highlight java %}
// props指定哪些成员需要注入，例如{&ldquo;Test1&rdquo;, &ldquo;test1&rdquo;}，Test1指的是setTest1，test1指的是bean名字
public Object buildWithSetters(String name, Class&lt;?> c, Map&lt;String, String> props) {
  try {
    // ClassSetMethods 类获取Class&lt;?>中所有setXX这种接口
    ClassSetMethods setMethods = new ClassSetMethods&copy;;
    Object obj = c.newInstance();
    for (Map.Entry&lt;String, String> entrys : props.entrySet()) {
      String pname = entrys.getKey();
      String beanName = entrys.getValue();
      // 取得setXXX这个Method
      Method m = setMethods.get(pname);
      Object val = getBean(beanName);
      // 调用
      m.invoke(obj, val);
    }
    beans.put(name, obj);
    return obj;
  } catch (Exception e) {
    throw new RuntimeException(&ldquo;build bean failed&rdquo;, e);
  }
}  <br/>
{% endhighlight %}</p>

<p><code>ClassSetMethod</code>自省出一个Class中所有的<code>setXXX(xx)</code>接口：</p>

<p>{% highlight java %}
public ClassSetMethods(Class&lt;?> c) {
  Method[] methods = c.getMethods();
  for (Method m : methods) {
    String mname = m.getName();
    Class&lt;?>[] ptypes = m.getParameterTypes();
    if (mname.startsWith(&ldquo;set&rdquo;) &amp;&amp; ptypes.length == 1 &amp;&amp; m.getReturnType() == Void.TYPE) {
      String name = mname.substring(&ldquo;set&rdquo;.length());
      this.methods.put(name, m);
    }
  }
}
{% endhighlight %}</p>

<p>以上就可以看出Java中的自省能力，例如<code>Class&lt;?&gt;.getMethods</code>、<code>Method.getReturnType</code>、<code>Method.getParameterTypes</code>。</p>

<h2>通过构造函数注入</h2>

<p>类似于Spring中的：</p>

<pre><code>&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
  &lt;constructor-arg type="int" value="2001"/&gt;
  &lt;constructor-arg type="java.lang.String" value="Zara"/&gt;
</code></pre>

<p>   </bean></p>

<p>可以将依赖的Bean通过构造函数参数注入到目标对象中：</p>

<p>{% highlight java %}
List<String> params = new ArrayList<String>();
params.add(&ldquo;test1&rdquo;);
bf.buildWithConstructor(&ldquo;test2&rdquo;, Test2.class, params);
{% endhighlight %}</p>

<p>其实现：</p>

<p>{% highlight java %}
public Object buildWithConstructor(String name, Class&lt;?> c, List<String> beanNames) {
  try {
    Constructor&lt;?>[] ctors = c.getConstructors(); // 取得Class构造函数列表
    assert ctors.length == 1;
    Constructor&lt;?> cc = ctors[0];
    Class&lt;?>[] ptypes = cc.getParameterTypes(); // 取得构造函数参数类型列表
    assert ptypes.length == beans.size();
    Object[] args = new Object[ptypes.length];
    for (int i = 0; i &lt; beanNames.size(); ++i) {
      args[i] = getBean(beanNames.get(i)); // 构造调用构造函数的实参列表
    }
    Object obj = cc.newInstance(args); // 通过构造函数创建对象
    beans.put(name, obj);
    return obj;
  } catch (Exception e) {
    throw new RuntimeException(&ldquo;build bean failed&rdquo;, e);
  }
}
{% endhighlight %}</p>

<p>这个接口的使用约定<code>beanNames</code>保存的是bean名称，并与构造函数参数一一对应。</p>

<h2>通过注解注入</h2>

<p>我们可以通过注解标注某个数据成员是需要被自动注入的。我这里简单地获取注解标注的成员类型，找到该类型对应的Bean作为注入对象。当然复杂点还可以指定要注入Bean的名字，或自动查找类型的派生类实现。</p>

<p>一个空的注解即可：</p>

<p>{% highlight java %}
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Inject {
}
{% endhighlight %}</p>

<p>实现：</p>

<p>{% highlight java %}</p>

<p>public Object buildWithInject(String name, Class&lt;?> c) {
  try {
    Object obj = c.newInstance();
    Field[] fields = c.getDeclaredFields(); // 获取该类所有定义的成员
    for (Field f :fields) {
      Inject inject = f.getAnnotation(Inject.class); // 获取数据成员的注解
      if (inject != null) { // 如果被Inject注解标注
        Object bean = getBeanByType(f.getType()); // 根据成员的类型找到对应的Bean
        f.set(obj, bean); // 注入
      } else {
        throw new RuntimeException(&ldquo;not found bean &rdquo; + f.getName());
      }
    }
    beans.put(name, obj);
    return obj;
  } catch (Exception e) {
    throw new RuntimeException(&ldquo;build bean failed&rdquo;, e);
  }
}
{% endhighlight %}</p>

<p><code>getBeanByType</code>就是根据<code>Class</code>匹配所有的Bean。使用时：</p>

<p>{% highlight java %}
public class Test2 {
  @Inject
  public Test1 test1;
  &hellip;
}
{% endhighlight %}</p>

<p>完。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Drill中实现HTTP storage plugin]]></title>
    <link href="http://codemacro.com/2015/05/30/drill-http-plugin/"/>
    <updated>2015-05-30T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/05/30/drill-http-plugin</id>
    <content type="html"><![CDATA[<p>Apache Drill可用于大数据的实时分析，引用一段介绍：</p>

<blockquote><p>受到Google Dremel启发，Apache的Drill项目是对大数据集进行交互式分析的分布式系统。Drill并不会试图取代已有的大数据批处理框架（Big Data batch processing framework），如Hadoop MapReduce或流处理框架（stream processing framework），如S4和Storm。相反，它是要填充现有空白的——对大数据集的实时交互式处理</p></blockquote>

<p>简单来说，Drill可接收SQL查询语句，然后后端从多个数据源例如HDFS、MongoDB等获取数据并分析产出分析结果。在一次分析中，它可以汇集多个数据源的数据。而且基于分布式的架构，可以支持秒级查询。</p>

<p>Drill在架构上是比较灵活的，它的前端可以不一定是SQL查询语言，后端数据源也可以接入Storage plugin来支持其他数据来源。这里我就实现了一个从HTTP服务获取数据的Storage plugin demo。这个demo可以接入基于GET请求，返回JSON格式的HTTP服务。源码可从我的Github获取：<a href="https://github.com/kevinlynx/drill-storage-http">drill-storage-http</a></p>

<p>例子包括：</p>

<pre><code>select name, length from http.`/e/api:search` where $p=2 and $q='avi'
select name, length from http.`/e/api:search?q=avi&amp;p=2` where length &gt; 0 
</code></pre>

<h2>实现</h2>

<p>要实现一个自己的storage plugin，目前Drill这方面文档几乎没有，只能从已有的其他storage plugin源码入手，例如mongodb的，参考Drill子项目<code>drill-mongo-storage</code>。实现的storage plugin打包为jar放到<code>jars</code>目录，Drill启动时会自动载入，然后web上配置指定类型即可。</p>

<p>主要需要实现的类包括：</p>

<pre><code>AbstractStoragePlugin
StoragePluginConfig
SchemaFactory
BatchCreator
AbstractRecordReader
AbstractGroupScan
</code></pre>

<!-- more -->


<h3>AbstraceStoragePlugin</h3>

<p><code>StoragePluginConfig</code>用于配置plugin，例如：</p>

<pre><code>{
  "type" : "http",
  "connection" : "http://xxx.com:8000",
  "resultKey" : "results",
  "enabled" : true
}
</code></pre>

<p>它必须是可JSON序列化/反序列化的，Drill会把storage配置存储到<code>/tmp/drill/sys.storage_plugins</code>中，例如windows下<code>D:\tmp\drill\sys.storage_plugins</code>。</p>

<p><code>AbstractStoragePlugin</code> 是plugin的主类，它必须配合<code>StoragePluginConfig</code>，实现这个类时，构造函数必须遵循参数约定，例如：</p>

<pre><code>public HttpStoragePlugin(HttpStoragePluginConfig httpConfig, DrillbitContext context, String name)
</code></pre>

<p>Drill启动时会自动扫描<code>AbstractStoragePlugin</code>实现类(<code>StoragePluginRegistry</code>)，并建立<code>StoragePluginConfig.class</code>到<code>AbstractStoragePlugin constructor</code>的映射。<code>AbstractStoragePlugin</code>需要实现的接口包括：</p>

<p>{% highlight java %}
    // 相应地需要实现AbstraceGroupScan
    // selection包含了database name和table name，可用可不用
    public AbstractGroupScan getPhysicalScan(String userName, JSONOptions selection)</p>

<pre><code>// 注册schema
public void registerSchemas(SchemaConfig schemaConfig, SchemaPlus parent) throws IOException

// StoragePluginOptimizerRule 用于优化Drill生成的plan，可实现也可不实现
public Set&lt;StoragePluginOptimizerRule&gt; getOptimizerRules() 
</code></pre>

<p>{% endhighlight %}</p>

<p>Drill中的schema用于描述一个database，以及处理table之类的事务，必须要实现，否则任意一个SQL查询都会被认为是找不到对应的table。<code>AbstraceGroupScan</code>用于一次查询中提供信息，例如查询哪些columns。</p>

<p>Drill在查询时，有一种中间数据结构(基于JSON)叫Plan，其中又分为Logic Plan和Physical Plan。Logic Plan是第一层中间结构，用于完整表达一次查询，是SQL或其他前端查询语言转换后的中间结构。完了后还要被转换为Physical Plan，又称为Exectuion Plan，这个Plan是被优化后的Plan，可用于与数据源交互进行真正的查询。<code>StoragePluginOptimizerRule</code>就是用于优化Physical Plan的。这些Plan最终对应的结构有点类似于语法树，毕竟SQL也可以被认为是一种程序语言。<code>StoragePluginOptimizerRule</code>可以被理解为改写这些语法树的。例如Mongo storage plugin就实现了这个类，它会把<code>where</code>中的filter转换为mongodb自己的filter(如{&lsquo;$gt&rsquo;: 2})，从而优化查询。</p>

<p>这里又牵扯出Apache的另一个项目：<a href="https://github.com/apache/incubator-calcite">calcite</a>，前身就是OptiQ。Drill中整个关于SQL的执行，主要是依靠这个项目。要玩转Plan的优化是比较难的，也是因为文档欠缺，相关代码较多。</p>

<h3>SchemaFactory</h3>

<p><code>registerSchemas</code>主要还是调用<code>SchemaFactory.registerSchemas</code>接口。Drill中的Schema是一种树状结构，所以可以看到<code>registerSchemas</code>实际就是往parent中添加child：</p>

<p>{% highlight java %}
    public void registerSchemas(SchemaConfig schemaConfig, SchemaPlus parent) throws IOException {
        HttpSchema schema = new HttpSchema(schemaName);
        parent.add(schema.getName(), schema);
    }
{% endhighlight %}</p>

<p><code>HttpSchema</code>派生于<code>AbstractSchema</code>，主要需要实现接口<code>getTable</code>，因为我这个http storage plugin中的table实际就是传给HTTP service的query，所以table是动态的，所以<code>getTable</code>的实现比较简单：</p>

<p>{% highlight java %}
    public Table getTable(String tableName) { // table name can be any of string
        HttpScanSpec spec = new HttpScanSpec(tableName); // will be pass to getPhysicalScan
        return new DynamicDrillTable(plugin, schemaName, null, spec);
    }
{% endhighlight %}</p>

<p>这里的<code>HttpScanSpec</code>用于保存查询中的一些参数，例如这里保存了table name，也就是HTTP service的query，例如<code>/e/api:search?q=avi&amp;p=2</code>。它会被传到<code>AbstraceStoragePlugin.getPhysicalScan</code>中的<code>JSONOptions</code>：</p>

<p>{% highlight java %}
    public AbstractGroupScan getPhysicalScan(String userName, JSONOptions selection) throws IOException {
        HttpScanSpec spec = selection.getListWith(new ObjectMapper(), new TypeReference<HttpScanSpec>() {});
        return new HttpGroupScan(userName, httpConfig, spec);
    }
{% endhighlight %}</p>

<p><code>HttpGroupScan</code>后面会看到用处。</p>

<h3>AbstractRecordReader</h3>

<p><code>AbstractRecordReader</code>负责真正地读取数据并返回给Drill。<code>BatchCreator</code>则是用于创建<code>AbstractRecordReader</code>。</p>

<p>{% highlight java %}
    public class HttpScanBatchCreator implements BatchCreator<HttpSubScan> {</p>

<pre><code>  @Override
  public CloseableRecordBatch getBatch(FragmentContext context,
      HttpSubScan config, List&lt;RecordBatch&gt; children)
      throws ExecutionSetupException {
    List&lt;RecordReader&gt; readers = Lists.newArrayList();
    readers.add(new HttpRecordReader(context, config));
    return new ScanBatch(config, context, readers.iterator());
  }
}
</code></pre>

<p>{% endhighlight %}</p>

<p>既然<code>AbstractRecordReader</code>负责真正读取数据，那么它肯定是需要知道传给HTTP service的query的，但这个query最早是在<code>HttpScanSpec</code>中，然后传给了<code>HttpGroupScan</code>，所以马上会看到<code>HttpGroupScan</code>又把参数信息传给了<code>HttpSubScan</code>。</p>

<p>Drill也会自动扫描<code>BatchCreator</code>的实现类，所以这里就不用关心<code>HttpScanBatchCreator</code>的来历了。</p>

<p><code>HttpSubScan</code>的实现比较简单，主要是用来存储<code>HttpScanSpec</code>的：</p>

<pre><code>public class HttpSubScan extends AbstractBase implements SubScan // 需要实现SubScan
</code></pre>

<p>回到<code>HttpGroupScan</code>，必须实现的接口：</p>

<p>{% highlight java %}
      public SubScan getSpecificScan(int minorFragmentId) { // pass to HttpScanBatchCreator
        return new HttpSubScan(config, scanSpec); // 最终会被传递到HttpScanBatchCreator.getBatch接口
      }
{% endhighlight %}</p>

<p>最终query被传递到<code>HttpRecordReader</code>，该类需要实现的接口包括：<code>setup</code>和<code>next</code>，有点类似于迭代器。<code>setup</code>中查询出数据，然后<code>next</code>中转换数据给Drill。转换给Drill时可以使用到<code>VectorContainerWriter</code>和<code>JsonReader</code>。这里也就是Drill中传说的vector数据格式，也就是列存储数据。</p>

<h3>总结</h3>

<p>以上，就包含了plugin本身的创建，及查询中query的传递。查询中类似<code>select titile, name</code> 中的columns会被传递到<code>HttpGroupScan.clone</code>接口，只不过我这里并不关注。实现了这些，就可以通过Drill查询HTTP service中的数据了。</p>

<p>而<code>select * from xx where xx</code>中的<code>where</code> filter，Drill自己会对查询出来的数据做过滤。如果要像mongo plugin中构造mongodb的filter，则需要实现<code>StoragePluginOptimizerRule</code>。</p>

<p>我这里实现的HTTP storage plugin，本意是觉得传给HTTP service的query可能会动态构建，例如：</p>

<pre><code>select name, length from http.`/e/api:search` where $p=2 and $q='avi' # p=2&amp;q=avi 就是动态构建，其值可以来源于其他查询结果
select name, length from http.`/e/api:search?q=avi&amp;p=2` where length &gt; 0  # 这里就是静态的
</code></pre>

<p>第一条查询就需要借助<code>StoragePluginOptimizerRule</code>，它会收集所有where中的filter，最终作为HTTP serivce的query。但这里的实现还不完善。</p>

<p>总体而言，由于Drill项目相对较新，要进行扩展还是比较困难的。尤其是Plan优化部分。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识JVM byte code]]></title>
    <link href="http://codemacro.com/2015/03/31/intro-java-bytecode/"/>
    <updated>2015-03-31T00:00:00+08:00</updated>
    <id>http://codemacro.com/2015/03/31/intro-java-bytecode</id>
    <content type="html"><![CDATA[<p>关于JVM和其上的byte code，网上其实有足够多的资料了，我这里就简单做个提纲和介绍，权当记录吧。</p>

<h2>stack-based VM</h2>

<p>Java byte code运行在JVM上，就像机器指令运行在物理机上，是需要遵循这个机器的指令规范的。所以认识JVM byte code，是需要稍微了解下JVM的。JVM是一个基于栈(stack-based)的虚拟机。很久以前我还写过类似<a href="http://www.cppblog.com/kevinlynx/archive/2010/04/15/112704.html">简单的虚拟机</a>。</p>

<p>基于栈的虚拟机其操作数和指令运算的中间结果全部都在一个虚拟栈中，与之对应的是基于寄存器(register-based)的虚拟机，其操作数和指令运算结果会存放在若干个寄存器（也就是存储单元）里。x86机器就可以理解为基于寄存器的机器。</p>

<p>byte code其实和x86汇编代码本质一样，无非是对应机器制定的一堆指令，这里可以举例说明下两类虚拟机的不同：</p>

<pre><code># stack-based 
push 1       # 压立即数1到栈顶
push 2       # 压立即数2到栈顶
add          # 弹出栈顶2个数相加，将结果3压到栈顶

# register-based
mov ax, 1    # 写立即数到寄存器ax
add ax, 2    # 取ax中的值1与立即数2进行相加，存放结果到ax
</code></pre>

<p>关于两类实现的比较，网上也有不少资料，例如<a href="http://www.zhihu.com/question/20207106">Dalvik 虚拟机和 Sun JVM 在架构和执行方面有什么本质区别？</a>。</p>

<!-- more -->


<p><em>至于有人说基于栈的虚拟机更利于移植，我不是很理解，因为即使是基于寄存器的实现，也不一定真的必须把这些寄存器映射到物理机CPU上的寄存器，使用内存来模拟性能上跟基于栈的方式不是八九不离十吗？</em></p>

<p>了解了JVM的这个特点，JVM上的各种指令就可以更好地理解，如果要理解JVM如何运行byte code的，那还需要了解JVM内部的各种结构，例如符号解析、class loader、内存分配甚至垃圾回收等。这个以后再谈。</p>

<h2>byte-code</h2>

<p><code>*.class</code>文件就已经是编译好的byte code文件，就像C/C++编译出来的目标文件一样，已经是各种二进制指令了。这个时候可以通过JDK中带的<code>javap</code>工具来反汇编，以查看对应的byte code。</p>

<p>{% highlight java %}
    // Test.java
    public class Test {
        public static void main(String[] args) {
            int a = 0xae;
            int b = 0x10;
            int c = a + b;
            int d = c + 1;
            String s;
            s = &ldquo;hello&rdquo;;
        }
    }
{% endhighlight %}</p>

<p>编译该文件：<code>javac Test.java</code>得到<code>Test.class</code>，然后<code>javap -c Test</code>即得到：</p>

<pre><code>Compiled from "Test.java"
public class Test {
  public Test();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: sipush        174           # push a short onto the stack 0xae=174
       3: istore_1                    # store int value into variable 1: a = 0xae
       4: bipush        16            # push a byte onto the stack 0x10=16
       6: istore_2                    # store int value into variable 2: b = 0x10
       7: iload_1                     # load value from variable 1 and push onto the stack
       8: iload_2                   
       9: iadd                        # add two ints: a + b
      10: istore_3                    # c = a + b
      11: iload_3                     
      12: iconst_1                    # 1
      13: iadd                        # c + 1
      14: istore        4             # d = c + 1
      16: ldc           #2                  // String hello
      18: astore        5
      20: return
}
</code></pre>

<p>这个时候对照着JVM指令表看上面的代码，比起x86汇编浅显易懂多了，秒懂，参考<a href="http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings">Java bytecode instruction listings</a>。JVM中每个指令只占一个字节，操作数是变长的，所以其一条完整的指令（操作码+操作数）也是变长的。上面每条指令前都有一个偏移，实际是按字节来偏移的。<em>想起Lua VM的指令竟然是以bit来干的</em></p>

<p>从上面的byte code中，以x86汇编的角度来看会发现一些不同的东西：</p>

<ul>
<li>局部变量竟是以索引来区分：<code>istore_1</code> 写第一个局部变量，<code>istore_2</code>写第二个局部变量，第4个局部变量则需要用操作数来指定了：<code>istore 4</code></li>
<li>函数调用<code>invokespecial #1</code>竟然也是类似的索引，这里调用的是<code>Object</code>基类构造函数</li>
<li>常量字符串也是类似的索引：<code>ldc #2</code></li>
<li><code>*.class</code>中是不是也分了常量数据段和代码段呢</li>
</ul>


<p>以上需要我们进一步了解<code>*.class</code>文件的格式。</p>

<h2>class file format</h2>

<p>class 文件格式网上也有讲得很详细的了，例如这篇<a href="http://www.importnew.com/15161.html">Java Class文件详解</a>。整个class文件完全可以用以下结构来描述：</p>

<pre><code>ClassFile {
    u4 magic;                                        //魔数
    u2 minor_version;                                //次版本号
    u2 major_version;                                //主版本号
    u2 constant_pool_count;                          //常量池大小
    cp_info constant_pool[constant_pool_count-1];    //常量池
    u2 access_flags;                                 //类和接口层次的访问标志（通过|运算得到）
    u2 this_class;                                   //类索引（指向常量池中的类常量）
    u2 super_class;                                  //父类索引（指向常量池中的类常量）
    u2 interfaces_count;                             //接口索引计数器
    u2 interfaces[interfaces_count];                 //接口索引集合
    u2 fields_count;                                 //字段数量计数器
    field_info fields[fields_count];                 //字段表集合
    u2 methods_count;                                //方法数量计数器
    method_info methods[methods_count];              //方法表集合
    u2 attributes_count;                             //属性个数
    attribute_info attributes[attributes_count];     //属性表
}
</code></pre>

<p>这明显已经不是以区段来分的格式了，上面提到的函数索引、常量字符串索引，都是保存在<code>constant_pool</code>常量池中。常量池中存储了很多信息，包括：</p>

<ul>
<li>各种字面常量，例如字符串</li>
<li>类、数据成员、接口引用</li>
</ul>


<p>常量池的索引从1开始。对于上面例子<code>Test.java</code>，可以使用<code>javap -v Test</code>来查看其中的常量池，例如：</p>

<pre><code>Constant pool:
   #1 = Methodref          #4.#13         //  java/lang/Object."&lt;init&gt;":()V
   #2 = String             #14            //  hello
   #3 = Class              #15            //  Test
   #4 = Class              #16            //  java/lang/Object
   #5 = Utf8               &lt;init&gt;
   #6 = Utf8               ()V
   #7 = Utf8               Code
   #8 = Utf8               LineNumberTable
   #9 = Utf8               main
  #10 = Utf8               ([Ljava/lang/String;)V
  #11 = Utf8               SourceFile
  #12 = Utf8               Test.java
  #13 = NameAndType        #5:#6          //  "&lt;init&gt;":()V
  #14 = Utf8               hello
  #15 = Utf8               Test
  #16 = Utf8               java/lang/Object
</code></pre>

<p>每一个类都会有一个常量池。</p>

<h2>summary</h2>

<p>要想了解JVM运行byte code，还需要了解更多JVM本身的东西，例如符号解析，内存管理等，可参考：</p>

<ul>
<li><a href="http://blog.jamesdbloom.com/JVMInternals.html">JVM Internals</a></li>
<li><a href="http://www.cubrid.org/blog/dev-platform/understanding-jvm-internals/">Understanding JVM Internals</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
