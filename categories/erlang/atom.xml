<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: erlang | loop in codes]]></title>
  <link href="http://codemacro.com/categories/erlang/atom.xml" rel="self"/>
  <link href="http://codemacro.com/"/>
  <updated>2013-05-09T21:13:40+08:00</updated>
  <id>http://codemacro.com/</id>
  <author>
    <name><![CDATA[Kevin Lynx]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[erlang使用感受]]></title>
    <link href="http://codemacro.com/2013/05/08/thought-about-erlang/"/>
    <updated>2013-05-08T00:00:00+08:00</updated>
    <id>http://codemacro.com/2013/05/08/thought-about-erlang</id>
    <content type="html"><![CDATA[<p>用erlang也算写了些代码了，主要包括<a href="http://codemacro.com/2013/04/11/rabbitmq-erlang/">使用RabbitMQ的练习</a>，以及最近写的<a href="https://github.com/kevinlynx/erlang-tcpserver">kl_tserver</a>和<a href="https://github.com/kevinlynx/icerl">icerl</a>。其中icerl是一个实现了<a href="http://www.zeroc.com/">Ice</a>的erlang库。</p>

<p>erlang的书较少，我主要读过&lt;Programming Erlang>和&lt;Erlang/OTP in Action>。其实erlang本身就语言来说的话比较简单，同ruby一样，类似这种本身目标是应用于实际软件项目的语言都比较简单，对应的语法书很快可以翻完。</p>

<p>这里我仅谈谈自己在编写erlang代码过程中的一些感受。</p>

<h2>语法</h2>

<p>erlang语法很简单，接触过函数式语言的程序员上手会很快。它没有类似common lisp里宏这种较复杂的语言特性。其语法元素很紧凑，不存在一些用处不大的特性。在这之前，我学习过ruby和common lisp。ruby代码写的比common lisp多。但是在学习erlang的过程中我的脑海里却不断出现common lisp里的语法特性。这大概是因为common lisp的语法相对ruby来说，更接近erlang。</p>

<h3>编程模式</h3>

<p>erlang不是一个面向对象的语言，它也不同common lisp提供多种编程模式。它的代码就是靠一个个函数组织出来的。面向对象语言在语法上有一点让我很爽的是，其函数调用更自然。erlang的接口调用就像C语言里接口的调用一样：</p>

<pre><code>func(Obj, args)
Obj-&gt;func(args)
</code></pre>

<p>即需要在函数第一个参数传递操作对象。但是面向对象语言也会带来一些语法的复杂性。如果一门语言可以用很少的语法元素表达很多信息，那么我觉得这门语言就是门优秀的语言。</p>

<h3>表达式/语句</h3>

<p>erlang里没有语句，全部是表达式，意思是所有语法元素都是有返回值的。这实在太好了，全世界都有返回值可以让代码写起来简单多了：</p>

<p><div class="highlight"><pre><code class="erlang"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nv">Flag</span> <span class="o">=</span> <span class="k">case</span> <span class="n">func</span><span class="p">()</span> <span class="k">of</span> <span class="mi">1</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">true</span><span class="p">;</span> <span class="mi">0</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">false</span> <span class="k">end</span><span class="p">,</span> 
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div></p>

<!-- more -->


<h3>命名</h3>

<p>我之所以不想写一行python代码的很大一部分原因在于这门语言居然要求我必须使用代码缩进来编程，真是不敢相信。erlang里虽然没有此规定，却也有不同的语法元素有大小写的限定。变量首字母必须大写，atom必须以小写字母开头，更霸气的是模块命名必须和文件名相同。</p>

<h3>变量</h3>

<p>erlang里的变量是不可更改的。实际上给一个变量赋值，严格来说应该叫<code>bound</code>，即绑定。这个特性完全就是函数式语言里的特性。其带来的好处就像函数式语言宣扬的一样，这会使得代码没有副作用(side effect)。因为程序里的所有函数不论怎样调用，其程序状态都不会改变，因为变量无法被改变。</p>

<p>变量不可更改，直接意味着全局变量没有存在的意义，也就意味着不论你的系统是多么复杂地被构建出来，当系统崩溃时，其崩溃所在位置的上下文就足够找到问题。</p>

<p>但是变量不可改变也会带来一些代码编写上的不便。我想这大概是编程思维的转变问题。erlang的语法特性会强迫人编写非常短小的函数，你大概不愿意看到你的函数实现里出现Var1/Var2/Var3这样的变量，而实际上这样的命名在命令式语言里其实指的是同一个变量，只不过其值不同而已。</p>

<p>但是我们的程序总是应该有状态的。在erlang里我们通过不断创建新的变量来存储这个状态。我们需要通过将这个状态随着我们的程序流程不断地通过函数参数和返回值传递下去。</p>

<h3>atom</h3>

<p>atom这个语法特性本身没问题，它就同lisp里的atom一样，没什么意义，就是一个名字。它主要用在增加代码的可读性上。但是这个atom带来的好处，直接导致erlang不去内置诸如true/false这种关键字。erlang使用true/false这两个atom来作为boolean operator的返回值。但erlang里严格来说是没有布尔类型的。这其实没什么，糟糕的是，对于一些较常见的函数返回值，例如true/false，erlang程序员之间就得做约定。要表示一个函数执行失败了，我可以返回false、null、failed、error、nil，甚至what_the_fuck，这一度让我迷惘。</p>

<h3>list/tuple</h3>

<p>erlang里的list当然没有lisp里的list牛逼，别人整个世界就是由list构成的。在一段时间里，我一直以为list里只能保存相同类型的元素，而tuple才是用于保存不同类型元素的容器。直到有一天我发现tuple的操作不能满足我的需求了，我才发现list居然是可以保存不同类型的。</p>

<p>list相对于tuple而言，更厉害的地方就在于头匹配，意思是可以通过匹配来拆分list的头和剩余部分。</p>

<h3>匹配(match)</h3>

<p>erlang的匹配机制是个好东西。这个东西贯穿了整个语言。在我理解看来，匹配机制减少了很多判断代码。它试图用一个期望的类型去匹配另一个东西，如果这个东西出了错，它就无法完成这个匹配。无法完成匹配就导致程序断掉。</p>

<p>匹配还有个方便的地方在于可以很方便地取出record里的成员，或者tuple和list的某个部分，这其实增强了其他语法元素的能力。</p>

<h3>循环</h3>

<p>erlang里没有循环语法元素，这真是太好了。函数式语言里为什么要有循环语法呢？common lisp干毛要加上那些复杂的循环（宏），每次我遇到需要写循环的场景时，我都诚惶诚恐，最后还是用递归来解决。</p>

<p>同样，在erlang里我们也是用函数递归来解决循环问题。甚至，我们还有list comprehension。当我写C++代码时，我很不情愿用循环去写那些容器遍历代码，幸运的是在C++11里通过lambda和STL里那些算法我终于不用再写这样的循环代码了。</p>

<h3>if/case/guard</h3>

<p>erlang里有条件判定语法if，甚至还有类似C语言里的switch...case。这个我一时半会还不敢评价，好像haskell里也保留了if。erlang里同haskell一样有guard的概念，这其实是一种变相的条件判断，只不过其使用场景不一样。</p>

<h3>进程</h3>

<p>并发性支持属于erlang的最大亮点。erlang里的进程概念非常简单，基于消息机制，程序员从来不需要担心同步问题。每个进程都有一个mailbox，用于缓存发送到此进程的消息。erlang提供内置的语法元素来发送和接收消息。</p>

<p>erlang甚至提供分布式支持，更酷的是你往网络上的其他进程发送消息，其语法和往本地进程发送是一样的。</p>

<h3>模块加载</h3>

<p>如果我写了一个erlang库，该如何在另一个erlang程序里加载这个库？这个问题一度让我迷惘。erlang里貌似有对库打包的功能(.ez?)，按理说应该提供一种整个库加载的方式，然后可以通过手动调用函数或者指定代码依赖项来加载。结果不是这样。</p>

<p>erlang不是按整个库来加载的，因为也没有方式去描述一个库（应该有第三方的）。当我们调用某个模块里的函数时，erlang会自动从某个目录列表里去搜索对应的beam文件。所以，可以通过在启动erlang添加这个模块文件所在目录来实现加载，这还是自动的。当然，也可以在erlang shell里通过函数添加这个目录。</p>

<h2>OTP</h2>

<p>使用erlang来编写程序，最大的优势可能就是其OTP了。OTP基本上就是一些随erlang一起发布的库。这些库中最重要的一个概念是behaviour。behaviour其实就是提供了一种编程框架，应用层提供各种回调函数给这个框架，从而获得一个健壮的并发程序。</p>

<h3>application behaviour</h3>

<p>application behaviour用于组织一个erlang程序，通过一个配置文件，和提供若干回调，就可以让我们编写的erlang程序以一种统一的方式启动。我之前写的都是erlang库，并不需要启动，而是提供给应用层使用，所以也没使用该behaviour。</p>

<h3>gen_server behaviour</h3>

<p>这个behaviour应该是使用频率很高的。它封装了进程使用的细节，本质上也就是将主动收取消息改成了自动收取，收取后再回调给你的模块。</p>

<h3>supervisor behaviour</h3>

<p>这个behaviour看起来很厉害，通过对它进行一些配置，你可以把你的并发程序里的所有进程建立成树状结构。这个结构的牛逼之处在于，当某个进程挂掉之后，通过supervisor可以自动重新启动这个挂掉的进程，当然重启没这么简单，它提供多种重启规则，以让整个系统确实通过重启变成正常状态。这实在太牛逼了，这意味着你的服务器可以7x24小时地运行了，就算有问题你也可以立刻获得一个重写工作的系统。</p>

<h3>热更新</h3>

<p>代码热更新对于一个动态语言而言其实根本算不上什么优点，基本上动态语言都能做到这一点。但是把热更新这个功能加到一个用于开发并发程序的语言里，那就很牛逼了。你再一次可以确保你的服务器7x24小时不停机维护。</p>

<h3>gen_tcp</h3>

<p>最开始我以为erlang将网络部分封装得已经认不出有socket这个概念了。至少，你也得有一个牛逼的网络库吧。结果发现依然还是socket那一套。然后我很失望。直到后来，发现使用一些behaviour，加上调整gen_tcp的一些option，居然可以以很少的代码写出一个维护大量连接的TCP服务器。是啊，erlang天生就是并发的，在传统的网络模型中，我们会觉得使用one-thread-per-connection虽然简单却不是可行的，因为thread是OS资源，太昂贵。但是在erlang里，one-process-per-connection却是再自然不过的事情。你要是写个erlang程序里面却只有一个process你都不好意思告诉别人你写的是erlang。process是高效的（对我们这种二流程序员而言），它就像C++里一个很普通的对象一样。</p>

<p>在使用gen_tcp的过程中我发现一个问题，不管我使用哪一种模型，我竟然找不到一种温柔的关闭方式。我查看了几个tutorial，这些混蛋竟然没有一个人提到如何去正常关闭一个erlang TCP服务器。后来，我没有办法，只好使用API强制关闭服务器进程。</p>

<h2>Story</h2>

<p>其实，我和erlang之间是有故事的。我并不是这个月开始才接触erlang。早在2009年夏天的时候我就学习过这门语言。那时候我还没接触过任何函数式语言，那时候lua里的闭包都让我觉得新奇。然后无意间，我莫名其妙地接触了haskell（&lt;Real World Haskell>），在我决定开始写点什么haskell练习时，我发现我无从下手，最后，Monads把我吓哭了。haskell实在太可怕了。</p>

<p>紧接着我怀揣着对函数式语言的浓烈好奇心看到了erlang。当我看到了concurrent programming的章节时，在一个燥热难耐的下午我的领导找到了我，同我探讨起erlang对我们的网游服务器有什么好处。然后，我结束我了的erlang之旅。</p>

<p>时隔四年，这种小众语言，居然进入了中国程序员的视野，并被用于开发网页游戏服务器。时代在进步，我们总是被甩在后面。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[erlang和RabbitMQ学习总结]]></title>
    <link href="http://codemacro.com/2013/04/11/rabbitmq-erlang/"/>
    <updated>2013-04-11T00:00:00+08:00</updated>
    <id>http://codemacro.com/2013/04/11/rabbitmq-erlang</id>
    <content type="html"><![CDATA[<h2>AMQP和RabbitMQ概述</h2>

<p><a href="http://www.amqp.org/">AMQP</a>(Advanced Message Queue Protocol)定义了一种消息系统规范。这个规范描述了在一个分布式的系统中各个子系统如何通过消息交互。而<a href="http://www.rabbitmq.com/">RabbitMQ</a>则是AMQP的一种基于erlang的实现。</p>

<p>AMQP将分布式系统中各个子系统隔离开来，子系统之间不再有依赖。子系统仅依赖于消息。子系统不关心消息的发送者，也不关心消息的接受者。</p>

<p>AMQP中有一些概念，用于定义与应用层的交互。这些概念包括：message、queue、exchange、channel, connection, broker、vhost。</p>

<p><em>注：到目前为止我并没有打算使用AMQP，所以没有做更深入的学习，仅为了找个机会写写erlang代码，以下信息仅供参考。</em></p>

<ul>
<li>message，即消息，简单来说就是应用层需要发送的数据</li>
<li>queue，即队列，用于存储消息</li>
<li>exchange，有翻译为“路由”，它用于投递消息，<strong>应用程序在发送消息时并不是指定消息被发送到哪个队列，而是将消息投递给路由，由路由投递到队列</strong></li>
<li>channel，几乎所有操作都在channel中进行，有点类似一个沟通通道</li>
<li>connection，应用程序与broker的网络连接</li>
<li>broker，可简单理解为实现AMQP的服务，例如RabbitMQ服务</li>
</ul>


<p>关于AMQP可以通过一篇很有名的文章了解更多：<a href="http://blog.ftofficer.com/2010/03/translation-rabbitmq-python-rabbits-and-warrens/">RabbitMQ+Python入门经典 兔子和兔子窝</a></p>

<p>RabbitMQ的运行需要erlang的支持，erlang和RabbitMQ在windows下都可以直接使用安装程序，非常简单。RabbitMQ还支持网页端的管理，这需要开启一些RabbitMQ的插件，可以参考<a href="http://www.rabbitmq.com/management.html">官方文档</a>。</p>

<p>RabbitMQ本质上其实是一个服务器，与这个服务器做交互则是通过AMQP定义的协议，应用可以使用一个实现了AMQP协议的库来与服务器交互。这里我使用erlang的一个客户端，对应着RabbitMQ的tutorial，使用erlang实现了一遍。基于这个过程我将一些关键实现罗列出来以供记忆：</p>

<!-- more -->


<h2>主要功能使用</h2>

<p>关于RabbitMQ erlang client的使用说明可以参考<a href="http://www.rabbitmq.com/erlang-client-user-guide.html">官方文档</a>。这个client library下载下来后是两个ez文件，其实就是zip文件，本身是erlang支持的库打包格式，但据说这个feature还不成熟。总之我是直接解压，然后在环境变量中指定<code>ERL_LIBS</code>到解压目录。使用时使用<code>include_lib</code>包含库文件（类似C语言里的头文件）：</p>

<p><div class="highlight"><pre><code class="erlang"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;-</span><span class="n">include_lib</span><span class="p">(</span><span class="s">&quot;amqp_client/include/amqp_client.hrl&quot;</span><span class="p">).</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div></p>

<h3>Connection/Channel</h3>

<p>对于连接到本地的RabbitMQ服务：</p>

<p><div class="highlight"><pre><code class="erlang"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Connection</span><span class="p">}</span> <span class="o">=</span> <span class="nn">amqp_connection</span><span class="p">:</span><span class="nf">start</span><span class="p">(</span><span class="nl">#amqp_params_network</span><span class="p">{}),</span>
<span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Channel</span><span class="p">}</span> <span class="o">=</span> <span class="nn">amqp_connection</span><span class="p">:</span><span class="nf">open_channel</span><span class="p">(</span><span class="nv">Connection</span><span class="p">),</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div></p>

<h3>创建Queue</h3>

<p>每个Queue都有名字，这个名字可以人为指定，也可以由系统分配。Queue创建后如果不显示删除，断开网络连接是不会自动删除这个Queue的，这个可以在RabbitMQ的web管理端看到。</p>

<p><div class="highlight"><pre><code class="erlang"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nl">#&#39;queue.declare_ok&#39;</span><span class="p">{</span><span class="n">queue</span> <span class="o">=</span> <span class="nv">Q</span><span class="p">}</span>
    <span class="o">=</span> <span class="nn">amqp_channel</span><span class="p">:</span><span class="nf">call</span><span class="p">(</span><span class="nv">Channel</span><span class="p">,</span> <span class="nl">#&#39;queue.declare&#39;</span><span class="p">{</span><span class="n">queue</span> <span class="o">=</span> <span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="s">&quot;rpc_queue&quot;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;}),</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div></p>

<p>但也可以指定Queue会在程序退出后被自动删除，需要指定<code>exclusive</code>参数：</p>

<p><div class="highlight"><pre><code class="erlang"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nv">QDecl</span> <span class="o">=</span> <span class="nl">#&#39;queue.declare&#39;</span><span class="p">{</span><span class="n">queue</span> <span class="o">=</span> <span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;,</span> <span class="n">exclusive</span> <span class="o">=</span> <span class="n">true</span><span class="p">},</span>
<span class="nl">#&#39;queue.declare_ok&#39;</span><span class="p">{</span><span class="n">queue</span> <span class="o">=</span> <span class="nv">Q</span><span class="p">}</span> <span class="o">=</span> <span class="nn">amqp_channel</span><span class="p">:</span><span class="nf">call</span><span class="p">(</span><span class="nv">Channel</span><span class="p">,</span> <span class="nv">QDecl</span><span class="p">),</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div></p>

<p>上例中queue的名字未指定，由系统分配。</p>

<h3>发送消息</h3>

<p>一般情况下，消息其实是发送给exchange的：</p>

<p><div class="highlight"><pre><code class="erlang"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nv">Payload</span> <span class="o">=</span> <span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="s">&quot;hello&quot;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span>
<span class="nv">Publish</span> <span class="o">=</span> <span class="nl">#&#39;basic.publish&#39;</span><span class="p">{</span><span class="n">exchange</span> <span class="o">=</span> <span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="s">&quot;log_exchange&quot;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;},</span>
<span class="nn">amqp_channel</span><span class="p">:</span><span class="nf">cast</span><span class="p">(</span><span class="nv">Channel</span><span class="p">,</span> <span class="nv">Publish</span><span class="p">,</span> <span class="nl">#amqp_msg</span><span class="p">{</span><span class="n">payload</span> <span class="o">=</span> <span class="nv">Payload</span><span class="p">}),</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div></p>

<p>exchange有一系列规则，决定某个消息将被投递到哪个队列。</p>

<p>发送消息时也可以不指定exchange，这个时候消息的投递将依赖于<code>routing_key</code>，<code>routing_key</code>在这种场景下就对应着目标queue的名字：</p>

<p><div class="highlight"><pre><code class="erlang"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nl">#&#39;queue.declare_ok&#39;</span><span class="p">{</span><span class="n">queue</span> <span class="o">=</span> <span class="nv">Q</span><span class="p">}</span>
    <span class="o">=</span> <span class="nn">amqp_channel</span><span class="p">:</span><span class="nf">call</span><span class="p">(</span><span class="nv">Channel</span><span class="p">,</span> <span class="nl">#&#39;queue.declare&#39;</span><span class="p">{</span><span class="n">queue</span> <span class="o">=</span> <span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="s">&quot;rpc_queue&quot;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;}),</span>
<span class="nv">Payload</span> <span class="o">=</span> <span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="s">&quot;hello&quot;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;,</span>
<span class="nv">Publish</span> <span class="o">=</span> <span class="nl">#&#39;basic.publish&#39;</span><span class="p">{</span><span class="n">exchange</span> <span class="o">=</span> <span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;,</span> <span class="n">routing_key</span> <span class="o">=</span> <span class="nv">Q</span><span class="p">},</span>
<span class="nn">amqp_channel</span><span class="p">:</span><span class="nf">cast</span><span class="p">(</span><span class="nv">Channel</span><span class="p">,</span> <span class="nv">Publish</span><span class="p">,</span> <span class="nl">#amqp_msg</span><span class="p">{</span><span class="n">payload</span> <span class="o">=</span> <span class="nv">Payload</span><span class="p">}),</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div></p>

<h3>接收消息</h3>

<p>可以通过注册一个消息consumer来完成消息的异步接收：</p>

<p><div class="highlight"><pre><code class="erlang"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nv">Sub</span> <span class="o">=</span> <span class="nl">#&#39;basic.consume&#39;</span> <span class="p">{</span><span class="n">queue</span> <span class="o">=</span> <span class="nv">Q</span><span class="p">},</span>
<span class="nl">#&#39;basic.consume_ok&#39;</span><span class="p">{</span><span class="n">consumer_tag</span> <span class="o">=</span> <span class="nv">Tag</span><span class="p">}</span> <span class="o">=</span> <span class="nn">amqp_channel</span><span class="p">:</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">Channel</span><span class="p">,</span> <span class="nv">Sub</span><span class="p">,</span> <span class="n">self</span><span class="p">()),</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div></p>

<p>以上注册了了一个consumer，监听变量<code>Q</code>指定的队列。当有消息到达该队列时，系统就会向consumer进程对应的mailbox投递一个通知，我们可以使用<code>receive</code>来接收该通知：</p>

<p><div class="highlight"><pre><code class="erlang"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">loop</span><span class="p">(</span><span class="nv">Channel</span><span class="p">)</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span>
    <span class="k">receive</span> 
        <span class="c">% This is the first message received (from RabbitMQ)</span>
        <span class="nl">#&#39;basic.consume_ok&#39;</span><span class="p">{}</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> 
            <span class="n">loop</span><span class="p">(</span><span class="nv">Channel</span><span class="p">);</span>
        <span class="c">% a delivery</span>
        <span class="p">{</span><span class="nl">#&#39;basic.deliver&#39;</span><span class="p">{</span><span class="n">delivery_tag</span> <span class="o">=</span> <span class="nv">Tag</span><span class="p">},</span> <span class="nl">#amqp_msg</span><span class="p">{</span><span class="n">payload</span> <span class="o">=</span> <span class="nv">Payload</span><span class="p">}}</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span>
            <span class="n">echo</span><span class="p">(</span><span class="nv">Payload</span><span class="p">),</span>
            <span class="c">% ack the message</span>
            <span class="nn">amqp_channel</span><span class="p">:</span><span class="nf">cast</span><span class="p">(</span><span class="nv">Channel</span><span class="p">,</span> <span class="nl">#&#39;basic.ack&#39;</span><span class="p">{</span><span class="n">delivery_tag</span> <span class="o">=</span> <span class="nv">Tag</span><span class="p">}),</span>
            <span class="n">loop</span><span class="p">(</span><span class="nv">Channel</span><span class="p">);</span>
    <span class="p">...</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div></p>

<h3>绑定exchange和queue</h3>

<p>绑定(binding)其实也算AMQP里的一个关键概念，它用于建立exchange和queue之间的联系，以方便exchange在收到消息后将消息投递到队列。我们不一定需要将队列和exchange绑定起来。</p>

<p><div class="highlight"><pre><code class="erlang"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nv">Binding</span> <span class="o">=</span> <span class="nl">#&#39;queue.bind&#39;</span><span class="p">{</span><span class="n">queue</span> <span class="o">=</span> <span class="nv">Queue</span><span class="p">,</span> <span class="n">exchange</span> <span class="o">=</span> <span class="nv">Exchange</span><span class="p">,</span> <span class="n">routing_key</span> <span class="o">=</span> <span class="nv">RoutingKey</span><span class="p">},</span>
<span class="nl">#&#39;queue.bind_ok&#39;</span><span class="p">{}</span> <span class="o">=</span> <span class="nn">amqp_channel</span><span class="p">:</span><span class="nf">call</span><span class="p">(</span><span class="nv">Channel</span><span class="p">,</span> <span class="nv">Binding</span><span class="p">)</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div></p>

<p>在绑定的时候需要填入一个<code>routing_key</code>的参数，不同类型的exchange对该值的处理方式不一样，例如后面提到<code>fanout</code>类型的exchange时，就不需要该值。</p>

<h2>更多细节</h2>

<p>通过阅读<a href="http://www.rabbitmq.com/getstarted.html">RabbitMQ tutorial</a>，我们还会获得很多细节信息。例如exchange的种类、binding等。</p>

<h3>exchange分类</h3>

<p>exchange有四种类型，不同类型决定了其在收到消息后，该如何处理这条消息（投递规则），这四种类型为：</p>

<ul>
<li>fanout</li>
<li>direct</li>
<li>topic</li>
<li>headers</li>
</ul>


<p><strong>fanout</strong>类型的exchange是一个广播exchange，它在收到消息后会将消息广播给所有绑定到它上面的队列。绑定(binding)用于将队列和exchange关联起来。我们可以在创建exchange的时候指定exchange的类型：</p>

<p><div class="highlight"><pre><code class="erlang"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nv">Declare</span> <span class="o">=</span> <span class="nl">#&#39;exchange.declare&#39;</span><span class="p">{</span><span class="n">exchange</span> <span class="o">=</span> <span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="s">&quot;my_exchange&quot;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;,</span> <span class="n">type</span> <span class="o">=</span> <span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="s">&quot;fanout&quot;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;}</span>
<span class="nl">#&#39;exchange.declare_ok&#39;</span><span class="p">{}</span> <span class="o">=</span> <span class="nn">amqp_channel</span><span class="p">:</span><span class="nf">call</span><span class="p">(</span><span class="nv">Channel</span><span class="p">,</span> <span class="nv">Declare</span><span class="p">)</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div></p>

<p><strong>direct</strong>类型的exchange在收到消息后，会将此消息投递到发送消息时指定的<code>routing_key</code>和绑定队列到exchange上时的<code>routing_key</code>相同的队列里。可以多次绑定一个队列到一个exchange上，每次指定不同的<code>routing_key</code>，就可以接收多种<code>routing_key</code>类型的消息。<strong>注意，绑定队列时我们可以填入一个<code>routing_key</code>，发送消息时也可以指定一个<code>routing_key</code>。</strong></p>

<p><strong>topic</strong>类型的exchange相当于是direct exchange的扩展，direct exchange在投递消息到队列时，是单纯的对<code>routing_key</code>做相等判定，而topic exchange则是一个<code>routing_key</code>的字符串匹配，就像正则表达式一样。在<code>routing_key</code>中可以填入一种字符串匹配符号：</p>

<pre><code>* (star) can substitute for exactly one word.
# (hash) can substitute for zero or more words.
</code></pre>

<p><em>header exchange tutorial中未提到，我也不深究</em></p>

<h3>消息投递及回应</h3>

<p>每个消息都可以提供回应，以使RabbitMQ确定该消息确实被收到。RabbitMQ重新投递消息仅依靠与consumer的网络连接情况，所以只要网络连接正常，consumer卡死也不会导致RabbitMQ重投消息。如下回应消息：</p>

<p><div class="highlight"><pre><code class="erlang"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nn">amqp_channel</span><span class="p">:</span><span class="nf">cast</span><span class="p">(</span><span class="nv">Channel</span><span class="p">,</span> <span class="nl">#&#39;basic.ack&#39;</span><span class="p">{</span><span class="n">delivery_tag</span> <span class="o">=</span> <span class="nv">Tag</span><span class="p">}),</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div></p>

<p>其中<code>Tag</code>来源于接收到消息时里的<code>Tag</code>。</p>

<p>如果有多个consumer监听了一个队列，RabbitMQ会依次把消息投递到这些consumer上。这里的投递原则使用了<code>round robin</code>方法，也就是轮流方式。如前所述，如果某个consumer的处理逻辑耗时严重，则将导致多个consumer出现负载不均衡的情况，而RabbitMQ并不关心consumer的负载。可以通过消息回应机制来避免RabbitMQ使用这种消息数平均的投递原则：</p>

<p><div class="highlight"><pre><code class="erlang"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nv">Prefetch</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="nn">amqp_channel</span><span class="p">:</span><span class="nf">call</span><span class="p">(</span><span class="nv">Channel</span><span class="p">,</span> <span class="nl">#&#39;basic.qos&#39;</span><span class="p">{</span><span class="n">prefetch_count</span> <span class="o">=</span> <span class="nv">Prefetch</span><span class="p">})</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div></p>

<h3>消息可靠性</h3>

<p>RabbitMQ可以保证消息的可靠性，这需要设置消息和队列都为durable的：</p>

<p><div class="highlight"><pre><code class="erlang"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nl">#&#39;queue.declare_ok&#39;</span><span class="p">{</span><span class="n">queue</span> <span class="o">=</span> <span class="nv">Q</span><span class="p">}</span> <span class="o">=</span> <span class="nn">amqp_channel</span><span class="p">:</span><span class="nf">call</span><span class="p">(</span><span class="nv">Channel</span><span class="p">,</span> <span class="nl">#&#39;queue.declare&#39;</span><span class="p">{</span><span class="n">queue</span> <span class="o">=</span> <span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="s">&quot;hello_queue&quot;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;,</span> <span class="n">durable</span> <span class="o">=</span> <span class="n">true</span><span class="p">}),</span>

<span class="nv">Payload</span> <span class="o">=</span> <span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="s">&quot;foobar&quot;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;,</span>
<span class="nv">Publish</span> <span class="o">=</span> <span class="nl">#&#39;basic.publish&#39;</span><span class="p">{</span><span class="n">exchange</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">routing_key</span> <span class="o">=</span> <span class="nv">Queue</span><span class="p">},</span>
<span class="nv">Props</span> <span class="o">=</span> <span class="nl">#&#39;P_basic&#39;</span><span class="p">{</span><span class="n">delivery_mode</span> <span class="o">=</span> <span class="mi">2</span><span class="p">},</span> <span class="c">%% persistent message</span>
<span class="nv">Msg</span> <span class="o">=</span> <span class="nl">#amqp_msg</span><span class="p">{</span><span class="n">props</span> <span class="o">=</span> <span class="nv">Props</span><span class="p">,</span> <span class="n">payload</span> <span class="o">=</span> <span class="nv">Payload</span><span class="p">},</span>
<span class="nn">amqp_channel</span><span class="p">:</span><span class="nf">cast</span><span class="p">(</span><span class="nv">Channel</span><span class="p">,</span> <span class="nv">Publish</span><span class="p">,</span> <span class="nv">Msg</span><span class="p">)</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div></p>

<h2>参考</h2>

<p>除了参考RabbitMQ tutorial外，还可以看看别人使用erlang是如何实现这些tutorial的，github上有一个这样的项目：<a href="https://github.com/rabbitmq/rabbitmq-tutorials/tree/master/erlang">rabbitmq-tutorials</a>。我自己也实现了一份，包括rabbitmq-tutorials中没实现的RPC。后来我发现原来<a href="https://github.com/kevinlynx/rabbitmq-erlang-client">rabbitmq erlang client</a>的实现里已经包含了一个RPC模块。</p>

<ul>
<li><a href="http://blog.chinaunix.net/uid-22312037-id-3458208.html">RabbitMQ源码解析前奏--AMQP协议</a></li>
<li><a href="http://blog.ftofficer.com/2010/03/translation-rabbitmq-python-rabbits-and-warrens/">RabbitMQ+Python入门经典 兔子和兔子窝</a></li>
<li><a href="http://www.rabbitmq.com/erlang-client-user-guide.html">Erlang AMQP Client library</a></li>
<li><a href="http://www.rabbitmq.com/management.html">Manage RabbitMQ by WebUI</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
