<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: other | loop in codes]]></title>
  <link href="http://codemacro.com/categories/other/atom.xml" rel="self"/>
  <link href="http://codemacro.com/"/>
  <updated>2015-06-07T17:59:18+08:00</updated>
  <id>http://codemacro.com/</id>
  <author>
    <name><![CDATA[Kevin Lynx]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[理解git常用命令原理]]></title>
    <link href="http://codemacro.com/2014/09/09/understand-git/"/>
    <updated>2014-09-09T00:00:00+08:00</updated>
    <id>http://codemacro.com/2014/09/09/understand-git</id>
    <content type="html"><![CDATA[<p>git不同于类似SVN这种版本管理系统，虽然熟悉常用的操作就可以满足大部分需求，但为了在遇到麻烦时不至于靠蛮力去尝试，了解git的原理还是很有必要。</p>

<h2>文件</h2>

<p>通过git管理的文件版本信息全部存放在根目录<code>.git</code>下，稍微看下：</p>

<pre><code>$ ls .git
COMMIT_EDITMSG  HEAD       branches  description  index  logs     packed-refs
FETCH_HEAD      ORIG_HEAD  config    hooks        info   objects  refs
</code></pre>

<p>git除了提供给我们平时常用的一些命令之外，还有很多底层命令，可以用于查看以上部分文件表示的东西。</p>

<h2>三个区域/三类对象</h2>

<p>理解git里的三个区域概念非常重要。git里很多常用的命令都是围绕着这三个区域来做的。它们分别为：</p>

<ul>
<li>working directory，也就是你所操作的那些文件</li>
<li>history，你所提交的所有记录，文件历史内容等等。<strong>git是个分布式版本管理系统，在你本地有项目的所有历史提交记录；文件历史记录；提交日志等等。</strong></li>
<li>stage(index)，暂存区域，本质上是个文件，也就是<code>.git/index</code></li>
</ul>


<!-- more -->


<p>git中还有三类常用对象（实际不止三种），理解这三类对象也很重要。分别为：</p>

<ul>
<li>blob，用于表示一个文件</li>
<li>tree，用于表示一个目录，索引到若干文件或子目录</li>
<li>commit，用于表示一次提交(commit)</li>
</ul>


<p>所有对象都会以文件的形式保存在<code>.git/objects</code>目录，一个对象一个文件。</p>

<p>接下来把上面所有的内容关联起来。做以下操作：</p>

<pre><code>$ mkdir test &amp;&amp; cd test
$ git init
$ ls -a .git/objects             # 没有文件
.  ..  info  pack
$ touch readme                   # working directory里增加了一个readme文件
$ git add readme                 # 添加一个文件到stage区域
$ git ls-files --stage           # 这个命令可以查看stage区域里的内容，可以看到有readme
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0       readme
$ ls -a .git/objects             # 同时.git/objects增加了一个e6的目录
.  ..  e6  info  pack
$ ls -a .git/objects/e6/         # e6目录下增加了一个文件
.  ..  9de29bb2d1d6434b8b29ae775ad8c2e48c5391
</code></pre>

<p>上面的操作展示了git中三个区域三个对象的部分关联关系。git中每个对象都以一个40个字符长度的SHA-1哈希值为标识，以这40个字符的前2个字符作为文件夹，以后38个字符为文件名。</p>

<p>基于以上继续操作：</p>

<pre><code>$ git commit -m 'first commit'   # commit会将stage里标识的文件提交到history区域
[master (root-commit) 8bf6969] first commit
 0 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 readme

$ ls -a .git/objects             # 增加了2个文件，也就是2个对象
.  ..  8b  e6  e8  info  pack
$ git ls-files --stage           # stage仅表示当前被版本管理的文件，所以内容不变
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0       readme

# git cat-file 命令可以用于查看.git/objects下的文件，意即可用于查看对象
$ git cat-file -t e69de29bb2d1d6434b8b29ae775ad8c2e48c5391      # 这个是之前git add readme产生的文件对象 blob
blob

# 同样我们来查看git commit -m后新增的两个对象

$ ls .git/objects/8b/
f696927c17526eb8f0c6dae8badb968a001ed0
$ git cat-file -t 8bf696927c17526eb8f0c6dae8badb968a001ed0  # 记得带上8b这个文件夹名，才算一个完整的对象ID。这是一个commit对象
commit
$ ls .git/objects/e8
0ad49ace82167de62e498622d70377d913c79e
$ git cat-file -t e80ad49ace82167de62e498622d70377d913c79e  # tree对象
tree
</code></pre>

<p>区域和对象如何交互的可以用下图描述：</p>

<p><img src="/assets/res/git-objects.png" alt="" /></p>

<p>通过<code>git cat-file -p</code>可以查看对象的更多描述，<code>git cat-file -t</code>仅获取对象的类型。做以下操作获得更深的认识：</p>

<pre><code># 这个commit对象记录了提交者的信息，还包括指向的tree对象
$  git cat-file -p 8bf696927c17526eb8f0c6dae8badb968a001ed0
tree e80ad49ace82167de62e498622d70377d913c79e
author Kevin Lynx &lt;kevinlynx@gmail.com&gt; 1410090424 +0800
committer Kevin Lynx &lt;kevinlynx@gmail.com&gt; 1410090424 +0800

first commit

# 查看tree对象可以看出tree指向的blob对象 
$ git cat-file -p e80ad49ace82167de62e498622d70377d913c79e
100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    readme
</code></pre>

<p>即使是已经被版本管理的文件，发生改动后（正常改动或合并）都使用<code>git add</code>来重新mark它。创建第二次提交进一步认识：</p>

<pre><code>$ echo 'hello git' &gt; readme
$ touch install
$ git ls-files --stage       # 不使用git add，暂存区域内容没变
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0       readme

# 此时stage里内容未变，提示no changes added to commit
$ git commit
# On branch master
# Changed but not updated:
#   (use "git add &lt;file&gt;..." to update what will be committed)
#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)
#
#       modified:   readme
#
# Untracked files:
#   (use "git add &lt;file&gt;..." to include in what will be committed)
#
#       install
no changes added to commit (use "git add" and/or "git commit -a")

$ git add readme
$ ls .git/objects/  # git add之后.git/objects下新增文件
8b  8d  e6  e8  info  pack
$ ls .git/objects/8d/
0e41234f24b6da002d962a26c2495ea16a425f
$ git cat-file -p 8d0e41234f24b6da002d962a26c2495ea16a425f # 查看该新增对象
hello git

# 这个时候还可以在提交前撤销git add readme
$ git reset readme  # 从history到stage
Unstaged changes after reset:
M       readme
$ cat readme
hello git
$ git checkout readme # 从stage到working directory
$ cat readme # 没有内容，回到第一个版本

$ git add install # 添加新创建的文件
$ git ls-files --stage # stage中的内容是最新的readme和新添加的install
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0       install
100644 8d0e41234f24b6da002d962a26c2495ea16a425f 0       readme
$ ls .git/objects/
8b  8d  e6  e8  info  pack
</code></pre>

<p>以上，发现一个有趣的现象：新加的<code>install</code>文件的SHA-1哈希值和之前的<code>readme</code>相同，这是因为这2个文件都是空的，内容相同。继续：</p>

<pre><code>$ git commit -m 'second commit'
$ ls .git/objects/  # 提交后新增2个对象
45  72  8b  8d  e6  e8  info  pack

$ ls .git/objects/72/
b94e949c5fca6092cc74c751a7bb35ee71c283
$ git cat-file -p 72b94e949c5fca6092cc74c751a7bb35ee71c283
tree 45cf0bd049d7eea4558b14f33a894db27c7c1130                    # 新创建的tree对象
parent 8bf696927c17526eb8f0c6dae8badb968a001ed0                  # commit对象有parent，正是上一次提交
author Kevin Lynx &lt;kevinlynx@gmail.com&gt; 1410094456 +0800
committer Kevin Lynx &lt;kevinlynx@gmail.com&gt; 1410094456 +0800

second commit
# 新创建的tree对象指向了2个文件
$ git cat-file -p 45cf0bd049d7eea4558b14f33a894db27c7c1130
100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    install
100644 blob 8d0e41234f24b6da002d962a26c2495ea16a425f    readme
</code></pre>

<p>需要注意，有时候我们使用<code>git commit -a</code>，它会直接将已经加入版本管理的文件一起提交，从而跳过了<code>git add</code>这个过程。同git很多操作一样，它只是一个快捷操作。</p>

<h2>总结</h2>

<p>从上面的内容其实已经可以看出git的优势所在，它可以完全不需要服务器就完成一个版本控制系统的所有事情。在.git文件中它记录了所有的文件的所有历史提交，记录了每一次提交的信息。</p>

<p>git的常用操作中还会涉及到分支、远端仓库等，空了再写。</p>

<h2>参考文档</h2>

<ul>
<li><a href="http://www.nowamagic.net/academy/detail/48160210">Git的思想和基本工作原理</a></li>
<li><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html?no-svg">图解Git</a></li>
<li><a href="http://blog.jobbole.com/26209/">Git详解之九：Git内部原理</a></li>
<li><a href="http://www.oschina.net/translate/git-fetch-and-merge">Git 少用 Pull 多用 Fetch 和 Merge</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[my 2013]]></title>
    <link href="http://codemacro.com/2014/02/02/2013/"/>
    <updated>2014-02-02T00:00:00+08:00</updated>
    <id>http://codemacro.com/2014/02/02/2013</id>
    <content type="html"><![CDATA[<h2>技术</h2>

<p>这一年里个人的技术感觉进步不是那么大。一方面技术之外的事情多了起来，另一方面由于工作原因接触的技术也较为杂乱，没有机会专注。技术的提升还是得靠业余时间。</p>

<h3>系统分析设计</h3>

<p>学了些RUP的方法，对规范化的系统分析设计算是有了一定认识。但这个东西在实践的过程中往往较难运用，好的方法学还是得看项目的实际情况而定。</p>

<!-- more -->


<h3>单元测试软件</h3>

<p>基于clang重写了公司的一个测试软件。因为之前有过一定的编译原理实践，本身我对编程语言也有一定认识，所以带领团队实现这个项目的时候也较容易。倒是对clang的研究，一直没有深入的机会。</p>

<h3>浏览器前端</h3>

<p>这一年里工作原因，对浏览器前端的一些技术有了更深的接触。后来还参与了部分编码，使用AngularJS和Bootstrap写了些代码。到目前为止对Javascrpt以及前端框架理念只能算有了个初步认识。也是希望能在这一块有一定深入的机会。自己写一个前端框架应该不难。</p>

<h3>Erlang</h3>

<p>基于之前做的dhtcrawler2，对Erlang有了一定的实践经验。使用函数式语言编写应用非常爽。主要体现在对集合的方便操作，以及lambda的应用。但Erlang的基础API确实不优美，接口的命名风格都存在一定的不统一。Erlang的进程模型非常酷，用来写服务器程序非常自然。进程相关的API比起同样是actor模型的akka好用太多。Erlang调优依然是服务器编程中无法回避的问题，虽然OTP提供了很多辅助这一过程的接口。</p>

<p>dhtcrawler2也存在很多问题，可惜后来实在太忙，已经没有时间顾及这种业余项目。</p>

<h3>Scala</h3>

<p>Scala到目前为止也是一门我比较喜欢的语言。它综合了面向对象和函数式语言的特性，基于JVM可以无代价地使用任何一个Java库，使得该语言在实际应用中没有什么阻碍。Scala的语法集很大，能被写出难以阅读的代码。</p>

<p>11月份的时候接了一个外包，我就直接选用了Scala来做，总算有了实践机会。在实际使用中越是发现Scala的强大。但对语言本身还深入的很不够，也希望在未来有更多的实践机会。</p>

<h2>团队管理</h2>

<h3>适量的制度和信任</h3>

<p>有那么一段时间很多很细的事情我都亲历亲为，对于整个项目的细节都掌握得比较清楚，对于每个技术实现方案也都是自己在做，后来发现这样太累，没有精力做更高层面的工作。所以，后来我就在这个度上做了些调整。仅做技术方案的大体制定，将分析设计的细化交给能够胜任的人。通过一份好的文档来做几次高效率的沟通，从而节省了我的时间。此外，这种方式也有利于培养团队成员编码之外的能力，对于成员本身应该也是大有益处的。</p>

<p>对于团队成员的信任，应该是一个逐渐累积的过程。这个过程中存在一定的磨合期，这个磨合期我觉得应该建立一些制度，用于实现沟通的有效性、工作的明确性以及部分工作的指导。这个制度应该保持轻量，尽量维持在不限制程序员的创造性以及造成厌恶情绪的程度。</p>

<h3>团队氛围的营造</h3>

<p>团队氛围我觉得是非常重要的，它可以与公司的氛围不一样。良好的氛围可以较大程度地提升团队成员的工作积极性，提高团队的战斗力。团队的氛围肯定是需要与团队成员契合的，这涉及到人员招聘的问题。</p>

<p>我希望我的团队应该充满技术氛围。程序员处在这个团队中，不仅仅是为公司工作，在项目中能够把解决掉的某个问题作为茶余饭后的谈资。成员之间应该可以在任何时候任何地点激情地讨论技术问题。程序员留在这个团队不仅仅是因为公司提供的待遇，团队本身的引力应该占到足够的比重。</p>

<p>要营造以上的氛围，我觉得Leader要做很多工作。可以包括：</p>

<ul>
<li>适当且有效的技术交流，这其实也很难</li>
<li>一定频率的技术比赛，要适合每个成员的参与，也比较困难</li>
<li>技术热情的散播，Leader可以随时随地发起话题</li>
<li>项目问题的讨论</li>
<li>项目经验的总结及散播</li>
</ul>


<p>此外，除了以上需要尽量做到的事情之外，我觉得有些事情是应该避免做的，包括：</p>

<ul>
<li>工作时间与项目关系不太直接的纯技术学习。这其实本身是件好事，但其实反映了一个管理问题：某个成员的工作安排不够饱和。而一旦出现这样的情况，Leader不应该立即制止，而是分析项目情况以及成员的工作安排，通过及时安排工作来中断该行为。纯技术的学习，可以作为某个技术点交流会议的准备。</li>
<li>浏览技术之外的网页或其他甚至和自身技术提升不沾边的行为。我一般不明确制止该行为，但会同上一点一样从其他方面终止该行为。</li>
</ul>


<p>我觉得，一个团队成员的不良行为，往往不仅仅是影响到他自己，这种现象通常会进行传播。</p>

<h3>人员招聘</h3>

<p>基于我喜欢的团队氛围目标，我会在程序员招聘时就进行严格的筛选。我一般不喜欢包含以下特征的程序员：</p>

<ul>
<li>基础不好。我希望我团队中的每个成员都能成长为牛人，拥有较快上升特征的程序员也会给团队注入活力。而不管你是从事什么类型开发的程序员，我相信扎实的计算机基础才是成长的基石。当然，出于公司或项目原因，这个条件可以放宽。</li>
<li>浮夸。我喜欢踏实的程序员，会就是会，不会就是不会，不熟就是不熟，忘了就是忘了。实力可以从很多方面体现出来，但肯定不是每一项技术细节你都了解。当然，那种招聘5年C++程序员却嫌你不熟MFC的面试官本身就是一个问题，除非他明确地招聘一个MFC程序员。浮夸的特征不一定很明显，但是我觉得如果遇到一个能说会道的人，那就得小心点。</li>
<li>说话太冲。这个主要是担心以后难以管理，与其他人合作会有问题。在面试的时候我尽量表现的随意，希望面试者将面试过程当作一次平等的技术交流。但是，我觉得对面试官的基本尊重必须有。可能有些技术问题无法达成共识，但没必要在面试的过程中追根究底面红耳赤。我在面试过程中有几次坦白自己不太确定某个技术，也曾很自信地告诉对方可以私下验证一下我的结论。我的组员中还确实有人在入职的时候告诉我，某某问题我错了。我都能欣然接受，反而能增加我的好感。</li>
</ul>


<p>由于我处在一个小公司，所以我不会对性格做过多的考察。我觉得，对于这样的公司，只要这个程序员不是内向到沟通比较困难，不是太自我为中心，就成。</p>

<p>人员招聘是一件需要很谨慎的事情。我可能在看人上还很欠缺经验，所以在过去面试的几十个人里（应该在50以下），我花费的平均面试时间大概在2小时左右。为了提高这2小时的有效率，通过有效合理的笔试题和简历研究来进行筛选是必不可少的手段。</p>

<h3>适当的职责提升</h3>

<p>这个同给予成员信任差不多。一个人得到别人的信任才能把事情做得更好，对项目本身也会有归属感。在项目的某些时期，明确地提升某个成员的职责，意义也在于此。当然这涉及到人员的挑选，我觉得有足够的责任心以及技术实力，就可以胜任这个角色。再往上的话，当然得需要一定的协调能力，能够协调一定数量的人员将项目的某一部分良好地完成。</p>

<h2>项目管理</h2>

<p>由于几个项目规模都较小，一个月的时间4个程序员就可以获得一个雏形。所以我感觉这些项目的管理方式更偏重于敏捷。在项目中有些活动是必须的。</p>

<h3>项目计划</h3>

<p>说法上我们称一自然周为一个迭代周期。在项目做完初步的分析设计之后，我会根据当时对项目的把握情况做出尽可能久尽可能详细的迭代计划。这份迭代计划会描述未来几次迭代周期应该完成的内容。项目里程碑在哪个时间点。</p>

<p>在项目开始的时候，每一次迭代开始我会更新这份迭代计划，尽可能细化当前迭代的内容。迭代的内容里主要包含开发内容，但也会包含需求沟通、分析设计、测试类工作。</p>

<h3>项目总结</h3>

<p>在每一次迭代快完的时候，我会及时总结当前迭代所完成的内容。这些内容一般都会与计划有些微的出入，有时候由于需求的介入、客户方的要求等等，实际完成的内容可能会非常不同。</p>

<p>除了在迭代结束的时候总结当前完成情况之外，在迭代中我也可能进行总结分析。其目的并不在于形成一种规范，而在于真真实实地辅助对项目进展的把控。</p>

<p>另一方面，当项目进度不再特别紧的时候，我觉得团队主要人员应该对整个项目的技术进行分析总结，一方面起到促进沟通交流的作用，另一方面也可以为团队沉淀技术实力和业务知识。</p>

<h3>例会/周报/管理系统</h3>

<p>在公司里做事往往需要对上对下。这么多感触，基本上都是对下的经验。公司高层虽然不需要像项目经理一样对项目做细致地把控，但也不能完全隔离项目的实际情况。有些规章制度总是需要的。这些制度对于程序员而言可能是一种干扰，但对管理层而言却也是必不可少的。</p>

<p>一套好用的项目管理系统，可以尽可能方便地让项目参与人员录入信息，也尽可能方便地管理层看到项目的大致进展情况，看到项目成员的工作情况。这也是目前我觉得我们做得不好的地方。</p>

<p>关于周报，我觉得在项目较空闲的时候是完全没有必要的。这个同某个成员在某个时间段较空闲的理由一样，这完全是管理层的问题，却要把这个问题转换为程序员编造工作周报的烦恼。但在项目较紧的时候，则是很有必要的。</p>

<p>工作例会，同很多沟通活动一样，我主张效率至上。在我能控制范围内，尽可能少地进行形式化的活动。例会的内容通常用于团队成员彼此之间工作内容的交流，让每个人知道其他人大概做的事情。同时，例会也是维持团队工作激情的一种简单方式。</p>

<h2>总结</h2>

<p>2013年下半年开始就一直很忙。最差的情况是：加班，加完班回去接着做外包，完了就睡觉。在项目里偶尔充当打杂的角色，哪块技术缺人就去补位。有时候又不放心别人的工作，又要去参合一下。公司里偶尔也有些杂物事。招聘人也费了不少时间，接触得多了发现来面试的群体都差不多，对自身的提高也失去了作用。</p>

<p>工作上偶尔觉得有压力。眼看快而立之年，技术没什么特别强的建树，钱也没挣到，生活也不免有了压力。</p>

<p>有时候想回去游戏行业，觉得专注一个领域才有长足的发展。但又没有特别吸引人的团队和公司。不太喜欢和国企的人打交道，虚来虚去，时间浪费不少。</p>

<p>越来越相信选择有时候特别重要。</p>

<p>希望2014年，自己还是能把眼前的事踏实做好。无论是技术还是管理还是个人收入，都能真正地上一个台阶。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么处理排序的数组要比非排序的快？]]></title>
    <link href="http://codemacro.com/2012/08/29/branch-predictor/"/>
    <updated>2012-08-29T19:55:00+08:00</updated>
    <id>http://codemacro.com/2012/08/29/branch-predictor</id>
    <content type="html"><![CDATA[<p>参考<a href="http://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-an-unsorted-array">Why is processing a sorted array faster than an unsorted array?</a></p>

<h2>问题</h2>

<p>看以下代码：</p>

<p>{% highlight c++ %}</p>

<h1>include <algorithm></h1>

<h1>include <ctime></h1>

<h1>include <iostream></h1>

<p>int main()
{
    // generate data
    const unsigned arraySize = 32768;
    int data[arraySize];</p>

<pre><code>for (unsigned c = 0; c &lt; arraySize; ++c)
    data[c] = std::rand() % 256;


// !!! with this, the next loop runs faster
std::sort(data, data + arraySize);


// test
clock_t start = clock();
long long sum = 0;

for (unsigned i = 0; i &lt; 100000; ++i)
{
    // primary loop
    for (unsigned c = 0; c &lt; arraySize; ++c)
    {
        if (data[c] &gt;= 128)
            sum += data[c];
    }
}

double elapsedTime = static_cast&lt;double&gt;(clock() - start) / CLOCKS_PER_SEC;

std::cout &lt;&lt; elapsedTime &lt;&lt; std::endl;
std::cout &lt;&lt; "sum = " &lt;&lt; sum &lt;&lt; std::endl;
</code></pre>

<p>}</p>

<p>{% endhighlight %}</p>

<p>问题就在于，去掉<code>std::sort</code>那一行，以上代码将运行更长的时间。在我的机器上未去掉<code>std::sort</code>耗时8.99s，去掉后耗时24.78s。编译器使用的是gcc4.4.3。事实上，以上代码跟编译器没有关系，甚至跟语言没有关系。那这是为什么呢？</p>

<!-- more -->


<p>这跟处理这个数组的逻辑有非常大的关系。如以上代码所示，这个循环里有个条件判断。条件判断被编译成二进制代码后，就是一个跳转指令，类似：</p>

<p>{% highlight asm %}
jl SHORT $LN3@main
{% endhighlight %}</p>

<p>具体为什么会不同，这涉及到计算机CPU执行指令时的行为。</p>

<h2>CPU的流水线指令执行</h2>

<p>想象现在有一堆指令等待CPU去执行，那么CPU是如何执行的呢？具体的细节可以找一本计算机组成原理的书来看。CPU执行一堆指令时，并不是单纯地一条一条取出来执行，而是按照一种流水线的方式，在CPU真正执行一条指令前，这条指令就像工厂里流水线生产的产品一样，已经被经过一些处理。简单来说，一条指令可能经过这些过程：取指(Fetch)、解码(Decode)、执行(Execute)、放回(Write-back)。</p>

<p>假设现在有指令序列ABCDEFG。当CPU正在执行(execute)指令A时，CPU的其他处理单元（CPU是由若干部件构成的）其实已经预先处理到了指令A后面的指令，例如B可能已经被解码，C已经被取指。这就是流水线执行，这可以保证CPU高效地执行指令。</p>

<h2>Branch Prediction</h2>

<p>如上所说，CPU在执行一堆顺序执行的指令时，因为对于执行指令的部件来说，其基本不需要等待，因为诸如取指、解码这些过程早就被做了。但是，当CPU面临非顺序执行的指令序列时，例如之前提到的跳转指令，情况会怎样呢？</p>

<p>取指、解码这些CPU单元并不知道程序流程会跳转，只有当CPU执行到跳转指令本身时，才知道该不该跳转。所以，取指解码这些单元就会继续取跳转指令之后的指令。当CPU执行到跳转指令时，如果真的发生了跳转，那么之前的预处理（取指、解码）就白做了。这个时候，CPU得从跳转目标处临时取指、解码，然后才开始执行，这意味着：CPU停了若干个时钟周期！</p>

<p>这其实是个问题，如果CPU的设计放任这个问题，那么其速度就很难提升起来。为此，人们发明了一种技术，称为branch prediction，也就是分支预测。分支预测的作用，就是预测某个跳转指令是否会跳转。而CPU就根据自己的预测到目标地址取指令。这样，即可从一定程度提高运行速度。当然，分支预测在实现上有很多方法。</p>

<p>简单的预测可以直接使用之前的实际执行结果。例如某个跳转指令某一次产生了跳转，那么下一次执行该指令时，CPU就直接从跳转目标地址处取指，而不是该跳转指令的下一条指令。</p>

<h2>答案</h2>

<p>了解了以上信息后，文章开头提出的问题就可以解释了。这个代码中有一个循环，这个循环里有一个条件判断。每一次CPU执行这个条件判断时，CPU都可能跳转到循环开始处的指令，即不执行if后的指令。使用分支预测技术，当处理已经排序的数组时，在若干次<code>data[c]&gt;=128</code>都不成立时（或第一次不成立时，取决于分支预测的实现），CPU预测这个分支是始终会跳转到循环开始的指令时，这个时候CPU将保持有效的执行，不需要重新等待到新的地址取指；同样，当<code>data[c]&gt;=128</code>条件成立若干次后，CPU也可以预测这个分支是不必跳转的，那么这个时候CPU也可以保持高效执行。</p>

<p>相反，如果是无序的数组，CPU的分支预测在很大程度上都无法预测成功，基本就是50%的预测成功概率，这将消耗大量的时间，因为CPU很多时间都会等待取指单元重新取指。</p>

<p>本文完。最后感叹下stackoverflow上这个帖子里那个老外回答问题的专业性，我要是楼主早就感动得涕泪横飞了。感谢每一个传播知识的人。</p>

<h2>参考资料</h2>

<ol>
<li><a href="http://blog.sina.com.cn/s/blog_6c673e570100zfmo.html">http://blog.sina.com.cn/s/blog_6c673e570100zfmo.html</a></li>
<li><a href="http://www.cnblogs.com/dongliqian/archive/2012/04/05/2433847.html">http://www.cnblogs.com/dongliqian/archive/2012/04/05/2433847.html</a></li>
<li><a href="http://en.wikipedia.org/wiki/Branch_predictor">http://en.wikipedia.org/wiki/Branch_predictor</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为octopress每篇文章添加一个文章信息]]></title>
    <link href="http://codemacro.com/2012/07/26/post-footer-plugin-for-octopress/"/>
    <updated>2012-07-26T14:27:00+08:00</updated>
    <id>http://codemacro.com/2012/07/26/post-footer-plugin-for-octopress</id>
    <content type="html"><![CDATA[<p>当你的博客文章被转载时，你肯定希望转载者能添加一个原始地址。或者你的文章被各种RSS抓取器抓取时，你也希望能在明显的位置显示这个原始地址。使用octopress写博客时，可以通过插件来做这件事。最开始，我只是想单纯地添加这个“原始地址“，一番google未能找到现成的插件，所以只好动手。</p>

<p>话说编写octopress真不是件容易事，因为我实在没找到编写插件的文档。octopress基于jekyll，jekyll又使用了liquid。最后我把这几个项目的文档都翻了下，也仅仅看到几个代码示例，而且liquid的API页面居然出错。无奈之下只好多翻了些现有插件的代码，摸索着来写。写octopress的插件，主要分为generator/tag/filter几种。tag很好理解，就是在文章中插入一个插件注册的tag，然后生成页面时就会调用到对应的插件。filter大概就是把文章内容过滤一遍转换成其他内容输出。</p>

<!-- more -->


<p>后来发现了一篇文章<a href="http://xoyo.name/2012/04/auto-spacing-for-octopress/">\&lt;给中英文间加个空格></a>，这人写的插件从流程上大致是我需要的，模仿如下：</p>

<p>{% highlight ruby %}
{% raw %}
#</p>

<h1>post_footer_filter.rb</h1>

<h1>Append every post some footer infomation like original url</h1>

<h1>Kevin Lynx</h1>

<h1>7.26.2012</h1>

<p>#
require &lsquo;./plugins/post_filters&rsquo;</p>

<p>module AppendFooterFilter
  def append(post)
     author = post.site.config[&lsquo;author&rsquo;]
     url = post.site.config[&lsquo;url&rsquo;]
     pre = post.site.config[&lsquo;original_url_pre&rsquo;]
     post.content + %Q[<p class='post-footer'>
            #{pre or &ldquo;original link:&rdquo;}
            <a href='#{post.full_url}'>#{post.full_url}</a><br/>
            &nbsp;written by <a href='#{url}'>#{author}</a>
            &nbsp;posted at <a href='#{url}'>#{url}</a>
            </p>]
  end
end</p>

<p>module Jekyll
  class AppendFooter &lt; PostFilter
    include AppendFooterFilter
    def pre_render(post)
      post.content = append(post) if post.is_post?
    end
  end
end</p>

<p>Liquid::Template.register_filter AppendFooterFilter
{% endraw %}
{% endhighlight %}</p>

<p>大概就是当传入的页面是post时，就添加页脚信息，我这里主要添加了原始地址和作者信息，并且留了个post-footer作为这个段落的样式定制。附加的信息对于RSS输出同样有效。</p>

<p>这个插件的使用方式很简单，直接放到plugins目录下即可。可以在_config.yml中配置下origional_url_pre，例如配置为“原始地址：“。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开始记录编程方面的技巧]]></title>
    <link href="http://codemacro.com/2012/07/18/start-to-write-tips/"/>
    <updated>2012-07-18T17:01:00+08:00</updated>
    <id>http://codemacro.com/2012/07/18/start-to-write-tips</id>
    <content type="html"><![CDATA[<p>回首上篇博客的发表时间，又2个月时间过去了。在我博客生涯的过去两三年里，总会有好几个月的时间没有编写任何文章。我觉得这真是一个不好的习惯。这个情况的产生，有很多原因。例如自己太懒、工作偶尔忙、自己偶尔处于混沌时期、自己偶尔怀疑人生，如是种种。但最大的原因还是，不敢写。</p>

<p>在刚出来工作那会，作为一个懵懂的青年，接触个什么新技术都内心激动骄傲，然后就特别有动力将所学记录下来，注意下言辞还能折腾个像那么回事的教程出来。后来慢慢地，我就觉得，这些东西太肤浅。先别说教人用个什么IDE，配置个什么数据库，就算你是学个新语言，好好研究下TCP，甚至还能折腾个IOCP框架，这些都还是他妈的特肤浅。你说任何一个有那么点经验和学习能力的程序员，谁花点时间整不出来这些？谁他妈要你在这里装逼卖萌，甚至贻笑大方。除此之外，我个人也觉得无聊了。</p>

<p>另一方面我觉得写博客还有个好处就是帮助自己记录技术，以便将来万一又需要曾经学习过的技术了，回头温习一下就好。但是后来慢慢地我又觉得，这也是没必要的事情。因为反正需要这个技术的时候，也花不了多少时间。</p>

<p>基于这些乱七八糟的原因，我虽然经常打开自己的博客，看看有没人评论啊，留言啊，但发表博客的频率始终上不去。</p>

<!-- more -->


<p>后来呢，在google reader上断断续续也看了些别的程序员的故事。例如有傻逼坚持1年每天一篇博客，后来竟然写了本书；例如有傻逼坚持每天翻译一篇英文文章。我琢磨着这些人该有多么大的毅力啊，就算是翻译文章，这从找文章筛选文章到最好发表出来这尼玛又该睡觉了啊亲。心生佩服之余，我觉得自己应该向这些傻逼们学习。作为一个已经没有那么多青年时光的青年，试想以后每天下班回家带娃的日子，而曾经竟碌碌无为地磨过每一个工作日耍过每一个工作日晚上，这是件比带娃更悲剧的事情。</p>

<p>所以，我也决定坚持干一件虽一日不用一次但也望每周那么几次的事情。我决定在博客上记录一些编程方面的技巧(tips)，集中于某个小问题的解决、某个小功能的实现。这些技巧相比前文说的，就更肤浅了，肤浅到你一google出来的结果你都吓一跳的程度。但是我依然觉得这是有用的，就像我用rails做网站，每一个小功能我都得google一遍，然后积累于心，然后一段时间后忘掉。为了不忘掉，为了查阅起来简单，我决定记录下来。但是仅靠我自己的经验，是肯定无法做到频繁地更新的，所以，我决定上stackoverflow上随机找些问题/答案翻译出来。stackoverflow非常适合满足这种需求，我发现我google某个rails技巧时，基本是从stackoverflow上获取下来的。</p>

<p>这样，我的博客<a href="http://codemacro.com">http://codemacro.com</a>的rss输出可能会繁杂点，这对于某些人而言估计会起到恶心的效果。而我自己的博客可能也会变得不那么像个人博客。我也想过单独做个网站出来，但仔细想想还是制止自己少瞎折腾了。如有建议欢迎批评。</p>

<p>好，就这样，没了。</p>
]]></content>
  </entry>
  
</feed>
