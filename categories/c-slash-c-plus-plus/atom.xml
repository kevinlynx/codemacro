<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c/c++ | loop in codes]]></title>
  <link href="http://codemacro.com/categories/c-slash-c-plus-plus/atom.xml" rel="self"/>
  <link href="http://codemacro.com/"/>
  <updated>2014-09-21T20:53:27+08:00</updated>
  <id>http://codemacro.com/</id>
  <author>
    <name><![CDATA[Kevin Lynx]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[浅析静态库链接原理]]></title>
    <link href="http://codemacro.com/2014/09/15/inside-static-library/"/>
    <updated>2014-09-15T00:00:00+08:00</updated>
    <id>http://codemacro.com/2014/09/15/inside-static-library</id>
    <content type="html"><![CDATA[<p>静态库的链接基本上同链接目标文件<code>.obj/.o</code>相同，但也有些不同的地方。本文简要描述linux下静态库在链接过程中的一些细节。</p>

<h2>静态库文件格式</h2>

<p>静态库远远不同于动态库，不涉及到符号重定位之类的问题。静态库本质上只是将一堆目标文件进行打包而已。静态库没有标准，不同的linux下都会有些细微的差别。大致的格式<a href="http://en.wikipedia.org/wiki/Ar_%28Unix%29#File_format_details">wiki</a>上描述的较清楚：</p>

<pre><code>Global header
-----------------        +-------------------------------
File header 1       ---&gt; | File name
File content 1  |        | File modification timestamp 
-----------------        | Owner ID
File header 2            | Group ID
File content 2           | File mode
-----------------        | File size in bytes
...                      | File magic
                         +-------------------------------
</code></pre>

<p><code>File header</code>很多字段都是以ASCII码表示，所以可以用文本编辑器打开。</p>

<p>静态库本质上就是使用<code>ar</code>命令打包一堆<code>.o</code>文件。我们甚至可以用<code>ar</code>随意打包一些文件：</p>

<pre><code>$ echo 'hello' &gt; a.txt &amp;&amp; echo 'world' &gt; b.txt
$ ar -r test.a a.txt b.txt
$ cat test.a
!&lt;arch&gt;
a.txt/          1410628755  60833 100   100644  6         `
hello
b.txt/          1410628755  60833 100   100644  6         `
world
</code></pre>

<!-- more -->


<h2>链接过程</h2>

<p>链接器在链接静态库时，同链接一般的<code>.o</code>基本相似。链接过程大致可以归纳下图：</p>

<p><img src="/assets/res/link-process.png" alt="" /></p>

<p>总结为：</p>

<ul>
<li><strong>所有传入链接器的<code>.o</code>都会被链接进最终的可执行程序</strong>；链接<code>.o</code>时，会将<code>.o</code>中的<code>global symbol</code>和<code>unresolved symbol</code>放入一个临时表</li>
<li>如果多个<code>.o</code>定义了相同的<code>global symbol</code>，那么就会得到多重定义的链接错误</li>
<li>如果链接结束了，<code>unresolved symbol</code>表不为空，那么就会得到符号未定义的链接错误</li>
<li><code>.a</code>静态库处理本质上就是处理其中的每一个<code>.o</code>，不同的是，如果某个<code>.o</code>中没有一个符号属于<code>unresolved symbol</code>表，也就是链接器此时怀疑该<code>.o</code>没有必要，那么其就会被忽略</li>
</ul>


<p>可以通过一些代码来展示以上过程。在开发C++程序时，可以利用文件静态变量会先于<code>main</code>之前执行做一些可能利于程序结构的事情。如果某个<code>.o</code>（包含静态库中打包的<code>.o</code>）被链接进程序，那么其文件静态变量就会先于<code>main</code>初始化。</p>

<p>{% highlight c++ %}
// test.cpp</p>

<h1>include &lt;stdio.h></h1>

<p>class Test {
public:
    Test() {
        printf(&ldquo;Test ctor\n&rdquo;);
    }
};</p>

<p>static Test s_test;</p>

<p>// lib.cpp</p>

<h1>include &lt;stdio.h></h1>

<p>class Lib {
public:
    Lib() {
        printf(&ldquo;Lib ctor\n&rdquo;);
    }
};</p>

<p>static Lib s_lib;</p>

<p>// main.cpp</p>

<h1>include &lt;stdio.h></h1>

<p>int main() {
    printf(&ldquo;main\n&rdquo;);
    return 0;
}
{% endhighlight %}</p>

<p>以上代码<code>main.cpp</code>中未引用任何<code>test.cpp``lib.cpp</code>中的符号：</p>

<pre><code>$ g++ -o test test.o lib.o main.o
$ ./test
Lib ctor
Test ctor
main
</code></pre>

<p>生成的可执行程序执行如预期，其链接了<code>test.o``lib.o</code>。但是如果把<code>lib.o</code>以静态库的形式进行链接，情况就不一样了：为了做对比，基于以上的代码再加一个文件，及修改<code>main.cpp</code>：</p>

<p>{% highlight c++ %}
// libfn.cpp
int sum(int a, int b) {
    return a + b;
}</p>

<p>// main.cpp</p>

<h1>include &lt;stdio.h></h1>

<p>int main() {
    printf(&ldquo;main\n&rdquo;);
    extern int sum(int, int);
    printf(&ldquo;sum: %d\n&rdquo;, sum(2, 3));
    return 0;
}
{% endhighlight %}</p>

<p>将<code>libfn.o</code>和<code>lib.o</code>创建为静态库：</p>

<pre><code>$ ar -r libfn.a libfn.o lib.o
$ g++ -o test main.o test.o -lfn -L.
$ ./test
Test ctor
main
sum: 5
</code></pre>

<p>因为<code>lib.o</code>没有被链接，导致其文件静态变量也未得到初始化。</p>

<p>调整链接顺序，可以进一步检验前面的链接过程：</p>

<pre><code># 将libfn.a的链接放在main.o前面

$ g++ -o test test.o -lfn main.o  -L.
main.o: In function `main':
main.cpp:(.text+0x19): undefined reference to `sum(int, int)'
collect2: ld returned 1 exit status
</code></pre>

<p>这个问题遇到得比较多，也有点让人觉得莫名其妙。其原因就在于链接器在链接<code>libfn.a</code>的时候，发现<code>libfn.o</code>依然没有<strong>被之前链接的<code>*.o</code>引用到，也就是没有任何符号在<code>unresolved symbol table</code>中</strong>，所以<code>libfn.o</code>也被忽略。</p>

<h2>一些实践</h2>

<p>在实际开发中还会遇到一些静态库相关的问题。</p>

<h3>链接顺序问题</h3>

<p>前面的例子已经展示了这个问题。<strong>调整库的链接顺序</strong>可以解决大部分问题，但当静态库之间存在环形依赖时，则无法通过调整顺序来解决。</p>

<h4>-whole-archive</h4>

<p><code>-whole-archive</code>选项告诉链接器把静态库中的所有<code>.o</code>都进行链接，针对以上例子：</p>

<pre><code>$ g++ -o test -L. test.o -Wl,--whole-archive -lfn main.o -Wl,--no-whole-archive
$ ./test
Lib ctor
Test ctor
main
sum: 5
</code></pre>

<p>连<code>lib.o</code>也被链接了进来。<em><code>-Wl</code>选项告诉gcc将其作为链接器参数传入；之所以在命令行结尾加上<code>--no-whole-archive</code>是为了告诉编译器不要链接gcc默认的库</em></p>

<p>可以看出这个方法还是有点暴力了。</p>

<h4>&ndash;start-group</h4>

<p>格式为：</p>

<pre><code>--start-group archives --end-group
</code></pre>

<p>位于<code>--start-group</code>  <code>--end-group</code>中的所有静态库将被反复搜索，而不是默认的只搜索一次，直到不再有新的<code>unresolved symbol</code>产生为止。也就是说，出现在这里的<code>.o</code>如果发现有<code>unresolved symbol</code>，则可能回到之前的静态库中继续搜索。</p>

<pre><code>$ g++ -o test -L. test.o -Wl,--start-group -lfn main.o -Wl,--end-group
$ ./test
Test ctor
main
sum: 5
</code></pre>

<p>查看<code>ldd</code>关于该参数的man page还可以一窥链接过程的细节：</p>

<blockquote><p>The specified archives are searched repeatedly until no new undefined references are created. Normally, an archive is searched only once in the order that it is specified on the command line. If a symbol in that archive is needed to resolve an undefined symbol referred to by an object in an archive that appears later on the command line, the linker would not be able to resolve that reference. By grouping the archives, they all be searched repeatedly until all possible references are resolved.</p></blockquote>

<h3>嵌套静态库</h3>

<p>由于<code>ar</code>创建静态库时本质上只是对文件进行打包，所以甚至可以创建一个嵌套的静态库，从而测试链接器是否会递归处理静态库中的<code>.o</code>：</p>

<pre><code>$ ar -r libfn.a libfn.o
$ ar -r liboutfn.a libfn.a lib.o
$ g++ -o test -L. test.o main.o -loutfn
main.o: In function `main':
main.cpp:(.text+0x19): undefined reference to `sum(int, int)'
collect2: ld returned 1 exit status
</code></pre>

<p><strong>可见链接器并不会递归处理静态库中的文件</strong></p>

<p>之所以要提到嵌套静态库这个问题，是因为我发现很多时候我们喜欢为一个静态库工程链接其他静态库。当然，这里的链接并非真正的链接（仅是打包），这个过程当然可以聪明到将其他静态库里的<code>.o</code>提取出来然后打包到新的静态库。</p>

<p>如果我们使用的是类似<a href="http://www.scons.org/">scons</a>这种封装更高的依赖项管理工具，那么它是否会这样干呢？</p>

<p>基于之前的例子，我们使用scons来创建<code>liboutfn.a</code>：</p>

<pre><code># Sconstruct
StaticLibrary('liboutfn.a', ['libfn.a', 'lib.o'])
</code></pre>

<p>使用文本编辑器打开<code>liboutfn.a</code>就可以看到其内容，或者使用：</p>

<pre><code>$ ar -tv liboutfn.a
rw-r--r-- 60833/100   1474 Sep 14 02:59 2014 libfn.a
rw-r--r-- 60833/100   2448 Sep 14 02:16 2014 lib.o
</code></pre>

<p>可见scons也只是单纯地打包。<strong>所以，在scons中构建一个静态库时，再<code>链接</code>其他静态库是没有意义的</strong></p>

<h2>参考文档</h2>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Ar_%28Unix%29#File_format_details">ar (Unix)</a></li>
<li><a href="http://linux.die.net/man/1/ld">ld man page</a></li>
<li><a href="http://wen00072-blog.logdown.com/posts/188339-study-on-the-gnu-ld">GNU ld初探</a></li>
<li><a href="http://eli.thegreenplace.net/2013/07/09/library-order-in-static-linking/">Library order in static linking</a></li>
<li><a href="http://www.linuxjournal.com/article/6463?page=0,1">Linkers and Loaders</a></li>
<li><a href="http://www.scons.org/doc/0.96.1/HTML/scons-user/c549.html">scons Building and Linking with Libraries</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++构造/析构函数中的多态(二)]]></title>
    <link href="http://codemacro.com/2014/09/06/necessary-dtor/"/>
    <updated>2014-09-06T00:00:00+08:00</updated>
    <id>http://codemacro.com/2014/09/06/necessary-dtor</id>
    <content type="html"><![CDATA[<p>本来是几年以前写的一篇博客：<a href="http://codemacro.com/2012/09/17/c-plus-plus-ctor-virtual/">C++陷阱：构造函数中的多态</a>。然后有同学在评论中讨论了起来，为了记录我就在这里单独写一篇，基本上就是用编译器的实现去证明了早就被大家熟知的一些结论。</p>

<p><strong>默认构造函数/析构函数不是在所有情况下都会被生成出来的。</strong>为此我还特地翻出《Inside C++ object model》：</p>

<blockquote><p>2.1 Default Constructor Construction</p>

<p>The C++ Annotated Reference Manual (ARM) [ELLIS90] (Section 12.1) tells us that &ldquo;default constructors…are generated (by the compiler) where needed….&rdquo;</p></blockquote>

<p>后面别人还罗列了好些例子告诉你哪些情况才算<code>needed</code>。本文我就解释<code>构造函数中的多态</code>评论中的问题。</p>

<!-- more -->


<p>实验代码如下：</p>

<p>{% highlight c++ %}</p>

<h1>include &lt;stdio.h></h1>

<p>class Base {
public:
    Base() {
        Init();
    }</p>

<pre><code>//virtual
 ~Base() {
    printf("Base dtor\n");
    Release();
}

virtual void Init() {
    printf("Base::Init\n");
}

virtual void Release() {
    printf("Base::Release\n");
}
</code></pre>

<p>};</p>

<p>class Derived : public Base {
public:
    /<em>
    ~Derived() {
        printf(&ldquo;Derived dtor\n&rdquo;);
    } // </em>/</p>

<pre><code>virtual void Init() {
    printf("Derived::Init\n");
}

virtual void Release() {
    printf("Derived:Release\n");
}
</code></pre>

<p>};</p>

<p>int main()
{
    Base *obj = new Derived();
    delete obj;
    return 0;
}
{% endhighlight %}</p>

<p>去掉<code>Derived</code>的析构函数，去掉<code>Base</code>析构函数的<code>virtual</code>：</p>

<pre><code># g++ -Wa,-adhln -g test.cpp &gt; test.s

  44:test.cpp      ****     delete obj;
 227                    .loc 1 44 0
 228 0028 488B45F0      movq    -16(%rbp), %rax
 229 002c 488945E0      movq    %rax, -32(%rbp)
 230 0030 48837DE0      cmpq    $0, -32(%rbp)       
 230      00
 231 0035 7520          jne .L17                   
 232 0037 EB30          jmp .L18
...
 244                .L17:
 245                    .loc 1 44 0
 246 0057 488B7DE0      movq    -32(%rbp), %rdi
 247 005b E8000000      call    _ZN4BaseD1Ev             # 直接call
</code></pre>

<p>从这里甚至可以看到<code>delete</code>对空指针的判定。<code>Base</code>的析构函数不是<code>virtual</code>，所以这里编译器生成的析构函数调用代码根本不需要用到<code>vptr</code>，直接<code>call</code>就可以。而具体<code>call</code>谁则是根据<code>obj</code>指向的类型<code>Base</code>确定。<em>即使<code>Derived</code>用户定义了析构函数也不会调用，无论是否<code>virtual</code>。</em></p>

<p>事实上编译器甚至不需要生成<code>Derived</code>的析构函数，<em>多傻的编译器才会生成这些什么事都不做的代码而光进出函数就得好几条指令？</em></p>

<p>查看程序中的符号，没有生成<code>Derived</code>析构函数：</p>

<pre><code># nm test
...
0000000000400816 W _ZN4Base4InitEv
00000000004007fe W _ZN4Base7ReleaseEv
000000000040082e W _ZN4BaseC2Ev
0000000000400876 W _ZN4BaseD1Ev             
00000000004007e6 W _ZN7Derived4InitEv
00000000004007ce W _ZN7Derived7ReleaseEv
0000000000400852 W _ZN7DerivedC1Ev
...
</code></pre>

<p>现在把<code>Base</code>析构函数变为<code>virtual</code>的：</p>

<pre><code>  44:test.cpp      ****     delete obj;
 170                    .loc 1 44 0
 171 0028 48837DF0      cmpq    $0, -16(%rbp)
 171      00
 172 002d 7520          jne .L12
 173 002f EB32          jmp .L13
...
 185                .L12:
 186                    .loc 1 44 0
 187 004f 488B45F0      movq    -16(%rbp), %rax     # this -&gt; rax
 188 0053 488B00        movq    (%rax), %rax        # *rax -&gt; vptr
 189 0056 4883C008      addq    $8, %rax            # vptr += 8
 190 005a 488B00        movq    (%rax), %rax        # *vptr -&gt; Base::~Base
 191 005d 488B7DF0      movq    -16(%rbp), %rdi     # this as first argument (passed by rdi)
 192 0061 FFD0          call    *%rax               # call
</code></pre>

<p>析构函数动态调用这也是预期的。至于为什么是偏移<code>vptr+8</code>，是因为第一个指针指向的是<code>type_info</code>，具体可看<a href="http://www.cnblogs.com/zhyg6516/archive/2011/03/07/1971898.html">浅议 Dynamic_cast 和 RTTI</a>。<em>vptr和virtual function table还需要详述吗？</em></p>

<p>此时就会生成<code>Derived</code>的析构函数：</p>

<pre><code>...
000000000040084c W _ZN4Base4InitEv
00000000004008ac W _ZN4Base7ReleaseEv
0000000000400864 W _ZN4BaseC2Ev
0000000000400970 W _ZN4BaseD0Ev
00000000004009b0 W _ZN4BaseD1Ev
00000000004008c4 W _ZN4BaseD2Ev
0000000000400834 W _ZN7Derived4InitEv
000000000040081c W _ZN7Derived7ReleaseEv
0000000000400888 W _ZN7DerivedC1Ev
0000000000400904 W _ZN7DerivedD0Ev          
000000000040093a W _ZN7DerivedD1Ev
...
</code></pre>

<p>细心的人就会发现无论是<code>Base</code>还是<code>Derived</code>都会生成多个析构函数，这个深入下去还有很多内容，具体可以参看：<a href="http://stackoverflow.com/questions/6613870/gnu-gcc-g-why-does-it-generate-multiple-dtors">GNU GCC (g++): Why does it generate multiple dtors?</a>。</p>

<p>甚至可以运行这个例子看到调用到了<code>Derived</code>的析构函数：</p>

<pre><code>(gdb) ni
0x000000000040080d      45          return 0;
1: x/3i $pc
0x40080d &lt;main()+117&gt;:  callq  *%rax                  # 调用
0x40080f &lt;main()+119&gt;:  mov    $0x0,%eax
0x400814 &lt;main()+124&gt;:  add    $0x28,%rsp
(gdb) si
Derived::~Derived (this=0x7ffff7ffd000, __in_chrg=&lt;value optimized out&gt;) at test.cpp:24
24      class Derived : public Base {
1: x/3i $pc
0x400904 &lt;Derived::~Derived()&gt;: push   %rbp
0x400905 &lt;Derived::~Derived()+1&gt;:       mov    %rsp,%rbp
0x400908 &lt;Derived::~Derived()+4&gt;:       sub    $0x10,%rsp
</code></pre>

<p>其实看<code>Derived</code>的析构函数实现会发现很多有趣的东西：</p>

<pre><code>(gdb) disassemble 'Derived::~Derived'
Dump of assembler code for function Derived::~Derived():
0x0000000000400904 &lt;Derived::~Derived()+0&gt;:     push   %rbp
0x0000000000400905 &lt;Derived::~Derived()+1&gt;:     mov    %rsp,%rbp
0x0000000000400908 &lt;Derived::~Derived()+4&gt;:     sub    $0x10,%rsp
0x000000000040090c &lt;Derived::~Derived()+8&gt;:     mov    %rdi,-0x8(%rbp)
0x0000000000400910 &lt;Derived::~Derived()+12&gt;:    mov    $0x400b50,%edx
0x0000000000400915 &lt;Derived::~Derived()+17&gt;:    mov    -0x8(%rbp),%rax
0x0000000000400919 &lt;Derived::~Derived()+21&gt;:    mov    %rdx,(%rax)
0x000000000040091c &lt;Derived::~Derived()+24&gt;:    mov    -0x8(%rbp),%rdi
0x0000000000400920 &lt;Derived::~Derived()+28&gt;:    callq  0x4008c4 &lt;Base::~Base()&gt;
0x0000000000400925 &lt;Derived::~Derived()+33&gt;:    mov    $0x1,%eax
0x000000000040092a &lt;Derived::~Derived()+38&gt;:    test   %al,%al
0x000000000040092c &lt;Derived::~Derived()+40&gt;:    je     0x400937 &lt;Derived::~Derived()+51&gt;
0x000000000040092e &lt;Derived::~Derived()+42&gt;:    mov    -0x8(%rbp),%rdi
0x0000000000400932 &lt;Derived::~Derived()+46&gt;:    callq  0x400670 &lt;_ZdlPv@plt&gt;               
0x0000000000400937 &lt;Derived::~Derived()+51&gt;:    leaveq
0x0000000000400938 &lt;Derived::~Derived()+52&gt;:    retq
</code></pre>

<p>实际上这个析构函数就是上面的<code>D0</code>版本，它做了一件重要的事就是<code>delete this</code>。具体的可以google gcc对析构函数的实现。</p>

<p>构造函数和析构函数中根本就不会启用多态，这个是结论或者说是标准，但不是原因(真怕又有人告诉我c++ standard某section这样写的所以这就是理由)。既然反正已经看实现了，就索性看一眼编译器怎么处理这个问题：</p>

<pre><code>// Base::~Base
 261 0000 55            pushq   %rbp
 262                .LCFI22:
 263 0001 4889E5        movq    %rsp, %rbp
 264                .LCFI23:
 265 0004 4883EC10      subq    $16, %rsp
 266                .LCFI24:
 267 0008 48897DF8      movq    %rdi, -8(%rbp)
 268                    .loc 1 10 0
 269 000c BA000000      movl    $_ZTV4Base+16, %edx
 269      00
 270 0011 488B45F8      movq    -8(%rbp), %rax
 271 0015 488910        movq    %rdx, (%rax)
 272                    .loc 1 11 0
 273 0018 BF000000      movl    $.LC4, %edi
 273      00
 274 001d E8000000      call    puts
 274      00
 275                    .loc 1 12 0
 276 0022 488B7DF8      movq    -8(%rbp), %rdi
 277 0026 E8000000      call    _ZN4Base7ReleaseEv  # 直接call绝对地址
</code></pre>

<p>构造函数一样：</p>

<pre><code>  94 0000 55            pushq   %rbp
  95                .LCFI9:
  96 0001 4889E5        movq    %rsp, %rbp
  97                .LCFI10:
  98 0004 4883EC10      subq    $16, %rsp
  99                .LCFI11:
 100 0008 48897DF8      movq    %rdi, -8(%rbp)
 101                .LBB2:
 102                    .loc 1 5 0
 103 000c B8000000      movl    $_ZTV4Base+16, %eax
 103      00
 104 0011 488B55F8      movq    -8(%rbp), %rdx
 105 0015 488902        movq    %rax, (%rdx)
 106                    .loc 1 6 0
 107 0018 488B7DF8      movq    -8(%rbp), %rdi
 108 001c E8000000      call    _ZN4Base4InitEv  # 直接call地址
</code></pre>

<p><em>END</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C/C++中手动获取调用堆栈]]></title>
    <link href="http://codemacro.com/2014/09/02/stack-frame/"/>
    <updated>2014-09-02T00:00:00+08:00</updated>
    <id>http://codemacro.com/2014/09/02/stack-frame</id>
    <content type="html"><![CDATA[<p>当我们的程序core掉之后，如果能获取到core时的函数调用堆栈将非常有利于定位问题。在Windows下可以使用<a href="http://blog.csdn.net/starlee/article/details/6630816">SEH机制</a>；在Linux下通过gdb使用coredump文件即可。</p>

<p>但有时候由于某些错误导致堆栈被破坏，发生拿不到调用堆栈的情况。</p>

<p>一些基础预备知识本文不再详述，可以参考以下文章：</p>

<ul>
<li><a href="http://hutaow.com/blog/2013/10/15/dump-stack/">函数调用栈的获取原理分析</a></li>
<li><a href="http://www.findfunaax.com/notes/file/262">寄存器、函数调用与栈帧</a></li>
</ul>


<p>需要知道的信息：</p>

<ul>
<li>函数调用对应的<code>call</code>指令本质上是先压入下一条指令的地址到堆栈，然后跳转到目标函数地址</li>
<li>函数返回指令<code>ret</code>则是从堆栈取出一个地址，然后跳转到该地址</li>
<li>EBP寄存器始终指向当前执行函数相关信息（局部变量）所在栈中的位置，ESP则始终指向栈顶</li>
<li>每一个函数入口都会保存调用者的EBP值，在出口处都会重设EBP值，从而实现函数调用的现场保存及现场恢复</li>
<li>64位机器增加了不少寄存器，从而使得函数调用的参数大部分时候可以通过寄存器传递；同时寄存器名字发生改变，例如EBP变为RBP</li>
</ul>


<p>在函数调用中堆栈的情况可用下图说明：</p>

<!-- more -->


<p><img src="/assets/res/stack_frame/stack_frame.png" alt="" /></p>

<p>将代码对应起来：</p>

<p>{% highlight c++ %}
void g() {
    int <em>p = 0;
    long a = 0x1234;
    printf(&ldquo;%p %x\n&rdquo;, &amp;a, a);
    printf(&ldquo;%p %x\n&rdquo;, &amp;p, p);
    f();
    </em>p = 1;
}</p>

<p>void b(int argc, char **argv) {
    printf(&ldquo;%p %p\n&rdquo;, &amp;argc, &amp;argv);
    g();
}</p>

<p>int main(int argc, char **argv) {
    b(argc, argv);
    return 0;
}
{% endhighlight %}</p>

<p>在函数<code>g()</code>中断点，看看堆栈中的内容(64位机器)：</p>

<pre><code>(gdb) p $rbp
$2 = (void *) 0x7fffffffe370
(gdb) p &amp;p
$3 = (int **) 0x7fffffffe368
(gdb) p $rsp
$4 = (void *) 0x7fffffffe360
(gdb) x/8ag $rbp-16
0x7fffffffe360: 0x1234  0x0
0x7fffffffe370: 0x7fffffffe390  0x400631 &lt;b(int, char**)+43&gt;
0x7fffffffe380: 0x7fffffffe498  0x1a561cbc0
0x7fffffffe390: 0x7fffffffe3b0  0x40064f &lt;main(int, char**)+27&gt;
</code></pre>

<p>对应的堆栈图：</p>

<p><img src="/assets/res/stack_frame/stack_frame_ex.png" alt="" /></p>

<p>可以看看例子中<code>0x400631 &lt;b(int, char**)+43&gt;</code>和<code>0x40064f &lt;main(int, char**)+27&gt;</code>中的代码：</p>

<pre><code>(gdb) disassemble 0x400631
...
0x0000000000400627 &lt;b(int, char**)+33&gt;: callq  0x400468 &lt;printf@plt&gt;
0x000000000040062c &lt;b(int, char**)+38&gt;: callq  0x4005ae &lt;g()&gt;
0x0000000000400631 &lt;b(int, char**)+43&gt;: leaveq                           # call的下一条指令
...

(gdb) disassemble 0x40064f
... 
0x000000000040063f &lt;main(int, char**)+11&gt;:      mov    %rsi,-0x10(%rbp)
0x0000000000400643 &lt;main(int, char**)+15&gt;:      mov    -0x10(%rbp),%rsi
0x0000000000400647 &lt;main(int, char**)+19&gt;:      mov    -0x4(%rbp),%edi
0x000000000040064a &lt;main(int, char**)+22&gt;:      callq  0x400606 &lt;b(int, char**)&gt;
0x000000000040064f &lt;main(int, char**)+27&gt;:      mov    $0x0,%eax         # call的下一条指令
...
</code></pre>

<p>顺带一提，每个函数入口和出口，对应的设置RBP代码为：</p>

<pre><code>(gdb) disassemble g
...
0x00000000004005ae &lt;g()+0&gt;:     push   %rbp               # 保存调用者的RBP到堆栈
0x00000000004005af &lt;g()+1&gt;:     mov    %rsp,%rbp          # 设置自己的RBP
...
0x0000000000400603 &lt;g()+85&gt;:    leaveq                    # 等同于：movq %rbp, %rsp
                                                          #         popq %rbp
0x0000000000400604 &lt;g()+86&gt;:    retq                      
</code></pre>

<p>由以上可见，<strong>通过当前的RSP或RBP就可以找到调用堆栈中所有函数的RBP；找到了RBP就可以找到函数地址</strong>。因为，任何时候的RBP指向的堆栈位置就是上一个函数的RBP；而任何时候RBP所在堆栈中的前一个位置就是函数返回地址。</p>

<p>由此我们可以自己构建一个导致gdb无法取得调用堆栈的例子：</p>

<p>{% highlight c++ %}
void f() {
    long <em>p = 0;
    p = (long</em>) (&amp;p + 1); // 取得g()的RBP
    *p = 0;  // 破坏g()的RBP
}</p>

<p>void g() {
    int <em>p = 0;
    long a = 0x1234;
    printf(&ldquo;%p %x\n&rdquo;, &amp;a, a);
    printf(&ldquo;%p %x\n&rdquo;, &amp;p, p);
    f();
    </em>p = 1; // 写0地址导致一次core
}</p>

<p>void b(int argc, char **argv) {
    printf(&ldquo;%p %p\n&rdquo;, &amp;argc, &amp;argv);
    g();
}</p>

<p>int main(int argc, char **argv) {
    b(argc, argv);
    return 0;
}
{% endhighlight %}</p>

<p>使用gdb运行该程序：</p>

<pre><code>Program received signal SIGSEGV, Segmentation fault.
g () at ebp.c:37
37          *p = 1;
(gdb) bt
Cannot access memory at address 0x8
(gdb) p $rbp
$1 = (void *) 0x0
</code></pre>

<p><code>bt</code>无法获取堆栈，在函数<code>g()</code>中RBP被改写为0，gdb从0偏移一个地址长度即0x8，尝试从0x8内存位置获取函数地址，然后提示<code>Cannot access memory at address 0x8</code>。</p>

<p><strong>RBP出现了问题，我们就可以通过RSP来手动获取调用堆栈。</strong>因为RSP是不会被破坏的，要通过RSP获取调用堆栈则需要偏移一些局部变量所占的空间：</p>

<pre><code>(gdb) p $rsp
$2 = (void *) 0x7fffffffe360
(gdb) x/8ag $rsp+16             # g()中局部变量占16字节
0x7fffffffe370: 0x7fffffffe390  0x400631 &lt;b(int, char**)+43&gt;
0x7fffffffe380: 0x7fffffffe498  0x1a561cbc0
0x7fffffffe390: 0x7fffffffe3b0  0x40064f &lt;main(int, char**)+27&gt;
0x7fffffffe3a0: 0x7fffffffe498  0x100000000
</code></pre>

<p>基于以上就可以手工找到调用堆栈：</p>

<pre><code>g()
0x400631 &lt;b(int, char**)+43&gt;
0x40064f &lt;main(int, char**)+27&gt;
</code></pre>

<p>上面的例子本质上也是破坏堆栈，并且仅仅破坏了保存了的RBP。在实际情况中，堆栈可能会被破坏得更多，则可能导致手动定位也较困难。</p>

<p>堆栈被破坏还可能导致更多的问题，例如覆盖了函数返回地址，则会导致RIP错误；例如堆栈的不平衡。导致堆栈被破坏的原因也有很多，例如局部数组越界；<a href="http://codemacro.com/2013/08/15/debug-esp-bug/">delete/free栈上对象等</a>。</p>

<h2>omit-frame-pointer</h2>

<p>使用RBP获取调用堆栈相对比较容易。但现在编译器都可以设置不使用RBP(gcc使用-fomit-frame-pointer，msvc使用/Oy)，对于函数而言不设置其RBP意味着可以节省若干条指令。在函数内部则完全使用RSP的偏移来定位局部变量，包括嵌套作用域里的局部变量，即使程序实际运行时不会进入这个作用域。</p>

<p>例如：</p>

<p>{% highlight c++ %}
void f2() {
    int a = 0x1234;
    if (a > 0) {
        int b = 0xff;
        b = a;
    }
}
{% endhighlight %}</p>

<p>gcc中使用<code>-fomit-frame-pointer</code>生成的代码为：</p>

<pre><code>(gdb) disassemble f2
Dump of assembler code for function f2:
0x00000000004004a5 &lt;f2+0&gt;:      movl   $0x1234,-0x8(%rsp)    # int a = 0x1234
0x00000000004004ad &lt;f2+8&gt;:      cmpl   $0x0,-0x8(%rsp)       
0x00000000004004b2 &lt;f2+13&gt;:     jle    0x4004c4 &lt;f2+31&gt;      
0x00000000004004b4 &lt;f2+15&gt;:     movl   $0xff,-0x4(%rsp)      # int b = 0xff
0x00000000004004bc &lt;f2+23&gt;:     mov    -0x8(%rsp),%eax
0x00000000004004c0 &lt;f2+27&gt;:     mov    %eax,-0x4(%rsp)
0x00000000004004c4 &lt;f2+31&gt;:     retq
</code></pre>

<p>可以发现<code>f2()</code>没有操作<code>RBP</code>之类的指令了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于protobuf的RPC实现]]></title>
    <link href="http://codemacro.com/2014/08/31/protobuf-rpc/"/>
    <updated>2014-08-31T00:00:00+08:00</updated>
    <id>http://codemacro.com/2014/08/31/protobuf-rpc</id>
    <content type="html"><![CDATA[<p>可以对照<a href="http://www.codedump.info/?p=169">使用google protobuf RPC实现echo service</a>一文看，细节本文不再描述。</p>

<p>google protobuf只负责消息的打包和解包，并不包含RPC的实现，但其包含了RPC的定义。假设有下面的RPC定义：</p>

<p>{% highlight c++ %}
    service MyService {
        rpc Echo(EchoReqMsg) returns(EchoRespMsg)
    }
{% endhighlight %}</p>

<p>那么要实现这个RPC需要最少做哪些事？总结起来需要完成以下几步：</p>

<h2>客户端</h2>

<p>RPC客户端需要实现<code>google::protobuf::RpcChannel</code>。主要实现<code>RpcChannel::CallMethod</code>接口。客户端调用任何一个RPC接口，最终都是调用到<code>CallMethod</code>。这个函数的典型实现就是将RPC调用参数序列化，然后投递给网络模块进行发送。</p>

<p>{% highlight c++ %}
    void CallMethod(const ::google::protobuf::MethodDescriptor<em> method,
                  ::google::protobuf::RpcController</em> controller,
                  const ::google::protobuf::Message<em> request,
                  ::google::protobuf::Message</em> response,
                  ::google::protobuf::Closure* done) {
        &hellip;
        DataBufferOutputStream outputStream(&hellip;) // 取决于你使用的网络实现
        request->SerializeToZeroCopyStream(&amp;outputStream);
        _connection->postData(outputStream.getData(), &hellip;
        &hellip;
    }
{% endhighlight %}</p>

<!-- more -->


<h2>服务端</h2>

<p>服务端首先需要实现RPC接口，直接实现<code>MyService</code>中定义的接口：</p>

<p>{% highlight c++ %}
    class MyServiceImpl : public MyService {
        virtual void Echo(::google::protobuf::RpcController<em> controller,
            const EchoReqMsg</em> request,
            EchoRespMsg<em> response,
            ::google::protobuf::Closure</em> done) {
            &hellip;
            done->Run();
        }
    }
{% endhighlight %}</p>

<h2>标示service&amp;method</h2>

<p>基于以上，可以看出服务端根本不知道客户端想要调用哪一个RPC接口。从服务器接收到网络消息，到调用到<code>MyServiceImpl::Echo</code>还有很大一段距离。</p>

<p>解决方法就是在网络消息中带上RPC接口标识。这个标识可以直接带上service name和method name，但这种实现导致网络消息太大。另一种实现是基于service name和method name生成一个哈希值，因为接口不会太多，所以较容易找到基本不冲突的字符串哈希算法。</p>

<p>无论哪种方法，服务器是肯定需要建立RPC接口标识到protobuf service对象的映射的。</p>

<p>这里提供第三种方法：基于option的方法。</p>

<p>protobuf中option机制类似于这样一种机制：service&amp;method被视为一个对象，其有很多属性，属性包含内置的，以及用户扩展的。用户扩展的就是option。每一个属性有一个值。protobuf提供访问service&amp;method这些属性的接口。</p>

<p>首先扩展service&amp;method的属性，以下定义这些属性的key：</p>

<p>{% highlight c++ %}
    extend google.protobuf.ServiceOptions {
      required uint32 global_service_id = 1000;
    }
    extend google.protobuf.MethodOptions {
      required uint32 local_method_id = 1000;
    }
{% endhighlight %}</p>

<p>应用层定义service&amp;method时可以指定以上key的值：</p>

<p>{% highlight c++ %}
    service MyService
    {
        option (arpc.global_service_id) = 2302;</p>

<pre><code>    rpc Echo(EchoReqMsg) returns(EchoRespMsg) 
    {
        option (arpc.local_method_id) = 1;
    }
    rpc Echo_2(EchoReqMsg) returns(EchoRespMsg) 
    {
        option (arpc.local_method_id) = 2;
    }
    ...
}
</code></pre>

<p>{% endhighlight %}</p>

<p>以上相当于在整个应用中，每个service都被赋予了唯一的id，单个service中的method也有唯一的id。</p>

<p>然后可以通过protobuf取出以上属性值：</p>

<p>{% highlight c++ %}
    void CallMethod(const ::google::protobuf::MethodDescriptor<em> method,
                  ::google::protobuf::RpcController</em> controller,
                  const ::google::protobuf::Message<em> request,
                  ::google::protobuf::Message</em> response,
                  ::google::protobuf::Closure<em> done) {
        &hellip;
        google::protobuf::ServiceDescriptor </em>service = method->service();
        uint32_t serviceId = (uint32_t)(service->options().GetExtension(global_service_id));
        uint32_t methodId = (uint32_t)(method->options().GetExtension(local_method_id));
        &hellip;
    }
{% endhighlight %}</p>

<p>考虑到<code>serviceId</code> <code>methodId</code>的范围，可以直接打包到一个32位整数里：</p>

<pre><code>uint32_t ret = (serviceId &lt;&lt; 16) | methodId;
</code></pre>

<p>然后就可以把这个值作为网络消息头的一部分发送。</p>

<p>当然服务器端是需要建立这个标识值到service的映射的：</p>

<p>{% highlight c++ %}
    bool MyRPCServer::registerService(google::protobuf::Service *rpcService) {
        const google::protobuf::ServiceDescriptor = rpcService->GetDescriptor();
        int methodCnt = pSerDes->method_count();</p>

<pre><code>    for (int i = 0; i &lt; methodCnt; i++) {
        google::protobuf::MethodDescriptor *pMethodDes = pSerDes-&gt;method(i);
        uint32_t rpcCode = PacketCodeBuilder()(pMethodDes); // 计算出映射值
        _rpcCallMap[rpcCode] = make_pair(rpcService, pMethodDes); // 建立映射
    }
    return true;
}
</code></pre>

<p>{% endhighlight %}</p>

<p>服务端收到RPC调用后，取出这个标识值，然后再从<code>_rpcCallMap</code>中取出对应的service和method，最后进行调用：</p>

<p>{% highlight c++ %}
    google::protobuf::Message<em> response = <em>pService->GetResponsePrototype(</em>pMethodDes).New();
    // 用于回应的closure
    RPCServerClosure </em>pClosure = new (nothrow) RPCServerClosure(
            <em>channelId, </em>pConnection, <em>pReqMsg, pResMsg, </em>messageCodec, <em>version);
    RPCController *pController = pClosure->GetRpcController();
    &hellip;
    // protobuf 生成的CallMethod，会自动调用到Echo接口
    </em>pService->CallMethod(<em>pMethodDes, pController, </em>pReqMsg, pResMsg, pClosure);
{% endhighlight %}</p>

<h2>参考</h2>

<ul>
<li><a href="http://www.codedump.info/?p=169">使用google protobuf RPC实现echo service</a></li>
<li><a href="https://developers.google.com/protocol-buffers/docs/proto?hl=zh-cn#extensions">protobuf extensions</a></li>
<li><a href="https://developers.google.com/protocol-buffers/docs/proto#services">protobuf service</a></li>
<li><a href="https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.descriptor#MethodDescriptor.options.details">protobuf options</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[muduo源码阅读]]></title>
    <link href="http://codemacro.com/2014/05/04/muduo-source/"/>
    <updated>2014-05-04T00:00:00+08:00</updated>
    <id>http://codemacro.com/2014/05/04/muduo-source</id>
    <content type="html"><![CDATA[<p>最近简单读了下<a href="http://blog.csdn.net/solstice/article/details/5848547">muduo</a>的源码，本文对其主要实现/结构简单总结下。</p>

<p>muduo的主要源码位于net文件夹下，base文件夹是一些基础代码，不影响理解网络部分的实现。muduo主要类包括：</p>

<ul>
<li>EventLoop</li>
<li>Channel</li>
<li>Poller</li>
<li>TcpConnection</li>
<li>TcpClient</li>
<li>TcpServer</li>
<li>Connector</li>
<li>Acceptor</li>
<li>EventLoopThread</li>
<li>EventLoopThreadPool</li>
</ul>


<p>其中，Poller（及其实现类）包装了Poll/EPoll，封装了OS针对设备(fd)的操作；Channel是设备fd的包装，在muduo中主要包装socket；TcpConnection抽象一个TCP连接，无论是客户端还是服务器只要建立了网络连接就会使用TcpConnection；TcpClient/TcpServer分别抽象TCP客户端和服务器；Connector/Acceptor分别包装TCP客户端和服务器的建立连接/接受连接；EventLoop是一个主控类，是一个事件发生器，它驱动Poller产生/发现事件，然后将事件派发到Channel处理；EventLoopThread是一个带有EventLoop的线程；EventLoopThreadPool自然是一个EventLoopThread的资源池，维护一堆EventLoopThread。</p>

<p>阅读库源码时可以从库的接口层着手，看看关键功能是如何实现的。对于muduo而言，可以从TcpServer/TcpClient/EventLoop/TcpConnection这几个类着手。接下来看看主要功能的实现：</p>

<!-- more -->


<h2>建立连接</h2>

<p>{% highlight c++ %}
    TcpClient::connect
        -> Connector::start
            -> EventLoop::runInLoop(Connector::startInLoop&hellip;
            -> Connector::connect           <br/>
{% endhighlight %}</p>

<p>EventLoop::runInLoop接口用于在this所在的线程运行某个函数，这个后面看下EventLoop的实现就可以了解。 网络连接的最终建立是在Connector::connect中实现，建立连接之后会创建一个Channel来代表这个socket，并且绑定事件监听接口。最后最重要的是，调用<code>Channel::enableWriting</code>。<code>Channel</code>有一系列的enableXX接口，这些接口用于标识自己关心某IO事件。后面会看到他们的实现。</p>

<p>Connector监听的主要事件无非就是连接已建立，用它监听读数据/写数据事件也不符合设计。TcpConnection才是做这种事的。</p>

<h2>客户端收发数据</h2>

<p>当Connector发现连接真正建立好后，会回调到<code>TcpClient::newConnection</code>，在TcpClient构造函数中：</p>

<p>{% highlight c++ %}
    connector<em>->setNewConnectionCallback(
      boost::bind(&amp;TcpClient::newConnection, this, </em>1));
{% endhighlight %}</p>

<p><code>TcpClient::newConnection</code>中创建一个TcpConnection来代表这个连接：</p>

<p>{% highlight c++ %}
    TcpConnectionPtr conn(new TcpConnection(loop_,
                                            connName,
                                            sockfd,
                                            localAddr,
                                            peerAddr));</p>

<pre><code>conn-&gt;setConnectionCallback(connectionCallback_);
conn-&gt;setMessageCallback(messageCallback_);
conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);
...
conn-&gt;connectEstablished();
</code></pre>

<p>{% endhighlight %}</p>

<p>并同时设置事件回调，以上设置的回调都是应用层（即库的使用者）的接口。每一个TcpConnection都有一个Channel，毕竟每一个网络连接都对应了一个socket fd。在TcpConnection构造函数中创建了一个Channel，并设置事件回调函数。</p>

<p><code>TcpConnection::connectEstablished</code>函数最主要的是通知Channel自己开始关心IO读取事件：</p>

<p>{% highlight c++ %}
    void TcpConnection::connectEstablished()
    {
        &hellip;
        channel_->enableReading();
{% endhighlight %}</p>

<p>这是自此我们看到的第二个<code>Channel::enableXXX</code>接口，这些接口是如何实现关心IO事件的呢？这个后面讲到。</p>

<p>muduo的数据发送都是通过<code>TcpConnection::send</code>完成，这个就是一般网络库中在不使用OS的异步IO情况下的实现：缓存应用层传递过来的数据，在IO设备可写的情况下尽量写入数据。这个主要实现在<code>TcpConnection::sendInLoop</code>中。</p>

<p>{% highlight c++ %}
    TcpConnection::sendInLoop(&hellip;.) {
        &hellip;
        // if no thing in output queue, try writing directly
        if (!channel<em>->isWriting() &amp;&amp; outputBuffer</em>.readableBytes() == 0)  // 设备可写且没有缓存时立即写入
        {
            nwrote = sockets::write(channel<em>->fd(), data, len);
        }
        &hellip;
        // 否则加入数据到缓存，等待IO可写时再写
        outputBuffer</em>.append(static_cast<const char*>(data)+nwrote, remaining);
        if (!channel<em>->isWriting())
        {
            // 注册关心IO写事件，Poller就会对写做检测
            channel</em>->enableWriting();
        }
        &hellip;   <br/>
    }
{% endhighlight %}</p>

<p>当IO可写时，Channel就会回调<code>TcpConnection::handleWrite</code>（构造函数中注册）</p>

<p>{% highlight c++ %}
    void TcpConnection::handleWrite()
    {
        &hellip;
        if (channel<em>->isWriting())
        {
            ssize_t n = sockets::write(channel</em>->fd(),
                               outputBuffer<em>.peek(),
                               outputBuffer</em>.readableBytes());
{% endhighlight %}</p>

<p>服务器端的数据收发同客户端机制一致，不同的是连接(TcpConnection)的建立方式不同。</p>

<h2>服务器接收连接</h2>

<p>服务器接收连接的实现在一个网络库中比较重要。muduo中通过Acceptor类来接收连接。在TcpClient中，其Connector通过一个关心Channel可写的事件来通过连接已建立；在Acceptor中则是通过一个Channel可读的事件来表示有新的连接到来：</p>

<p>{% highlight c++ %}
    Acceptor::Acceptor(&hellip;.) {
        &hellip;
        acceptChannel_.setReadCallback(
            boost::bind(&amp;Acceptor::handleRead, this));
        &hellip;
    }</p>

<pre><code>void Acceptor::handleRead()
{
    ...
    int connfd = acceptSocket_.accept(&amp;peerAddr); // 接收连接获得一个新的socket
    if (connfd &gt;= 0)
    {
        ...
        newConnectionCallback_(connfd, peerAddr); // 回调到TcpServer::newConnection
</code></pre>

<p>{% endhighlight %}</p>

<p><code>TcpServer::newConnection</code>中建立一个TcpConnection，并将其附加到一个EventLoopThread中，简单来说就是给其配置一个线程：</p>

<p>{% highlight c++ %}
    void TcpServer::newConnection(int sockfd, const InetAddress&amp; peerAddr)
    {
        &hellip;
        EventLoop* ioLoop = threadPool<em>->getNextLoop();
        TcpConnectionPtr conn(new TcpConnection(ioLoop,
                                                connName,
                                                sockfd,
                                                localAddr,
                                                peerAddr));
        connections</em>[connName] = conn;
        &hellip;
        ioLoop->runInLoop(boost::bind(&amp;TcpConnection::connectEstablished, conn));
{% endhighlight %}</p>

<h2>IO的驱动</h2>

<p>之前提到，一旦要关心某IO事件了，就调用<code>Channel::enableXXX</code>，这个如何实现的呢？</p>

<p>{% highlight c++ %}
    class Channel {
        &hellip;
        void enableReading() { events<em> |= kReadEvent; update(); }
        void enableWriting() { events</em> |= kWriteEvent; update(); }</p>

<pre><code>void Channel::update()
{
    loop_-&gt;updateChannel(this);
}

void EventLoop::updateChannel(Channel* channel)
{
    ...
    poller_-&gt;updateChannel(channel);
}
</code></pre>

<p>{% endhighlight %}</p>

<p>最终调用到<code>Poller::upateChannel</code>。muduo中有两个Poller的实现，分别是Poll和EPoll，可以选择简单的Poll来看：</p>

<p>{% highlight c++ %}
    void PollPoller::updateChannel(Channel* channel)
    {
      &hellip;
      if (channel->index() &lt; 0)
      {
        // a new one, add to pollfds<em>
        assert(channels</em>.find(channel->fd()) == channels<em>.end());
        struct pollfd pfd;
        pfd.fd = channel->fd();
        pfd.events = static_cast<short>(channel->events()); // 也就是Channel::enableXXX操作的那个events</em>
        pfd.revents = 0;
        pollfds<em>.push_back(pfd); // 加入一个新的pollfd
        int idx = static_cast<int>(pollfds</em>.size())-1;
        channel->set_index(idx);
        channels_[pfd.fd] = channel;
{% endhighlight %}</p>

<p>可见Poller就是把Channel关心的IO事件转换为OS提供的IO模型数据结构上。通过查看关键的<code>pollfds_</code>的使用，可以发现其主要是在Poller::poll接口里。这个接口会在EventLoop的主循环中不断调用：</p>

<p>{% highlight c++ %}
    void EventLoop::loop()
    {
      &hellip;
      while (!quit<em>)
      {
        activeChannels</em>.clear();
        pollReturnTime<em> = poller</em>->poll(kPollTimeMs, &amp;activeChannels<em>);
        &hellip;
        for (ChannelList::iterator it = activeChannels</em>.begin();
            it != activeChannels<em>.end(); ++it)
        {
          currentActiveChannel</em> = *it;
          currentActiveChannel<em>->handleEvent(pollReturnTime</em>); // 获得IO事件，通知各注册回调
        }
{% endhighlight %}</p>

<p>整个流程可总结为：各Channel内部会把自己关心的事件告诉给Poller，Poller由EventLoop驱动检测IO，然后返回哪些Channel发生了事件，EventLoop再驱动这些Channel调用各注册回调。</p>

<p>从这个过程中可以看出，EventLoop就是一个事件产生器。</p>

<h2>线程模型</h2>

<p>在muduo的服务器中，muduo的线程模型是怎样的呢？它如何通过线程来支撑高并发呢？其实很简单，它为每一个线程配置了一个EventLoop，这个线程同时被附加了若干个网络连接，这个EventLoop服务于这些网络连接，为这些连接收集并派发IO事件。</p>

<p>回到<code>TcpServer::newConnection</code>中：</p>

<p>{% highlight c++ %}
    void TcpServer::newConnection(int sockfd, const InetAddress&amp; peerAddr)
    {
      &hellip;
      EventLoop* ioLoop = threadPool_->getNextLoop();
      &hellip;
      TcpConnectionPtr conn(new TcpConnection(ioLoop, // 使用这个选择到的线程中的EventLoop
                                              connName,
                                              sockfd,
                                              localAddr,
                                              peerAddr));
      &hellip;
      ioLoop->runInLoop(boost::bind(&amp;TcpConnection::connectEstablished, conn));
{% endhighlight %}</p>

<p>注意<code>TcpConnection::connectEstablished</code>是如何通过Channel注册关心的IO事件到<code>ioLoop</code>的。</p>

<p>极端来说，muduo的每一个连接线程可以只为一个网络连接服务，这就有点类似于thread per connection模型了。</p>

<h2>网络模型</h2>

<p>传说中的Reactor模式，以及one loop per thread，基于EventLoop的作用，以及线程池与TcpConnection的关系，可以醍醐灌顶般理解以下这张muduo的网络模型图了：</p>

<p><img src="/assets/res/muduo-model.png" alt="muduo-model" /></p>

<h2>总结</h2>

<p>本文主要对muduo的主要结构及主要机制的实现做了描述，其他如Buffer的实现、定时器的实现大家都可以自行研究。muduo的源码很清晰，通过源码及配合<a href="http://blog.csdn.net/solstice">陈硕博客</a>上的内容可以学到一些网络编程方面的经验。</p>
]]></content>
  </entry>
  
</feed>
