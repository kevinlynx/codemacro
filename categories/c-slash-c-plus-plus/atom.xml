<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c/c++ | loop in codes]]></title>
  <link href="http://codemacro.com/categories/c-slash-c-plus-plus/atom.xml" rel="self"/>
  <link href="http://codemacro.com/"/>
  <updated>2015-03-31T20:35:52+08:00</updated>
  <id>http://codemacro.com/</id>
  <author>
    <name><![CDATA[Kevin Lynx]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[基于内存查看STL常用容器内容]]></title>
    <link href="http://codemacro.com/2014/12/03/gdb_stl/"/>
    <updated>2014-12-03T00:00:00+08:00</updated>
    <id>http://codemacro.com/2014/12/03/gdb_stl</id>
    <content type="html"><![CDATA[<p>有时候在线上使用gdb调试程序core问题时，可能没有符号文件，拿到的仅是一个内存地址，如果这个指向的是一个STL对象，那么如何查看这个对象的内容呢？</p>

<p>只需要知道STL各个容器的数据结构实现，就可以查看其内容。本文描述了SGI STL实现中常用容器的数据结构，以及如何在gdb中查看其内容。</p>

<h2>string</h2>

<p>string，即<code>basic_string</code> <code>bits/basic_string.h</code>：</p>

<p>{% highlight c++ %}
    mutable <em>Alloc_hider  </em>M_dataplus;
    &hellip;
      const <em>CharT*
      c_str() const
      { return </em>M_data(); }
    &hellip;  <br/>
      <em>CharT*
      </em>M_data() const
      { return  <em>M_dataplus.</em>M_p; }</p>

<pre><code>...
  struct _Alloc_hider : _Alloc
  {
_Alloc_hider(_CharT* __dat, const _Alloc&amp; __a)
: _Alloc(__a), _M_p(__dat) { }

_CharT* _M_p; // The actual data.
  };

  size_type
  length() const
  { return _M_rep()-&gt;_M_length; }

  _Rep*
  _M_rep() const
  { return &amp;((reinterpret_cast&lt;_Rep*&gt; (_M_data()))[-1]); }

  ...
   struct _Rep_base
  {
size_type       _M_length;
size_type       _M_capacity;
_Atomic_word        _M_refcount;
  };

  struct _Rep : _Rep_base
</code></pre>

<p>{% endhighlight %}</p>

<p>即，string内有一个指针，指向实际的字符串位置，这个位置前面有一个<code>_Rep</code>结构，其内保存了字符串的长度、可用内存以及引用计数。当我们拿到一个string对象的地址时，可以通过以下代码获取相关值：</p>

<!-- more -->


<p>{% highlight c++ %}
    void ds_str_i(void <em>p) {
        char <strong>raw = (char</strong>)p;
        char </em>s = <em>raw;
        size_t len = </em>(size_t*)(s - sizeof(size_t) * 3);
        printf(&ldquo;str: %s (%zd)\n&rdquo;, s, len);
    }</p>

<pre><code>size_t ds_str() {
    std::string s = "hello";
    ds_str_i(&amp;s);
    return s.size();
}
</code></pre>

<p>{% endhighlight %}</p>

<p>在gdb中拿到一个string的地址时，可以以下打印出该字符串及长度：</p>

<pre><code>(gdb) x/1a p
0x7fffffffe3a0: 0x606028
(gdb) p (char*)0x606028
$2 = 0x606028 "hello"
(gdb) x/1dg 0x606028-24
0x606010:       5
</code></pre>

<h2>vector</h2>

<p>众所周知vector实现就是一块连续的内存，<code>bits/stl_vector.h</code>。</p>

<p>{% highlight c++ %}
    template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected <em>Vector_base&lt;</em>Tp, _Alloc></p>

<pre><code>...
template&lt;typename _Tp, typename _Alloc&gt;
struct _Vector_base
{
  typedef typename _Alloc::template rebind&lt;_Tp&gt;::other _Tp_alloc_type;

  struct _Vector_impl
  : public _Tp_alloc_type
  {
_Tp*           _M_start;
_Tp*           _M_finish;
_Tp*           _M_end_of_storage;
_Vector_impl(_Tp_alloc_type const&amp; __a)
: _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
{ }
  };


  _Vector_impl _M_impl;
</code></pre>

<p>{% endhighlight %}</p>

<p>可以看出<code>sizeof(vector&lt;xxx&gt;)=24</code>，其内也就是3个指针，<code>_M_start</code>指向首元素地址，<code>_M_finish</code>指向最后一个节点+1，<code>_M_end_of_storage</code>是可用空间最后的位置。</p>

<p>{% highlight c++ %}
      iterator
      end()
      { return iterator (this-><em>M_impl.</em>M_finish); }
      const_iterator
      &hellip;
      begin() const
      { return const_iterator (this-><em>M_impl.</em>M_start); }
      &hellip;
      size_type
      capacity() const
      { return size_type(const_iterator(this-><em>M_impl.</em>M_end_of_storage)
             - begin()); }
{% endhighlight %}</p>

<p>可以通过代码从一个vector对象地址输出其信息：</p>

<p>{% highlight c++ %}
    template <typename T>
    void ds_vec_i(void <em>p) {
        T </em>start = <em>(T**)p;
        T </em>finish = <em>(T**)((char</em>)p + sizeof(void<em>));
        T </em>end_storage = <em>(T**)((char</em>)p + 2 * sizeof(void*));
        printf(&ldquo;vec size: %ld, avaiable size: %ld\n&rdquo;, finish - start, end_storage - start);
    }</p>

<pre><code>size_t ds_vec() {
    std::vector&lt;int&gt; vec;
    vec.push_back(0x11);
    vec.push_back(0x22);
    vec.push_back(0x33);
    ds_vec_i&lt;int&gt;(&amp;vec);
    return vec.size();
}
</code></pre>

<p>{% endhighlight %}</p>

<p>使用gdb输出一个vector中的内容：</p>

<pre><code>(gdb) p p
$3 = (void *) 0x7fffffffe380
(gdb) x/1a p
0x7fffffffe380: 0x606080
(gdb) x/3xw 0x606080
0x606080:       0x00000011      0x00000022      0x00000033
</code></pre>

<h2>list</h2>

<p>众所周知list被实现为一个链表。准确来说是一个双向链表。list本身是一个特殊节点，其代表end，其指向的下一个元素才是list真正的第一个节点：</p>

<p><code>bits/stl_list.h</code></p>

<p>{% highlight c++ %}
      bool
      empty() const
      { return this-><em>M_impl.</em>M_node.<em>M_next == &amp;this-></em>M_impl._M_node; }</p>

<pre><code>  const_iterator
  begin() const
  { return const_iterator(this-&gt;_M_impl._M_node._M_next); }

  iterator
  end()
  { return iterator(&amp;this-&gt;_M_impl._M_node); }

  ...

struct _List_node_base
{
    _List_node_base* _M_next;   ///&lt; Self-explanatory
    _List_node_base* _M_prev;   ///&lt; Self-explanatory
    ...
};

template&lt;typename _Tp&gt;
struct _List_node : public _List_node_base
{
  _Tp _M_data;                ///&lt; User's data.
};

template&lt;typename _Tp, typename _Alloc&gt;
class _List_base
{
    ...
  struct _List_impl
  : public _Node_alloc_type
  {
_List_node_base _M_node;
    ...
  };

  _List_impl _M_impl;


template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt; &gt;
class list : protected _List_base&lt;_Tp, _Alloc&gt;
</code></pre>

<p>{% endhighlight %}</p>

<p>所以<code>sizeof(list&lt;xx&gt;)=16</code>，两个指针。每一个真正的节点首先是包含两个指针，然后是元素内容(<code>_List_node</code>)。</p>

<p>通过代码输出list的内容：</p>

<p>{% highlight c++ %}
    #define NEXT(ptr, T) do { \
        void <em>n = </em>(char<strong>)ptr; \
        T val = <em>(T</em>)((char</strong>)ptr + 2); \
        printf(&ldquo;list item %p val: 0x%x\n&rdquo;, ptr, val); \
        ptr = n; \
    } while (0)</p>

<pre><code>template &lt;typename T&gt;
void ds_list_i(void *p) {
    void *ptr = *(char**)p;

    NEXT(ptr, T);
    NEXT(ptr, T);
    NEXT(ptr, T);
}

size_t ds_list() {
    std::list&lt;int&gt; lst;
    lst.push_back(0x11);
    lst.push_back(0x22);
    lst.push_back(0x33);
    ds_list_i&lt;int&gt;(&amp;lst);
    return lst.size();
}
</code></pre>

<p>{% endhighlight %}</p>

<p>在gdb中可以以下方式遍历该list：</p>

<pre><code>(gdb) p p
$4 = (void *) 0x7fffffffe390
(gdb) x/1a p
0x7fffffffe390: 0x606080
(gdb) x/1xw 0x606080+16         # 元素1 
0x606090:       0x00000011
(gdb) x/1a 0x606080
0x606080:       0x6060a0
(gdb) x/1xw 0x6060a0+16         # 元素2
0x6060b0:       0x00000022
</code></pre>

<h2>map</h2>

<p>map使用的是红黑树实现，实际使用的是<code>stl_tree.h</code>实现：</p>

<p><code>bits/stl_map.h</code></p>

<p>{% highlight c++ %}
      typedef <em>Rb_tree&lt;key_type, value_type, </em>Select1st<value_type>,
               key_compare, <em>Pair_alloc_type> </em>Rep_type;
    &hellip;
     <em>Rep_type </em>M_t;
    &hellip;</p>

<pre><code>  iterator
  begin()
  { return _M_t.begin(); }
</code></pre>

<p>{% endhighlight %}</p>

<p><code>bits/stl_tree.h</code></p>

<p>{% highlight c++ %}
     struct <em>Rb_tree_node_base
      {
        typedef </em>Rb_tree_node_base<em> <em>Base_ptr;
        typedef const </em>Rb_tree_node_base</em> _Const_Base_ptr;</p>

<pre><code>    _Rb_tree_color  _M_color;
    _Base_ptr       _M_parent;
    _Base_ptr       _M_left;
    _Base_ptr       _M_right;

    ...
  };

template&lt;typename _Val&gt;
struct _Rb_tree_node : public _Rb_tree_node_base
{
  typedef _Rb_tree_node&lt;_Val&gt;* _Link_type;
  _Val _M_value_field;
};


template&lt;typename _Key_compare,
       bool _Is_pod_comparator = std::__is_pod&lt;_Key_compare&gt;::__value&gt;
    struct _Rb_tree_impl : public _Node_allocator
    {
  _Key_compare      _M_key_compare;
  _Rb_tree_node_base    _M_header;
  size_type         _M_node_count; // Keeps track of size of tree.
  ...
    }

_Rb_tree_impl&lt;_Compare&gt; _M_impl;
...

  iterator
  begin()
  {
return iterator(static_cast&lt;_Link_type&gt;
        (this-&gt;_M_impl._M_header._M_left));
  }
</code></pre>

<p>{% endhighlight %}</p>

<p>所以可以看出，大部分时候(取决于<code>_M_key_compare</code>) <code>sizeof(map&lt;xx&gt;)=48</code>，主要的元素是：</p>

<p>{% highlight c++ %}
        <em>Rb_tree_color  </em>M_color; // 节点颜色
        <em>Base_ptr       </em>M_parent; // 父节点
        <em>Base_ptr       </em>M_left; // 左节点
        <em>Base_ptr       </em>M_right; // 右节点
        <em>Val            </em>M_value_field // 同list中节点技巧一致，后面是实际的元素
{% endhighlight %}</p>

<p>同list中的实现一致，map本身作为一个节点，其不是一个存储数据的节点，</p>

<p><code>_Rb_tree::end</code></p>

<p>{% highlight c++ %}
      iterator
      end()
      { return iterator(static_cast<_Link_type>(&amp;this-><em>M_impl.</em>M_header)); }
{% endhighlight %}</p>

<p>由于节点值在<code>_Rb_tree_node_base</code>后，所以任意时候拿到节点就可以偏移这个结构体拿到节点值，节点的值是一个pair，包含了key和value。</p>

<p>在gdb中打印以下map的内容：</p>

<p>{% highlight c++ %}
    size_t ds_map() {
        std::map&lt;std::string, int> imap;
        imap[&ldquo;abc&rdquo;] = 0xbbb;
        return imap.size();
    }
{% endhighlight %}</p>

<pre><code>(gdb) p/x &amp;imap
$7 = 0x7fffffffe370
(gdb) x/1a (char*)&amp;imap+24       # _M_left 真正的节点
0x7fffffffe388: 0x606040          
(gdb) x/1xw 0x606040+32+8        # 偏移32字节是节点值的地址，再偏移8则是value的地址
0x606068:       0x00000bbb
(gdb) p *(char**)(0x606040+32)   # 偏移32字节是string的地址
$8 = 0x606028 "abc"
</code></pre>

<p>或者很多时候没有必要这么装逼+蛋疼：</p>

<pre><code>(gdb) p *(char**)(imap._M_t._M_impl._M_header._M_left+1)
$9 = 0x606028 "abc"
(gdb) x/1xw (char*)(imap._M_t._M_impl._M_header._M_left+1)+8
0x606068:       0x00000bbb
</code></pre>

<p><em>完</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux动态库的种种要点]]></title>
    <link href="http://codemacro.com/2014/11/04/linux-dynamic-library/"/>
    <updated>2014-11-04T00:00:00+08:00</updated>
    <id>http://codemacro.com/2014/11/04/linux-dynamic-library</id>
    <content type="html"><![CDATA[<p>linux下使用动态库，基本用起来还是很容易。但如果我们的程序中大量使用动态库来实现各种框架/插件，那么就会遇到一些坑，掌握这些坑才有利于程序更稳健地运行。</p>

<p>本篇先谈谈动态库符号方面的问题。</p>

<p>测试代码可以在<a href="https://github.com/kevinlynx/test/tree/master/dytest">github上找到</a></p>

<h2>符号查找</h2>

<p>一个应用程序<code>test</code>会链接一个动态库<code>libdy.so</code>，如果一个符号，例如函数<code>callfn</code>定义于libdy.so中，test要使用该函数，简单地声明即可：</p>

<p>{% highlight c++ %}
// dy.cpp libdy.so
void callfn() {
    &hellip;
}</p>

<p>// main.cpp test
extern void callfn();</p>

<p>callfn();  <br/>
{% endhighlight %}</p>

<p>在链接test的时候，链接器会统一进行检查。</p>

<p>同样，在libdy.so中有相同的规则，它可以使用一个外部的符号，<strong>在它被链接/载入进一个可执行程序时才会进行符号存在与否的检查</strong>。这个符号甚至可以定义在test中，形成一种双向依赖，或定义在其他动态库中：</p>

<!-- more -->


<p>{% highlight c++ %}
// dy.cpp libdy.so
extern void mfunc();</p>

<p>mfunc();</p>

<p>// main.cpp test
void mfunc() {
    &hellip;
}
{% endhighlight %}</p>

<p>在生成libdy.so时<code>mfunc</code>可以找不到，此时<code>mfunc</code>为未定义：</p>

<pre><code>$ nm libdy.so | grep mfun
U _Z5mfuncv
</code></pre>

<p>但在libdy.so被链接进test时则会进行检查，试着把<code>mfunc</code>函数的定义去掉，就会得到一个链接错误：</p>

<pre><code>./libdy.so: undefined reference to `mfunc()'
</code></pre>

<p>同样，如果我们动态载入libdy.so，此时当然可以链接通过，但是在载入时同样得到找不到符号的错误：</p>

<p>{% highlight c++ %}</p>

<h1>ifdef DY_LOAD</h1>

<pre><code>void *dp = dlopen("./libdy.so", RTLD_LAZY);
typedef void (*callfn)();
callfn f = (callfn) dlsym(dp, "callfn");
f();
dlclose(dp);
</code></pre>

<h1>else</h1>

<pre><code>callfn();
</code></pre>

<h1>endif</h1>

<p>{% endhighlight %}</p>

<p>得到错误：</p>

<pre><code>./test: symbol lookup error: ./libdy.so: undefined symbol: _Z5mfuncv
</code></pre>

<p><strong>结论：</strong>基于以上，我们知道，如果一个动态库依赖了一些外部符号，这些外部符号可以位于其他动态库甚至应用程序中。我们可以再链接这个动态库的时候就把依赖的其他库也链接上，或者推迟到链接应用程序时再链接。而动态加载的库，则要保证在加载该库时，进程中加载的其他动态库里已经存在该符号。</p>

<p>例如，通过<code>LD_PRELOAD</code>环境变量可以让一个进程先加载指定的动态库，上面那个动态加载启动失败的例子，可以通过预先加载包含<code>mfunc</code>符号的动态库解决：</p>

<pre><code>$ LD_PRELOAD=libmfun.so ./test
...
</code></pre>

<p>但是如果这个符号存在于可执行程序中则不行：</p>

<pre><code>$ nm test | grep mfunc
0000000000400a00 T _Z5mfuncv
$ nm test | grep mfunc
0000000000400a00 T _Z5mfuncv
$ ./test
...
./test: symbol lookup error: ./libdy.so: undefined symbol: _Z5mfuncv
</code></pre>

<h2>符号覆盖</h2>

<p>前面主要讲的是符号缺少的情况，如果同一个符号存在多分，则更能引发问题。这里谈到的符号都是全局符号，一个进程中某个全局符号始终是全局唯一的。为了保证这一点，在链接或动态载入动态库时，就会出现忽略重复符号的情况。</p>

<p><em>这里就不提同一个链接单位（如可执行程序、动态库）里符号重复的问题了</em></p>

<h3>函数</h3>

<p>当动态库和libdy.so可执行程序test中包含同名的函数时会怎样？根据是否动态加载情况还有所不同。</p>

<p>当直接链接动态库时，libdy.so和test都会链接包含<code>func</code>函数的fun.o，为了区分，我把<code>func</code>按照条件编译得到不同的版本：</p>

<p>{% highlight c++ %}
// fun.cpp</p>

<h1>ifdef V2</h1>

<p>extern &ldquo;C&rdquo; void func() {
    printf(&ldquo;func v2\n&rdquo;);
}</p>

<h1>else</h1>

<p>extern &ldquo;C&rdquo; void func() {
    printf(&ldquo;func v1\n&rdquo;);
}</p>

<h1>endif</h1>

<p>// Makefile
test: libdy obj.o mainfn
    g++ -g -Wall -c fun.cpp -o fun.o # 编译为fun.o
    g++ -g -Wall -c main.cpp #-DDY_LOAD
    g++ -g -Wall -o test main.o obj.o fun.o -ldl mfun.o -ldy -L.</p>

<p>libdy: obj
    g++ -Wall -fPIC -c fun.cpp -DV2 -o fun-dy.o  # 定义V2宏，编译为fun-dy.o
    g++ -Wall -fPIC -shared -o libdy.so dy.cpp -g obj.o fun-dy.o
{% endhighlight %}</p>

<p>这样，test中的<code>func</code>就会输出<code>func v1</code>；libdy.so中的<code>func</code>就会输出<code>func v2</code>。test和libdy.o确实都有<code>func</code>符号：</p>

<pre><code>$ nm libdy.so | grep func
0000000000000a60 T func

$nm test | grep func
0000000000400a80 T func
</code></pre>

<p>在test和libdy.so中都会调用<code>func</code>函数：</p>

<p>{% highlight c++ %}
// main.cpp test
int main(int argc, char **argv) {
    func();
    &hellip;
    callfn(); // 调用libdy.so中的函数
    &hellip;
}</p>

<p>// dy.cpp libdy.so
extern &ldquo;C&rdquo; void callfn() {
    &hellip;
    printf(&ldquo;callfn\n&rdquo;);
    func();
    &hellip;
}
{% endhighlight %}</p>

<p>运行后发现，都<strong>调用的是同一个<code>func</code></strong>：</p>

<pre><code>$ ./test
...
func v1
...
callfn
func v1
</code></pre>

<p><strong>结论</strong>，直接链接动态库时，整个程序运行的时候符号会发生覆盖，只有一个符号被使用。<strong>在实践中</strong>，如果程序和链接的动态库都依赖了一个静态库，而后他们链接的这个静态库版本不同，则很有可能因为符号发生了覆盖而导致问题。(静态库同普通的.o性质一样，参考<a href="http://codemacro.com/2014/09/15/inside-static-library/">浅析静态库链接原理</a>)</p>

<p>更复杂的情况中，多个动态库和程序都有相同的符号，情况也是一样，会发生符号覆盖。如果程序里没有这个符号，而多个动态库里有相同的符号，也会覆盖。</p>

<p>但是对于动态载入的情况则不同，同样的libdy.so我们在test中不链接，而是动态载入：</p>

<p>{% highlight c++ %}
int main(int argc, char **argv) {
    func();</p>

<h1>ifdef DY_LOAD</h1>

<pre><code>void *dp = dlopen("./libdy.so", RTLD_LAZY);
typedef void (*callfn)();
callfn f = (callfn) dlsym(dp, "callfn");
f();
func();
dlclose(dp);
</code></pre>

<h1>else</h1>

<pre><code>callfn();
</code></pre>

<h1>endif</h1>

<pre><code>return 0;
</code></pre>

<p>}
{% endhighlight %}</p>

<p>运行得到：</p>

<pre><code>$ ./test
func v1
...
callfn
func v2
func v1
</code></pre>

<p>都正确地调用到各自链接的<code>func</code>。</p>

<p><strong>结论</strong>，实践中，动态载入的动态库一般会作为插件使用，那么其同程序链接不同版本的静态库（相同符号不同实现），是没有问题的。</p>

<h3>变量</h3>

<p>变量本质上也是符号(symbol)，但其处理规则和函数还有点不一样(<em>是不是有点想吐槽了</em>)。</p>

<p>{% highlight c++ %}
// object.h
class Object {
public:
    Object() {</p>

<h1>ifdef DF</h1>

<pre><code>    s = malloc(32);
    printf("s addr %p\n", s);
</code></pre>

<h1>endif</h1>

<pre><code>    printf("ctor %p\n", this);
}

~Object() {
    printf("dtor %p\n", this);
</code></pre>

<h1>ifdef DF</h1>

<pre><code>    printf("s addr %p\n", s);
    free(s);
</code></pre>

<h1>endif</h1>

<pre><code>}

void *s;
</code></pre>

<p>};</p>

<p>extern Object g_obj;
{% endhighlight %}</p>

<p>我们的程序test和动态库libdy.so都会链接object.o。首先测试test链接libdy.so，test和libdy.so中都会有<code>g_obj</code>这个符号：</p>

<pre><code>// B g_obj 表示g_obj位于BSS段，未初始化段

$ nm test | grep g_obj
0000000000400a14 t _GLOBAL__I_g_obj
00000000006012c8 B g_obj
$ nm libdy.so | grep g_obj
000000000000097c t _GLOBAL__I_g_obj
0000000000200f30 B g_obj
</code></pre>

<p>运行：</p>

<pre><code>$ ./test
ctor 0x6012c8
ctor 0x6012c8
...
dtor 0x6012c8
dtor 0x6012c8
</code></pre>

<p><strong><code>g_obj</code>被构造了两次，但地址一样</strong>。全局变量只有一个实例，似乎在情理之中。</p>

<p>动态载入libdy.so，变量地址还是相同的：</p>

<pre><code>$ ./test
ctor 0x6012a8
...
ctor 0x6012a8
...
dtor 0x6012a8
dtor 0x6012a8
</code></pre>

<p><strong>结论</strong>，不同于函数，全局变量符号重复时，不论动态库是动态载入还是直接链接，变量始终只有一个。</p>

<p>但诡异的情况是，对象被构造和析构了两次。构造两次倒无所谓，浪费点空间，但是析构两次就有问题。因为析构时都操作的是同一个对象，那么如果这个对象内部有分配的内存，那就会对这块内存造成double free，因为指针相同。打开<code>DF</code>宏实验下：</p>

<pre><code>$ ./test
s addr 0x20de010
ctor 0x6012b8
s addr 0x20de040
ctor 0x6012b8
...
dtor 0x6012b8
s addr 0x20de040
dtor 0x6012b8
s addr 0x20de040
</code></pre>

<p>因为析构的两次都是同一个对象，所以其成员<code>s</code>指向的内存被释放了两次，从而产生了double free，让程序coredump了。</p>

<p><strong>总结</strong>，全局变量符号重复时，始终会只使用一个，并且会被初始化/释放两次，是一种较危险的情况，应当避免在使用动态库的过程中使用全局变量。</p>

<p><em>完</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅析glibc中thread tls的一处bug]]></title>
    <link href="http://codemacro.com/2014/10/07/pthread-tls-bug/"/>
    <updated>2014-10-07T00:00:00+08:00</updated>
    <id>http://codemacro.com/2014/10/07/pthread-tls-bug</id>
    <content type="html"><![CDATA[<p>最早的时候是在程序初始化过程中开启了一个timer(<code>timer_create</code>)，这个timer第一次触发的时间较短时就会引起程序core掉，core的位置也是不定的。使用valgrind可以发现有错误的内存写入：</p>

<pre><code>==31676== Invalid write of size 8
==31676==    at 0x37A540F852: _dl_allocate_tls_init (in /lib64/ld-2.5.so)
==31676==    by 0x4E26BD3: pthread_create@@GLIBC_2.2.5 (in /lib64/libpthread-2.5.so)
==31676==    by 0x76E0B00: timer_helper_thread (in /lib64/librt-2.5.so)
==31676==    by 0x4E2673C: start_thread (in /lib64/libpthread-2.5.so)
==31676==    by 0x58974BC: clone (in /lib64/libc-2.5.so)
==31676==  Address 0xf84dbd0 is 0 bytes after a block of size 336 alloc'd
==31676==    at 0x4A05430: calloc (vg_replace_malloc.c:418)
==31676==    by 0x37A5410082: _dl_allocate_tls (in /lib64/ld-2.5.so)
==31676==    by 0x4E26EB8: pthread_create@@GLIBC_2.2.5 (in /lib64/libpthread-2.5.so)
==31676==    by 0x76E0B00: timer_helper_thread (in /lib64/librt-2.5.so)
==31676==    by 0x4E2673C: start_thread (in /lib64/libpthread-2.5.so)
==31676==    by 0x58974BC: clone (in /lib64/libc-2.5.so)
</code></pre>

<p>google <code>_dl_allocate_tls_init</code> 相关发现一个glibc的bug <a href="https://sourceware.org/bugzilla/show_bug.cgi?id=13862">Bug 13862</a> 和我的情况有点类似。本文就此bug及tls相关实现做一定阐述。</p>

<p>需要查看glibc的源码，如何确认使用的glibc的版本，可以这样：</p>

<pre><code>$ /lib/libc.so.6
GNU C Library stable release version 2.5, by Roland McGrath et al.
...
</code></pre>

<p>为了方便，还可以直接在(glibc Cross Reference)[<a href="http://osxr.org/glibc/source/?v=glibc-2.17">http://osxr.org/glibc/source/?v=glibc-2.17</a>]网页上进行查看，版本不同，但影响不大。</p>

<!-- more -->


<h2>BUG描述</h2>

<p>要重现13862 BUG作者提到要满足以下条件：</p>

<blockquote><p>The use of a relatively large number of dynamic libraries, loaded at runtime using dlopen.</p>

<p>The use of thread-local-storage within those libraries.</p>

<p>A thread exiting prior to the number of loaded libraries increasing a significant amount, followed by a new thread being created after the number of libraries has increased.</p></blockquote>

<p>简单来说，就是在加载一大堆包含TLS变量的动态库的过程中，开启了一个线程，这个线程退出后又开启了另一个线程。</p>

<p>这和我们的问题场景很相似。不同的是我们使用的是timer，但timer在触发时也是开启新的线程，并且这个线程会立刻退出：</p>

<p><code>/nptl/sysdeps/unix/sysv/linux/timer_routines.c</code></p>

<p>{% highlight c++ %}
timer_helper_thread(&hellip;)  // 用于检测定时器触发的辅助线程
{
    &hellip;
      pthread_t th;
      (void) pthread_create (&amp;th, &amp;tk->attr, timer_sigev_thread, // 开启一个新线程调用用户注册的定时器函数
                 td);
    &hellip;
}
{% endhighlight %}</p>

<p>要重现此BUG可以使用我的实验代码 <a href="https://gist.github.com/kevinlynx/69435e718785a0ad12c4">thread-tls</a>，或者使用<a href="https://sourceware.org/bugzilla/attachment.cgi?id=6290">Bug 13862 中的附件</a></p>

<h2>TLS相关实现</h2>

<p>可以顺着<code>_dl_allocate_tls_init</code>函数的实现查看相关联的部分代码。该函数遍历所有加载的包含TLS变量的模块，初始化一个线程的TLS数据结构。</p>

<p>每一个线程都有自己的堆栈空间，其中单独存储了各个模块的TLS变量，从而实现TLS变量在每一个线程中都有单独的拷贝。TLS与线程的关联关系可以查看下图：</p>

<p><img src="/assets/res/pthread-tls.png" alt="" /></p>

<p>应用层使用的<code>pthread_t</code>实际是个<code>pthread</code>对象的地址。创建线程时线程的堆栈空间和<code>pthread</code>结构是一块连续的内存。但这个地址并不指向这块内存的首地址。相关代码：/nptl/allocatestack.c <code>allocate_stack</code>，该函数分配线程的堆栈内存。</p>

<p><code>pthread</code>第一个成员是<code>tcbhead_t</code>，<code>tcbhead_t</code>中<code>dtv</code>指向了一个<code>dtv_t</code>数组，该数组的大小随着当前程序载入的模块多少而动态变化。每一个模块被载入时，都有一个<code>l_tls_modid</code>，其直接作为<code>dtv_t</code>数组的下标索引。<code>tcbhead_t</code>中的<code>dtv</code>实际指向的是<code>dtv_t</code>第二个元素，第一个元素用于记录整个<code>dtv_t</code>数组有多少元素，第二个元素也做特殊使用，从第三个元素开始，才是用于存储TLS变量。</p>

<p>一个<code>dtv_t</code>存储的是一个模块中所有TLS变量的地址，当然这些TLS变量都会被放在连续的内存空间里。<code>dtv_t::pointer::val</code>正是用于指向这块内存的指针。对于非动态加载的模块它指向的是线程堆栈的位置；否则指向动态分配的内存位置。</p>

<p>以上结构用代码描述为，</p>

<p>{% highlight c++ %}
union dtv_t {
    size_t counter;
    struct {
        void <em>val; /</em> point to tls variable memory */
        bool is_static;
    } pointer;
};</p>

<p>struct tcbhead_t {
    void <em>tcb;
    dtv_t </em>dtv; /<em> point to a dtv_t array </em>/
    void <em>padding[22]; /</em> other members i don&rsquo;t care */
};</p>

<p>struct pthread {
    tcbhead_t tcb;
    /<em> more members i don&rsquo;t care </em>/
};
{% endhighlight %}</p>

<p><strong>dtv是一个用于以模块为单位存储TLS变量的数组</strong>。</p>

<p>实际代码参看 /nptl/descr.h 及 nptl/sysdeps/x86_64/tls.h。</p>

<h3>实验</h3>

<p>使用<code>g++ -o thread -g -Wall -lpthread -ldl thread.cpp</code>编译<a href="https://gist.github.com/kevinlynx/69435e718785a0ad12c4">代码</a>，即在创建线程前加载了一个.so：</p>

<pre><code>Breakpoint 1, dump_pthread (id=1084229952) at thread.cpp:40
40          printf("pthread %p, dtv %p\n", pd, dtv);
(gdb) set $dtv=pd-&gt;tcb.dtv
(gdb) p $dtv[-1]
$1 = {counter = 17, pointer = {val = 0x11, is_static = false}}
(gdb) p $dtv[3]
$2 = {counter = 18446744073709551615, pointer = {val = 0xffffffffffffffff, is_static = false}}
</code></pre>

<p><code>dtv[3]</code>对应着动态加载的模块，<code>is_static=false</code>，<code>val</code>被初始化为-1：</p>

<p>/elf/dl-tls.c <code>_dl_allocate_tls_init</code></p>

<p>{% highlight c++ %}
if (map->l_tls_offset == NO_TLS_OFFSET
   || map->l_tls_offset == FORCED_DYNAMIC_TLS_OFFSET)
 {
   /<em> For dynamically loaded modules we simply store
      the value indicating deferred allocation.  </em>/
   dtv[map->l_tls_modid].pointer.val = TLS_DTV_UNALLOCATED;
   dtv[map->l_tls_modid].pointer.is_static = false;
   continue;
 }
{% endhighlight %}</p>

<p><code>dtv</code>数组大小之所以为17，可以参看代码 /elf/dl-tls.c <code>allocate_dtv</code>：</p>

<p>{% highlight c++ %}
// dl_tls_max_dtv_idx 随着载入模块的增加而增加，载入1个.so则是1</p>

<p>dtv_length = GL(dl_tls_max_dtv_idx) + DTV_SURPLUS; // DTV_SURPLUS 14
dtv = calloc (dtv_length + 2, sizeof (dtv_t));
if (dtv != NULL)
 {
   /<em> This is the initial length of the dtv.  </em>/
   dtv[0].counter = dtv_length;
{% endhighlight %}</p>

<p>继续上面的实验，当调用到.so中的<code>function</code>时，其TLS被初始化，此时<code>dtv[3]</code>中<code>val</code>指向初始化后的TLS变量地址：</p>

<pre><code>68          fn();
(gdb)
0x601808, 0x601804, 0x601800
72          return 0;
(gdb) p $dtv[3]
$3 = {counter = 6297600, pointer = {val = 0x601800, is_static = false}}
(gdb) x/3xw 0x601800
0x601800:       0x55667788      0xaabbccdd      0x11223344
</code></pre>

<p>这个时候还可以看看<code>dtv[1]</code>中的内容，正是指向了<code>pthread</code>前面的内存位置：</p>

<pre><code>(gdb) p $dtv[1]
$5 = {counter = 1084229936, pointer = {val = 0x40a00930, is_static = true}}
(gdb) p/x tid
$7 = 0x40a00940
</code></pre>

<p><strong>结论</strong>:</p>

<ul>
<li>线程中TLS变量的存储是以模块为单位的</li>
</ul>


<h2>so模块加载</h2>

<p>这里也并不太需要查看<code>dlopen</code>等具体实现，由于使用<code>__thread</code>来定义TLS变量，整个实现涉及到ELF加载器的一些细节，深入下去内容较多。这里直接通过实验的手段来了解一些实现即可。</p>

<p>上文已经看到，<strong>在创建线程前如果动态加载了.so，dtv数组的大小是会随之增加的</strong>。如果是在线程创建后再载入.so呢？</p>

<p>使用<code>g++ -o thread -g -Wall -lpthread -ldl thread.cpp -DTEST_DTV_EXPAND -DSO_CNT=1</code>编译程序，调试得到：</p>

<pre><code>73          load_sos();
(gdb)
0x601e78, 0x601e74, 0x601e70

Breakpoint 1, dump_pthread (id=1084229952) at thread.cpp:44
44          printf("pthread %p, dtv %p\n", pd, dtv);
(gdb) p $dtv[-1]
$3 = {counter = 17, pointer = {val = 0x11, is_static = false}}
(gdb) p $dtv[4]
$4 = {counter = 6299248, pointer = {val = 0x601e70, is_static = false}}
</code></pre>

<p>在新载入了.so时，<code>dtv</code>数组大小并没有新增，<code>dtv[4]</code>直接被拿来使用。</p>

<p>因为<code>dtv</code>初始大小为16，那么当载入的.so超过这个数字的时候会怎样？</p>

<p>使用<code>g++ -o thread -g -Wall -lpthread -ldl thread.cpp -DTEST_DTV_EXPAND</code>编译程序：</p>

<pre><code>...
pthread 0x40a00940, dtv 0x6016a0
...
Breakpoint 1, dump_pthread (id=1084229952) at thread.cpp:44
44          printf("pthread %p, dtv %p\n", pd, dtv);
(gdb) p dtv
$2 = (dtv_t *) 0x6078a0
(gdb) p dtv[-1]
$3 = {counter = 32, pointer = {val = 0x20, is_static = false}}
(gdb) p dtv[5]
$4 = {counter = 6300896, pointer = {val = 0x6024e0, is_static = false}}
</code></pre>

<p>可以看出，<code>dtv</code>被重新分配了内存(0x6016a0 -> 0x6078a0)并做了扩大。</p>

<p>以上得出结论：</p>

<ul>
<li>创建线程前dtv的大小会根据载入模块数量决定</li>
<li>创建线程后新载入的模块会动态扩展dtv的大小(必要的时候)</li>
</ul>


<h2>pthread堆栈重用</h2>

<p>在<code>allocate_stack</code>中分配线程堆栈时，有一个从缓存中取的操作：</p>

<p>{% highlight c++ %}
allocate_stack(..) {
    &hellip;
    pd = get_cached_stack (&amp;size, &amp;mem);
    &hellip;
}
/<em> Get a stack frame from the cache.  We have to match by size since
   some blocks might be too small or far too large.  </em>/
get_cached_stack(&hellip;) {
    &hellip;
    list_for_each (entry, &amp;stack_cache) // 根据size从stack_cache中取
    { &hellip; }
    &hellip;
    /<em> Clear the DTV.  </em>/
    dtv_t *dtv = GET_DTV (TLS_TPADJ (result));
    for (size_t cnt = 0; cnt &lt; dtv[-1].counter; ++cnt)
        if (! dtv[1 + cnt].pointer.is_static
                &amp;&amp; dtv[1 + cnt].pointer.val != TLS_DTV_UNALLOCATED)
            free (dtv[1 + cnt].pointer.val);
    memset (dtv, &lsquo;\0&rsquo;, (dtv[-1].counter + 1) * sizeof (dtv_t));</p>

<pre><code>/* Re-initialize the TLS.  */
_dl_allocate_tls_init (TLS_TPADJ (result));
</code></pre>

<p>}
{% endhighlight %}</p>

<p><code>get_cached_stack</code>会把取出的<code>pthread</code>中的dtv重新初始化。<strong>注意 <code>_dl_allocate_tls_init</code> 中是根据模块列表来初始化dtv数组的。</strong></p>

<h3>实验</h3>

<p>当一个线程退出后，它就可能被当做cache被<code>get_cached_stack</code>取出复用。</p>

<p>使用<code>g++ -o thread -g -Wall -lpthread -ldl thread.cpp -DTEST_CACHE_STACK</code>编译程序，运行：</p>

<pre><code>$ ./thread
..
pthread 0x413c9940, dtv 0x1be46a0
... 
pthread 0x413c9940, dtv 0x1be46a0
</code></pre>

<h2>回顾BUG</h2>

<p>当新创建的线程复用了之前退出的线程堆栈时，由于在<code>_dl_allocate_tls_init</code>中初始化dtv数组时是根据当前载入的模块数量而定。如果在这个时候模块数已经超过了这个复用的dtv数组大小，那么就会出现写入非法的内存。使用valgrind检测就会得到本文开头提到的结果。</p>

<p>由于dtv数组大小通常会稍微大点，所以在新加载的模块数量不够多时程序还不会有问题。可以通过控制测试程序中<code>SO_CNT</code>的大小看看dtv中内容的变化。</p>

<p>另外，我查看了下glibc的更新历史，到目前为止(2.20)这个BUG还没有修复。</p>

<h2>参考文档</h2>

<ul>
<li><a href="https://sourceware.org/bugzilla/show_bug.cgi?id=13862">glibc Bug 13862 - Reuse of cached stack can cause bounds overrun of thread DTV</a></li>
<li><a href="http://tsecer.blog.163.com/blog/static/1501817201172883556743/">gLibc TLS实现</a></li>
<li><a href="http://blog.chinaunix.net/uid-24774106-id-3651266.html">Linux线程之线程栈</a></li>
<li><a href="http://www.longene.org/forum/viewtopic.php?f=17&amp;t=429">Linux用户空间线程管理介绍之二：创建线程堆栈</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅析静态库链接原理]]></title>
    <link href="http://codemacro.com/2014/09/15/inside-static-library/"/>
    <updated>2014-09-15T00:00:00+08:00</updated>
    <id>http://codemacro.com/2014/09/15/inside-static-library</id>
    <content type="html"><![CDATA[<p>静态库的链接基本上同链接目标文件<code>.obj/.o</code>相同，但也有些不同的地方。本文简要描述linux下静态库在链接过程中的一些细节。</p>

<h2>静态库文件格式</h2>

<p>静态库远远不同于动态库，不涉及到符号重定位之类的问题。静态库本质上只是将一堆目标文件进行打包而已。静态库没有标准，不同的linux下都会有些细微的差别。大致的格式<a href="http://en.wikipedia.org/wiki/Ar_%28Unix%29#File_format_details">wiki</a>上描述的较清楚：</p>

<pre><code>Global header
-----------------        +-------------------------------
File header 1       ---&gt; | File name
File content 1  |        | File modification timestamp 
-----------------        | Owner ID
File header 2            | Group ID
File content 2           | File mode
-----------------        | File size in bytes
...                      | File magic
                         +-------------------------------
</code></pre>

<p><code>File header</code>很多字段都是以ASCII码表示，所以可以用文本编辑器打开。</p>

<p>静态库本质上就是使用<code>ar</code>命令打包一堆<code>.o</code>文件。我们甚至可以用<code>ar</code>随意打包一些文件：</p>

<pre><code>$ echo 'hello' &gt; a.txt &amp;&amp; echo 'world' &gt; b.txt
$ ar -r test.a a.txt b.txt
$ cat test.a
!&lt;arch&gt;
a.txt/          1410628755  60833 100   100644  6         `
hello
b.txt/          1410628755  60833 100   100644  6         `
world
</code></pre>

<!-- more -->


<h2>链接过程</h2>

<p>链接器在链接静态库时，同链接一般的<code>.o</code>基本相似。链接过程大致可以归纳下图：</p>

<p><img src="/assets/res/link-process.png" alt="" /></p>

<p>总结为：</p>

<ul>
<li><strong>所有传入链接器的<code>.o</code>都会被链接进最终的可执行程序</strong>；链接<code>.o</code>时，会将<code>.o</code>中的<code>global symbol</code>和<code>unresolved symbol</code>放入一个临时表</li>
<li>如果多个<code>.o</code>定义了相同的<code>global symbol</code>，那么就会得到多重定义的链接错误</li>
<li>如果链接结束了，<code>unresolved symbol</code>表不为空，那么就会得到符号未定义的链接错误</li>
<li><code>.a</code>静态库处理本质上就是处理其中的每一个<code>.o</code>，不同的是，如果某个<code>.o</code>中没有一个符号属于<code>unresolved symbol</code>表，也就是链接器此时怀疑该<code>.o</code>没有必要，那么其就会被忽略</li>
</ul>


<p>可以通过一些代码来展示以上过程。在开发C++程序时，可以利用文件静态变量会先于<code>main</code>之前执行做一些可能利于程序结构的事情。如果某个<code>.o</code>（包含静态库中打包的<code>.o</code>）被链接进程序，那么其文件静态变量就会先于<code>main</code>初始化。</p>

<p>{% highlight c++ %}
// test.cpp</p>

<h1>include &lt;stdio.h></h1>

<p>class Test {
public:
    Test() {
        printf(&ldquo;Test ctor\n&rdquo;);
    }
};</p>

<p>static Test s_test;</p>

<p>// lib.cpp</p>

<h1>include &lt;stdio.h></h1>

<p>class Lib {
public:
    Lib() {
        printf(&ldquo;Lib ctor\n&rdquo;);
    }
};</p>

<p>static Lib s_lib;</p>

<p>// main.cpp</p>

<h1>include &lt;stdio.h></h1>

<p>int main() {
    printf(&ldquo;main\n&rdquo;);
    return 0;
}
{% endhighlight %}</p>

<p>以上代码<code>main.cpp</code>中未引用任何<code>test.cpp``lib.cpp</code>中的符号：</p>

<pre><code>$ g++ -o test test.o lib.o main.o
$ ./test
Lib ctor
Test ctor
main
</code></pre>

<p>生成的可执行程序执行如预期，其链接了<code>test.o``lib.o</code>。但是如果把<code>lib.o</code>以静态库的形式进行链接，情况就不一样了：为了做对比，基于以上的代码再加一个文件，及修改<code>main.cpp</code>：</p>

<p>{% highlight c++ %}
// libfn.cpp
int sum(int a, int b) {
    return a + b;
}</p>

<p>// main.cpp</p>

<h1>include &lt;stdio.h></h1>

<p>int main() {
    printf(&ldquo;main\n&rdquo;);
    extern int sum(int, int);
    printf(&ldquo;sum: %d\n&rdquo;, sum(2, 3));
    return 0;
}
{% endhighlight %}</p>

<p>将<code>libfn.o</code>和<code>lib.o</code>创建为静态库：</p>

<pre><code>$ ar -r libfn.a libfn.o lib.o
$ g++ -o test main.o test.o -lfn -L.
$ ./test
Test ctor
main
sum: 5
</code></pre>

<p>因为<code>lib.o</code>没有被链接，导致其文件静态变量也未得到初始化。</p>

<p>调整链接顺序，可以进一步检验前面的链接过程：</p>

<pre><code># 将libfn.a的链接放在main.o前面

$ g++ -o test test.o -lfn main.o  -L.
main.o: In function `main':
main.cpp:(.text+0x19): undefined reference to `sum(int, int)'
collect2: ld returned 1 exit status
</code></pre>

<p>这个问题遇到得比较多，也有点让人觉得莫名其妙。其原因就在于链接器在链接<code>libfn.a</code>的时候，发现<code>libfn.o</code>依然没有<strong>被之前链接的<code>*.o</code>引用到，也就是没有任何符号在<code>unresolved symbol table</code>中</strong>，所以<code>libfn.o</code>也被忽略。</p>

<h2>一些实践</h2>

<p>在实际开发中还会遇到一些静态库相关的问题。</p>

<h3>链接顺序问题</h3>

<p>前面的例子已经展示了这个问题。<strong>调整库的链接顺序</strong>可以解决大部分问题，但当静态库之间存在环形依赖时，则无法通过调整顺序来解决。</p>

<h4>-whole-archive</h4>

<p><code>-whole-archive</code>选项告诉链接器把静态库中的所有<code>.o</code>都进行链接，针对以上例子：</p>

<pre><code>$ g++ -o test -L. test.o -Wl,--whole-archive -lfn main.o -Wl,--no-whole-archive
$ ./test
Lib ctor
Test ctor
main
sum: 5
</code></pre>

<p>连<code>lib.o</code>也被链接了进来。<em><code>-Wl</code>选项告诉gcc将其作为链接器参数传入；之所以在命令行结尾加上<code>--no-whole-archive</code>是为了告诉编译器不要链接gcc默认的库</em></p>

<p>可以看出这个方法还是有点暴力了。</p>

<h4>&ndash;start-group</h4>

<p>格式为：</p>

<pre><code>--start-group archives --end-group
</code></pre>

<p>位于<code>--start-group</code>  <code>--end-group</code>中的所有静态库将被反复搜索，而不是默认的只搜索一次，直到不再有新的<code>unresolved symbol</code>产生为止。也就是说，出现在这里的<code>.o</code>如果发现有<code>unresolved symbol</code>，则可能回到之前的静态库中继续搜索。</p>

<pre><code>$ g++ -o test -L. test.o -Wl,--start-group -lfn main.o -Wl,--end-group
$ ./test
Test ctor
main
sum: 5
</code></pre>

<p>查看<code>ldd</code>关于该参数的man page还可以一窥链接过程的细节：</p>

<blockquote><p>The specified archives are searched repeatedly until no new undefined references are created. Normally, an archive is searched only once in the order that it is specified on the command line. If a symbol in that archive is needed to resolve an undefined symbol referred to by an object in an archive that appears later on the command line, the linker would not be able to resolve that reference. By grouping the archives, they all be searched repeatedly until all possible references are resolved.</p></blockquote>

<h3>嵌套静态库</h3>

<p>由于<code>ar</code>创建静态库时本质上只是对文件进行打包，所以甚至可以创建一个嵌套的静态库，从而测试链接器是否会递归处理静态库中的<code>.o</code>：</p>

<pre><code>$ ar -r libfn.a libfn.o
$ ar -r liboutfn.a libfn.a lib.o
$ g++ -o test -L. test.o main.o -loutfn
main.o: In function `main':
main.cpp:(.text+0x19): undefined reference to `sum(int, int)'
collect2: ld returned 1 exit status
</code></pre>

<p><strong>可见链接器并不会递归处理静态库中的文件</strong></p>

<p>之所以要提到嵌套静态库这个问题，是因为我发现很多时候我们喜欢为一个静态库工程链接其他静态库。当然，这里的链接并非真正的链接（仅是打包），这个过程当然可以聪明到将其他静态库里的<code>.o</code>提取出来然后打包到新的静态库。</p>

<p>如果我们使用的是类似<a href="http://www.scons.org/">scons</a>这种封装更高的依赖项管理工具，那么它是否会这样干呢？</p>

<p>基于之前的例子，我们使用scons来创建<code>liboutfn.a</code>：</p>

<pre><code># Sconstruct
StaticLibrary('liboutfn.a', ['libfn.a', 'lib.o'])
</code></pre>

<p>使用文本编辑器打开<code>liboutfn.a</code>就可以看到其内容，或者使用：</p>

<pre><code>$ ar -tv liboutfn.a
rw-r--r-- 60833/100   1474 Sep 14 02:59 2014 libfn.a
rw-r--r-- 60833/100   2448 Sep 14 02:16 2014 lib.o
</code></pre>

<p>可见scons也只是单纯地打包。<strong>所以，在scons中构建一个静态库时，再<code>链接</code>其他静态库是没有意义的</strong></p>

<h2>参考文档</h2>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Ar_%28Unix%29#File_format_details">ar (Unix)</a></li>
<li><a href="http://linux.die.net/man/1/ld">ld man page</a></li>
<li><a href="http://wen00072-blog.logdown.com/posts/188339-study-on-the-gnu-ld">GNU ld初探</a></li>
<li><a href="http://eli.thegreenplace.net/2013/07/09/library-order-in-static-linking/">Library order in static linking</a></li>
<li><a href="http://www.linuxjournal.com/article/6463?page=0,1">Linkers and Loaders</a></li>
<li><a href="http://www.scons.org/doc/0.96.1/HTML/scons-user/c549.html">scons Building and Linking with Libraries</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++构造/析构函数中的多态(二)]]></title>
    <link href="http://codemacro.com/2014/09/06/necessary-dtor/"/>
    <updated>2014-09-06T00:00:00+08:00</updated>
    <id>http://codemacro.com/2014/09/06/necessary-dtor</id>
    <content type="html"><![CDATA[<p>本来是几年以前写的一篇博客：<a href="http://codemacro.com/2012/09/17/c-plus-plus-ctor-virtual/">C++陷阱：构造函数中的多态</a>。然后有同学在评论中讨论了起来，为了记录我就在这里单独写一篇，基本上就是用编译器的实现去证明了早就被大家熟知的一些结论。</p>

<p><strong>默认构造函数/析构函数不是在所有情况下都会被生成出来的。</strong>为此我还特地翻出《Inside C++ object model》：</p>

<blockquote><p>2.1 Default Constructor Construction</p>

<p>The C++ Annotated Reference Manual (ARM) [ELLIS90] (Section 12.1) tells us that &ldquo;default constructors…are generated (by the compiler) where needed….&rdquo;</p></blockquote>

<p>后面别人还罗列了好些例子告诉你哪些情况才算<code>needed</code>。本文我就解释<code>构造函数中的多态</code>评论中的问题。</p>

<!-- more -->


<p>实验代码如下：</p>

<p>{% highlight c++ %}</p>

<h1>include &lt;stdio.h></h1>

<p>class Base {
public:
    Base() {
        Init();
    }</p>

<pre><code>//virtual
 ~Base() {
    printf("Base dtor\n");
    Release();
}

virtual void Init() {
    printf("Base::Init\n");
}

virtual void Release() {
    printf("Base::Release\n");
}
</code></pre>

<p>};</p>

<p>class Derived : public Base {
public:
    /<em>
    ~Derived() {
        printf(&ldquo;Derived dtor\n&rdquo;);
    } // </em>/</p>

<pre><code>virtual void Init() {
    printf("Derived::Init\n");
}

virtual void Release() {
    printf("Derived:Release\n");
}
</code></pre>

<p>};</p>

<p>int main()
{
    Base *obj = new Derived();
    delete obj;
    return 0;
}
{% endhighlight %}</p>

<p>去掉<code>Derived</code>的析构函数，去掉<code>Base</code>析构函数的<code>virtual</code>：</p>

<pre><code># g++ -Wa,-adhln -g test.cpp &gt; test.s

  44:test.cpp      ****     delete obj;
 227                    .loc 1 44 0
 228 0028 488B45F0      movq    -16(%rbp), %rax
 229 002c 488945E0      movq    %rax, -32(%rbp)
 230 0030 48837DE0      cmpq    $0, -32(%rbp)       
 230      00
 231 0035 7520          jne .L17                   
 232 0037 EB30          jmp .L18
...
 244                .L17:
 245                    .loc 1 44 0
 246 0057 488B7DE0      movq    -32(%rbp), %rdi
 247 005b E8000000      call    _ZN4BaseD1Ev             # 直接call
</code></pre>

<p>从这里甚至可以看到<code>delete</code>对空指针的判定。<code>Base</code>的析构函数不是<code>virtual</code>，所以这里编译器生成的析构函数调用代码根本不需要用到<code>vptr</code>，直接<code>call</code>就可以。而具体<code>call</code>谁则是根据<code>obj</code>指向的类型<code>Base</code>确定。<em>即使<code>Derived</code>用户定义了析构函数也不会调用，无论是否<code>virtual</code>。</em></p>

<p>事实上编译器甚至不需要生成<code>Derived</code>的析构函数，<em>多傻的编译器才会生成这些什么事都不做的代码而光进出函数就得好几条指令？</em></p>

<p>查看程序中的符号，没有生成<code>Derived</code>析构函数：</p>

<pre><code># nm test
...
0000000000400816 W _ZN4Base4InitEv
00000000004007fe W _ZN4Base7ReleaseEv
000000000040082e W _ZN4BaseC2Ev
0000000000400876 W _ZN4BaseD1Ev             
00000000004007e6 W _ZN7Derived4InitEv
00000000004007ce W _ZN7Derived7ReleaseEv
0000000000400852 W _ZN7DerivedC1Ev
...
</code></pre>

<p>现在把<code>Base</code>析构函数变为<code>virtual</code>的：</p>

<pre><code>  44:test.cpp      ****     delete obj;
 170                    .loc 1 44 0
 171 0028 48837DF0      cmpq    $0, -16(%rbp)
 171      00
 172 002d 7520          jne .L12
 173 002f EB32          jmp .L13
...
 185                .L12:
 186                    .loc 1 44 0
 187 004f 488B45F0      movq    -16(%rbp), %rax     # this -&gt; rax
 188 0053 488B00        movq    (%rax), %rax        # *rax -&gt; vptr
 189 0056 4883C008      addq    $8, %rax            # vptr += 8
 190 005a 488B00        movq    (%rax), %rax        # *vptr -&gt; Base::~Base
 191 005d 488B7DF0      movq    -16(%rbp), %rdi     # this as first argument (passed by rdi)
 192 0061 FFD0          call    *%rax               # call
</code></pre>

<p>析构函数动态调用这也是预期的。至于为什么是偏移<code>vptr+8</code>，是因为第一个指针指向的是<code>type_info</code>，具体可看<a href="http://www.cnblogs.com/zhyg6516/archive/2011/03/07/1971898.html">浅议 Dynamic_cast 和 RTTI</a>。<em>vptr和virtual function table还需要详述吗？</em></p>

<p>此时就会生成<code>Derived</code>的析构函数：</p>

<pre><code>...
000000000040084c W _ZN4Base4InitEv
00000000004008ac W _ZN4Base7ReleaseEv
0000000000400864 W _ZN4BaseC2Ev
0000000000400970 W _ZN4BaseD0Ev
00000000004009b0 W _ZN4BaseD1Ev
00000000004008c4 W _ZN4BaseD2Ev
0000000000400834 W _ZN7Derived4InitEv
000000000040081c W _ZN7Derived7ReleaseEv
0000000000400888 W _ZN7DerivedC1Ev
0000000000400904 W _ZN7DerivedD0Ev          
000000000040093a W _ZN7DerivedD1Ev
...
</code></pre>

<p>细心的人就会发现无论是<code>Base</code>还是<code>Derived</code>都会生成多个析构函数，这个深入下去还有很多内容，具体可以参看：<a href="http://stackoverflow.com/questions/6613870/gnu-gcc-g-why-does-it-generate-multiple-dtors">GNU GCC (g++): Why does it generate multiple dtors?</a>。</p>

<p>甚至可以运行这个例子看到调用到了<code>Derived</code>的析构函数：</p>

<pre><code>(gdb) ni
0x000000000040080d      45          return 0;
1: x/3i $pc
0x40080d &lt;main()+117&gt;:  callq  *%rax                  # 调用
0x40080f &lt;main()+119&gt;:  mov    $0x0,%eax
0x400814 &lt;main()+124&gt;:  add    $0x28,%rsp
(gdb) si
Derived::~Derived (this=0x7ffff7ffd000, __in_chrg=&lt;value optimized out&gt;) at test.cpp:24
24      class Derived : public Base {
1: x/3i $pc
0x400904 &lt;Derived::~Derived()&gt;: push   %rbp
0x400905 &lt;Derived::~Derived()+1&gt;:       mov    %rsp,%rbp
0x400908 &lt;Derived::~Derived()+4&gt;:       sub    $0x10,%rsp
</code></pre>

<p>其实看<code>Derived</code>的析构函数实现会发现很多有趣的东西：</p>

<pre><code>(gdb) disassemble 'Derived::~Derived'
Dump of assembler code for function Derived::~Derived():
0x0000000000400904 &lt;Derived::~Derived()+0&gt;:     push   %rbp
0x0000000000400905 &lt;Derived::~Derived()+1&gt;:     mov    %rsp,%rbp
0x0000000000400908 &lt;Derived::~Derived()+4&gt;:     sub    $0x10,%rsp
0x000000000040090c &lt;Derived::~Derived()+8&gt;:     mov    %rdi,-0x8(%rbp)
0x0000000000400910 &lt;Derived::~Derived()+12&gt;:    mov    $0x400b50,%edx
0x0000000000400915 &lt;Derived::~Derived()+17&gt;:    mov    -0x8(%rbp),%rax
0x0000000000400919 &lt;Derived::~Derived()+21&gt;:    mov    %rdx,(%rax)
0x000000000040091c &lt;Derived::~Derived()+24&gt;:    mov    -0x8(%rbp),%rdi
0x0000000000400920 &lt;Derived::~Derived()+28&gt;:    callq  0x4008c4 &lt;Base::~Base()&gt;
0x0000000000400925 &lt;Derived::~Derived()+33&gt;:    mov    $0x1,%eax
0x000000000040092a &lt;Derived::~Derived()+38&gt;:    test   %al,%al
0x000000000040092c &lt;Derived::~Derived()+40&gt;:    je     0x400937 &lt;Derived::~Derived()+51&gt;
0x000000000040092e &lt;Derived::~Derived()+42&gt;:    mov    -0x8(%rbp),%rdi
0x0000000000400932 &lt;Derived::~Derived()+46&gt;:    callq  0x400670 &lt;_ZdlPv@plt&gt;               
0x0000000000400937 &lt;Derived::~Derived()+51&gt;:    leaveq
0x0000000000400938 &lt;Derived::~Derived()+52&gt;:    retq
</code></pre>

<p>实际上这个析构函数就是上面的<code>D0</code>版本，它做了一件重要的事就是<code>delete this</code>。具体的可以google gcc对析构函数的实现。</p>

<p>构造函数和析构函数中根本就不会启用多态，这个是结论或者说是标准，但不是原因(真怕又有人告诉我c++ standard某section这样写的所以这就是理由)。既然反正已经看实现了，就索性看一眼编译器怎么处理这个问题：</p>

<pre><code>// Base::~Base
 261 0000 55            pushq   %rbp
 262                .LCFI22:
 263 0001 4889E5        movq    %rsp, %rbp
 264                .LCFI23:
 265 0004 4883EC10      subq    $16, %rsp
 266                .LCFI24:
 267 0008 48897DF8      movq    %rdi, -8(%rbp)
 268                    .loc 1 10 0
 269 000c BA000000      movl    $_ZTV4Base+16, %edx
 269      00
 270 0011 488B45F8      movq    -8(%rbp), %rax
 271 0015 488910        movq    %rdx, (%rax)
 272                    .loc 1 11 0
 273 0018 BF000000      movl    $.LC4, %edi
 273      00
 274 001d E8000000      call    puts
 274      00
 275                    .loc 1 12 0
 276 0022 488B7DF8      movq    -8(%rbp), %rdi
 277 0026 E8000000      call    _ZN4Base7ReleaseEv  # 直接call绝对地址
</code></pre>

<p>构造函数一样：</p>

<pre><code>  94 0000 55            pushq   %rbp
  95                .LCFI9:
  96 0001 4889E5        movq    %rsp, %rbp
  97                .LCFI10:
  98 0004 4883EC10      subq    $16, %rsp
  99                .LCFI11:
 100 0008 48897DF8      movq    %rdi, -8(%rbp)
 101                .LBB2:
 102                    .loc 1 5 0
 103 000c B8000000      movl    $_ZTV4Base+16, %eax
 103      00
 104 0011 488B55F8      movq    -8(%rbp), %rdx
 105 0015 488902        movq    %rax, (%rdx)
 106                    .loc 1 6 0
 107 0018 488B7DF8      movq    -8(%rbp), %rdi
 108 001c E8000000      call    _ZN4Base4InitEv  # 直接call地址
</code></pre>

<p><em>END</em></p>
]]></content>
  </entry>
  
</feed>
